Disassembly Listing for Klondike
Generated From:
/home/chris/Dev/klondike/firmware/Klondike.X/dist/Klondike/production/Klondike.X.production.cof
Jun 7, 2013 10:44:33 PM

---  /opt/microchip/xc8/v1.12/sources/wmul.c  -----------------------------------------------------------
1:             unsigned int
2:             __wmul(unsigned int multiplier, unsigned int multiplicand)
3:             {
4:             	unsigned int	product = 0;
0A86  01A4     CLRF 0x24
5:             
6:             	do {
7:             		if(multiplier & 1)
0A88  1C20     BTFSS BDT, 0x0
0A89  2A8E     GOTO 0x28E
8:             			product += multiplicand;
0A8A  0822     MOVF 0x22, W
0A8B  07A4     ADDWF 0x24, F
0A8C  0823     MOVF 0x23, W
0A8D  3DA5     ADDWFC 0x25, F
9:             		multiplicand <<= 1;
0A8E  35A2     LSLF 0x22, F
0A8F  0DA3     RLF 0x23, F
10:            		multiplier >>= 1;
0A90  36A1     LSRF 0x21, F
0A91  0CA0     RRF BDT, F
11:            	} while(multiplier != 0);
0A92  0821     MOVF 0x21, W
0A93  0420     IORWF BDT, W
0A94  1D03     BTFSS STATUS, 0x2
0A95  2A88     GOTO 0x288
12:            	return product;
0A96  0825     MOVF 0x25, W
0A97  00A1     MOVWF 0x21
0A98  0824     MOVF 0x24, W
0A99  00A0     MOVWF BDT
13:            }
0A9A  0008     RETURN
---  /opt/microchip/xc8/v1.12/sources/memset.c  ---------------------------------------------------------
1:             #include	<string.h>
2:             
3:             #ifdef _PIC16
4:             far void *
5:             memset(far void * p1, int c, register size_t n)
6:             #else /*  _PIC16 */
7:             void *
8:             memset(void * p1, int c, register size_t n)
9:             #endif /* _PIC16 */
10:            {
11:            
12:            #ifdef _PIC16
13:            	register far char *	p;
14:            #else /*  _PIC16 */
15:            	register char *		p;
16:            #endif /* _PIC16 */
17:            
18:            	p = p1;
0736  0871     MOVF data, W
0737  00F8     MOVWF 0x78
0738  0870     MOVF dir, W
0739  00F7     MOVWF p
19:            	while(n--)
073A  3001     MOVLW 0x1
073B  02F4     SUBWF i_750, F
073C  3000     MOVLW 0x0
073D  3BF5     SUBWFB i, F
073E  0A74     INCF i_750, W
073F  1903     BTFSC STATUS, 0x2
0740  0A75     INCF i, W
0741  1903     BTFSC STATUS, 0x2
0742  0008     RETURN
074E  2F3A     GOTO 0x73A
20:            		*p++ = c;
0743  0872     MOVF p, W
0744  00F6     MOVWF handle
0745  0877     MOVF p, W
0746  0086     MOVWF FSR1L
0747  0878     MOVF 0x78, W
0748  0087     MOVWF FSR1H
0749  0876     MOVF handle, W
074A  0081     MOVWF INDF1
074B  0AF7     INCF p, F
074C  1903     BTFSC STATUS, 0x2
074D  0AF8     INCF 0x78, F
21:            	return p1;
22:            }
074F  0020     MOVLB 0x0
---  /opt/microchip/xc8/v1.12/sources/lwdiv.c  ----------------------------------------------------------
1:             // word unsigned division
2:             
3:             unsigned int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __lwdiv(unsigned int divisor, unsigned int dividend)
7:             #else
8:             __lwdiv(unsigned int dividend, unsigned int divisor)
9:             #endif
0A9B  01A5     CLRF 0x25
0A9C  01A6     CLRF 0x26
10:            {
0A9D  0821     MOVF 0x21, W
0A9E  0420     IORWF BDT, W
0A9F  1903     BTFSC STATUS, 0x2
0AA0  2ABB     GOTO 0x2BB
11:            	unsigned int	quotient;
0AA1  01A4     CLRF 0x24
12:            	unsigned char	counter;
0AA3  1BA1     BTFSC 0x21, 0x7
0AA4  2AA8     GOTO 0x2A8
0AA7  2AA2     GOTO 0x2A2
13:            
0AA5  35A0     LSLF BDT, F
0AA6  0DA1     RLF 0x21, F
14:            	quotient = 0;
0AA2  0AA4     INCF 0x24, F
15:            	if(divisor != 0) {
16:            		counter = 1;
17:            		while((divisor & 0x8000) == 0) {
0AA8  35A5     LSLF 0x25, F
0AA9  0DA6     RLF 0x26, F
18:            			divisor <<= 1;
0AAA  0821     MOVF 0x21, W
0AAB  0223     SUBWF 0x23, W
0AAC  1D03     BTFSS STATUS, 0x2
0AAD  2AB0     GOTO 0x2B0
0AAE  0820     MOVF BDT, W
0AAF  0222     SUBWF 0x22, W
0AB0  1C03     BTFSS STATUS, 0x0
0AB1  2AB7     GOTO 0x2B7
19:            			counter++;
0AB2  0820     MOVF BDT, W
0AB3  02A2     SUBWF 0x22, F
0AB4  0821     MOVF 0x21, W
0AB5  3BA3     SUBWFB 0x23, F
20:            		}
0AB6  1425     BSF 0x25, 0x0
21:            		do {
22:            			quotient <<= 1;
0AB7  36A1     LSRF 0x21, F
0AB8  0CA0     RRF BDT, F
23:            			if(divisor <= dividend) {
0AB9  0BA4     DECFSZ 0x24, F
0ABA  2AA8     GOTO 0x2A8
24:            				dividend -= divisor;
25:            				quotient |= 1;
0ABB  0826     MOVF 0x26, W
0ABC  00A1     MOVWF 0x21
0ABD  0825     MOVF 0x25, W
0ABE  00A0     MOVWF BDT
26:            			}
0ABF  0008     RETURN
27:            			divisor >>= 1;
28:            		} while(--counter != 0);
29:            	}
30:            	return quotient;
31:            }
---  /opt/microchip/xc8/v1.12/sources/bmul.c  -----------------------------------------------------------
1:             unsigned char
2:             __bmul(unsigned char multiplier, unsigned char multiplicand)
3:             {
0DE7  00A2     MOVWF 0x22
4:             	unsigned char	product = 0;
0DE8  01A1     CLRF 0x21
5:             
6:             	do {
7:             		if(multiplier & 1)
0DEA  1822     BTFSC 0x22, 0x0
8:             			product += multiplicand;
0DE9  0820     MOVF BDT, W
0DEB  07A1     ADDWF 0x21, F
9:             		multiplicand <<= 1;
0DEC  35A0     LSLF BDT, F
10:            		multiplier >>= 1;
0DED  36A2     LSRF 0x22, F
11:            	} while(multiplier != 0);
0DEE  08A2     MOVF 0x22, F
0DEF  1D03     BTFSS STATUS, 0x2
0DF0  2DE9     GOTO 0x5E9
12:            	return product;
0DF1  0821     MOVF 0x21, W
13:            }
0DF2  0008     RETURN
14:            
---  /opt/microchip/xc8/v1.12/sources/awdiv.c  ----------------------------------------------------------
1:             // integer signed division
2:             
3:             signed int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __awdiv(signed int divisor, signed int dividend)
7:             #else
8:             __awdiv(signed int dividend, signed int divisor)
9:             #endif
0FC0  01A5     CLRF 0x25
10:            {
0FC1  1FA1     BTFSS 0x21, 0x7
0FC2  2FCA     GOTO 0x7CA
11:            	signed int	quotient;
0FC3  09A0     COMF BDT, F
0FC4  09A1     COMF 0x21, F
0FC5  0AA0     INCF BDT, F
0FC6  1903     BTFSC STATUS, 0x2
0FC7  0AA1     INCF 0x21, F
12:            	unsigned char	counter, sign;
0FC8  01A5     CLRF 0x25
0FC9  0AA5     INCF 0x25, F
13:            
14:            	sign = 0;
0FCA  1FA3     BTFSS 0x23, 0x7
0FCB  2FD3     GOTO 0x7D3
15:            	if(divisor < 0) {
0FCC  09A2     COMF 0x22, F
0FCD  09A3     COMF 0x23, F
0FCE  0AA2     INCF 0x22, F
0FCF  1903     BTFSC STATUS, 0x2
0FD0  0AA3     INCF 0x23, F
16:            		divisor = -divisor;
0FD1  3001     MOVLW 0x1
0FD2  06A5     XORWF 0x25, F
17:            		sign = 1;
18:            	}
0FD3  01A6     CLRF 0x26
0FD4  01A7     CLRF 0x27
19:            	if(dividend < 0) {
0FD5  0821     MOVF 0x21, W
0FD6  0420     IORWF BDT, W
0FD7  1903     BTFSC STATUS, 0x2
0FD8  2FF3     GOTO 0x7F3
20:            		dividend = -dividend;
0FD9  01A4     CLRF 0x24
21:            		sign ^= 1;
0FDB  1BA1     BTFSC 0x21, 0x7
0FDC  2FE0     GOTO 0x7E0
0FDF  2FDA     GOTO 0x7DA
22:            	}
0FDD  35A0     LSLF BDT, F
0FDE  0DA1     RLF 0x21, F
23:            	quotient = 0;
0FDA  0AA4     INCF 0x24, F
24:            	if(divisor != 0) {
25:            		counter = 1;
26:            		while((divisor & 0x8000U) == 0) {
0FE0  35A6     LSLF 0x26, F
0FE1  0DA7     RLF 0x27, F
27:            			divisor <<= 1;
0FE2  0821     MOVF 0x21, W
0FE3  0223     SUBWF 0x23, W
0FE4  1D03     BTFSS STATUS, 0x2
0FE5  2FE8     GOTO 0x7E8
0FE6  0820     MOVF BDT, W
0FE7  0222     SUBWF 0x22, W
0FE8  1C03     BTFSS STATUS, 0x0
0FE9  2FEF     GOTO 0x7EF
28:            			counter++;
0FEA  0820     MOVF BDT, W
0FEB  02A2     SUBWF 0x22, F
0FEC  0821     MOVF 0x21, W
0FED  3BA3     SUBWFB 0x23, F
29:            		}
0FEE  1426     BSF 0x26, 0x0
30:            		do {
31:            			quotient <<= 1;
0FEF  36A1     LSRF 0x21, F
0FF0  0CA0     RRF BDT, F
32:            			if((unsigned int)divisor <= (unsigned int)dividend) {
0FF1  0BA4     DECFSZ 0x24, F
0FF2  2FE0     GOTO 0x7E0
33:            				dividend -= divisor;
34:            				quotient |= 1;
0FF3  0825     MOVF 0x25, W
0FF4  1903     BTFSC STATUS, 0x2
0FF5  2FFB     GOTO 0x7FB
35:            			}
0FF6  09A6     COMF 0x26, F
0FF7  09A7     COMF 0x27, F
0FF8  0AA6     INCF 0x26, F
0FF9  1903     BTFSC STATUS, 0x2
0FFA  0AA7     INCF 0x27, F
36:            			*(unsigned int *)&divisor >>= 1;
0FFB  0827     MOVF 0x27, W
0FFC  00A1     MOVWF 0x21
0FFD  0826     MOVF 0x26, W
0FFE  00A0     MOVWF BDT
37:            		} while(--counter != 0);
0FFF  0008     RETURN
38:            	}
39:            	if(sign)
40:            		quotient = -quotient;
41:            	return quotient;
42:            }
---  /home/chris/Dev/klondike/firmware/main.c  ----------------------------------------------------------
1:             /********
2:              * main.c - main USB cmd loop and dispatch for Klondike mining firmware
3:              *
4:              * Derived from Microchip LPC Dev Kit.
5:              * Supports only PIC16LF1459 processor.
6:              *
7:              * (C) Copyright 2013 Chris Savery. All rights reserved.
8:              *
9:              */
10:            
11:            #include "GenericTypeDefs.h"
12:            #include "Compiler.h"
13:            #include "USB/usb.h"
14:            #include "USB/usb_function_cdc.h"
15:            #include "HardwareProfile.h"
16:            #include "klondike.h"
17:            
18:            #if defined (USE_INTERNAL_OSC)  //Definition in the hardware profile
19:                __CONFIG(FOSC_INTOSC & WDTE_OFF & PWRTE_ON & MCLRE_OFF & CP_OFF & BOREN_ON & CLKOUTEN_OFF & IESO_OFF & FCMEN_OFF);
20:                __CONFIG(WRT_OFF & CPUDIV_NOCLKDIV & USBLSCLK_48MHz & PLLMULT_3x & PLLEN_ENABLED & STVREN_ON &  BORV_LO & LPBOR_OFF & LVP_OFF);
21:            #else
22:                __CONFIG(FOSC_HS & WDTE_OFF & PWRTE_ON & MCLRE_OFF & CP_OFF & BOREN_ON & CLKOUTEN_OFF & IESO_OFF & FCMEN_OFF);
23:                __CONFIG(WRT_OFF & CPUDIV_NOCLKDIV & USBLSCLK_48MHz & PLLMULT_4x & PLLEN_ENABLED & STVREN_ON &  BORV_LO & LPBOR_OFF & LVP_OFF);
24:            #endif
25:             
26:            char USB_In_Buffer[64];
27:            char USB_Out_Buffer[64];
28:            
29:            extern WORKSTATUS Status;
30:            extern BYTE SlaveAddress;
31:            
32:            /** P R I V A T E  P R O T O T Y P E S ***************************************/
33:            static void InitializeSystem(void);
34:            void ProcessIO(void);
35:            void USBDeviceTasks(void);
36:            void USBCBSendResume(void);
37:            void UserInit(void);
38:            
39:            void SendCmdReply(char *cmd, BYTE *ReplyBuf, BYTE count);
40:            
41:            void interrupt ISRCode()
42:            {
0004  3180     MOVLP 0x0
43:                //if(RCIF)
44:                //    ResultDataReady();
45:                if(TMR0IF)
0005  1D0B     BTFSS INTCON, 0x2
0006  280A     GOTO 0xA
46:                    WorkTick();
0007  3197     MOVLP 0x17
0008  2739     CALL 0x739
0009  3180     MOVLP 0x0
47:                //if(ADIF)
48:                //    UpdateTemp();
49:                //if(TMR1GIF)
50:                //    UpdateFanSpeed();
51:                
52:                #if defined(USB_INTERRUPT)
53:                    USBDeviceTasks();
000A  3181     MOVLP 0x1
000B  2149     CALL 0x149
54:                #endif
55:            }
000C  0009     RETFIE
56:            
57:            int main(void)
58:            {   
59:                InitializeSystem();
0857  20D4     CALL 0xD4
0858  3188     MOVLP 0x8
60:            
61:                while(1)
62:                {
63:                    #if defined(USB_INTERRUPT)
64:                        if(USB_BUS_SENSE && (USBGetDeviceState() == DETACHED_STATE))
0859  0022     MOVLB 0x2
085A  08CD     MOVF 0x4D, F
085B  1D03     BTFSS STATUS, 0x2
085C  285F     GOTO 0x5F
65:                        {
66:                            USBDeviceAttach();
085D  20E4     CALL 0xE4
085E  3188     MOVLP 0x8
67:                            
68:                            //if(USBGetDeviceState() == ATTACHED_STATE)
69:                            //    InitI2CMaster();
70:                        }
71:                    #endif
72:            
73:                    #if defined(USB_POLLING)
74:            	// Check bus status and service USB interrupts.
75:                    USBDeviceTasks(); // Interrupt or polling method.  If using polling, must call
76:                    				  // this function periodically.  This function will take care
77:                    				  // of processing and responding to SETUP transactions 
78:                    				  // (such as during the enumeration process when you first
79:                    				  // plug in).  USB hosts require that USB devices should accept
80:                    				  // and process SETUP packets in a timely fashion.  Therefore,
81:                    				  // when using polling, this function should be called 
82:                    				  // regularly (such as once every 1.8ms or faster** [see 
83:                    				  // inline code comments in usb_device.c for explanation when
84:                    				  // "or faster" applies])  In most cases, the USBDeviceTasks() 
85:                    				  // function does not take very long to execute (ex: <100 
86:                    				  // instruction cycles) before it returns.
87:                    #endif
88:            
89:                    if(Status.State == 'P'){
90:                        ;//AsicPushWork();
91:                    }
92:                				  
93:                    ProcessIO();  
085F  2062     CALL 0x62
0860  3188     MOVLP 0x8
0861  2859     GOTO 0x59
94:                          
95:                }//end while
96:            }//end main
0862  3020     MOVLW 0x20
97:            
98:            static void InitializeSystem(void)
99:            {
100:               //Configure all pins for digital mode, except RC2, which has a Thermistor on it
101:               ANSELA = 0x00;
08D4  0023     MOVLB 0x3
08D5  018C     CLRF PORTA
102:               ANSELB = 0x00;
08D6  018D     CLRF PORTB
103:               ANSELC = 0x04;  
08D7  3004     MOVLW 0x4
08D8  008E     MOVWF PORTC
104:           
105:               #if defined (USE_INTERNAL_OSC)
106:                   OSCTUNE = 0;
08D9  0021     MOVLB 0x1
08DA  0198     CLRF T1CON
107:                   OSCCON = 0xFC;          //16MHz HFINTOSC with 3x PLL enabled (48MHz operation)
08DB  30FC     MOVLW 0xFC
08DC  0099     MOVWF T1GCON
108:                   ACTCON = 0x90;          //Enable active clock tuning with USB
08DD  3090     MOVLW 0x90
08DE  0027     MOVLB 0x7
08DF  009B     MOVWF PR2
109:               #endif
110:           
111:               UserInit();
08E0  3187     MOVLP 0x7
08E1  27B1     CALL 0x7B1
112:           
113:               USBDeviceInit();	//usb_device.c.  Initializes USB module SFRs and firmware
08E2  3186     MOVLP 0x6
08E3  2E5E     GOTO 0x65E
114:               					//variables to known states.
115:           }//end InitializeSystem
08E4  08CD     MOVF 0x4D, F
116:           
117:           
118:           void UserInit(void)
119:           {
120:               InitLED();
07B1  0021     MOVLB 0x1
07B2  128C     BCF PORTA, 0x5
07B3  0022     MOVLB 0x2
07B4  168C     BSF PORTA, 0x5
121:               InitThermistor();
07B5  27D2     CALL 0x7D2
07B6  3187     MOVLP 0x7
122:               InitFAN();
07B7  27BC     CALL 0x7BC
07B8  3187     MOVLP 0x7
123:               InitWorkTick();
07B9  27E5     CALL 0x7E5
124:               //InitResultRx();
125:               DetectAsics();
07BA  318F     MOVLP 0xF
07BB  2F24     GOTO 0x724
126:               //InitI2CSlave();
127:               //LED_Off();
128:           
129:           }//end UserInit
07BC  168E     BSF PORTC, 0x5
130:           
131:           void ProcessIO(void)
132:           {   
133:               BYTE numBytesRead;
134:           
135:               if((USBDeviceState < CONFIGURED_STATE)||(USBSuspendControl==1)) {
0862  3020     MOVLW 0x20
0863  024D     SUBWF 0x4D, W
0864  1C03     BTFSS STATUS, 0x0
0865  2885     GOTO 0x85
0866  003D     MOVLB 0x1D
0867  188E     BTFSC PORTC, 0x1
0868  2885     GOTO 0x85
136:           	// should check I2C for cmd data available
137:           	// and call ProcessCmd
138:           	}
139:               else if(USBUSARTIsTxTrfReady()) {
0869  0022     MOVLB 0x2
086A  08D4     MOVF 0x54, F
086B  1D03     BTFSS STATUS, 0x2
086C  2885     GOTO 0x85
140:                   numBytesRead = getsUSBUSART(USB_Out_Buffer, 64);
086D  3040     MOVLW 0x40
086E  0021     MOVLB 0x1
086F  00A7     MOVWF 0x27
0870  30A0     MOVLW 0xA0
0871  2088     CALL 0x88
0872  3188     MOVLP 0x8
0873  00ED     MOVWF 0x6D
141:                   if(numBytesRead != 0) {
0874  086D     MOVF 0x6D, W
0875  1903     BTFSC STATUS, 0x2
0876  2885     GOTO 0x85
142:                       if( USB_Out_Buffer[1] != MASTER_ADDRESS )
0877  0027     MOVLB 0x7
0878  0821     MOVF 0x21, W
0879  1903     BTFSC STATUS, 0x2
087A  2883     GOTO 0x83
143:                           SlaveDataRelay(USB_Out_Buffer, numBytesRead);
087B  0022     MOVLB 0x2
087C  086D     MOVF 0x6D, W
087D  0021     MOVLB 0x1
087E  00A0     MOVWF BDT
087F  30A0     MOVLW 0xA0
0880  2087     CALL 0x87
0881  3188     MOVLP 0x8
0882  2885     GOTO 0x85
144:                       else
145:                           ProcessCmd(USB_Out_Buffer);
0883  30A0     MOVLW 0xA0
0884  20FD     CALL 0xFD
146:                   }
147:               }
148:           
149:               CDCTxService();
0885  3185     MOVLP 0x5
0886  2DA4     GOTO 0x5A4
150:           } //end ProcessIO
0887  0008     RETURN
151:           
152:           void SendCmdReply(char *cmd, BYTE *data, BYTE count)
153:           {
154:               USB_In_Buffer[0] = cmd[0];
0A55  0822     MOVF 0x22, W
0A56  0084     MOVWF FSR0L
0A57  0823     MOVF 0x23, W
0A58  0085     MOVWF FSR0H
0A59  0800     MOVF INDF0, W
0A5A  0028     MOVLB 0x8
0A5B  00A0     MOVWF BDT
155:               USB_In_Buffer[1] = SlaveAddress;
0A5C  01A1     CLRF 0x21
156:               for(BYTE n=0; n < count; n++)
0A5D  0021     MOVLB 0x1
0A5E  01A9     CLRF 0x29
0A5F  0826     MOVF 0x26, W
0A60  0229     SUBWF 0x29, W
0A61  1803     BTFSC STATUS, 0x0
0A62  2A77     GOTO 0x277
0A75  0AA9     INCF 0x29, F
0A76  2A5F     GOTO 0x25F
157:                   USB_In_Buffer[n+2] = data[n];
0A63  0829     MOVF 0x29, W
0A64  3E22     ADDLW 0x22
0A65  0086     MOVWF FSR1L
0A66  3004     MOVLW 0x4
0A67  0087     MOVWF FSR1H
0A68  0825     MOVF 0x25, W
0A69  00A8     MOVWF 0x28
0A6A  0824     MOVF 0x24, W
0A6B  00A7     MOVWF 0x27
0A6C  0829     MOVF 0x29, W
0A6D  0727     ADDWF 0x27, W
0A6E  0084     MOVWF FSR0L
0A6F  0828     MOVF 0x28, W
0A70  1803     BTFSC STATUS, 0x0
0A71  0A28     INCF 0x28, W
0A72  0085     MOVWF FSR0H
0A73  0800     MOVF INDF0, W
0A74  0081     MOVWF INDF1
158:           
159:               if((USBDeviceState < CONFIGURED_STATE)||(USBSuspendControl==1)) {
0A77  3020     MOVLW 0x20
0A78  0022     MOVLB 0x2
0A79  024D     SUBWF 0x4D, W
0A7A  1C03     BTFSS STATUS, 0x0
0A7B  0008     RETURN
0A7C  003D     MOVLB 0x1D
0A7D  188E     BTFSC PORTC, 0x1
0A7E  0008     RETURN
160:           	// send reply via I2C	
161:               }
162:               else
163:                   putUSBUSART(USB_In_Buffer, count+2);
0A7F  0021     MOVLB 0x1
0A80  0826     MOVF 0x26, W
0A81  3E02     ADDLW 0x2
0A82  00A0     MOVWF BDT
0A83  3020     MOVLW 0x20
0A84  3197     MOVLP 0x17
0A85  2F08     GOTO 0x708
164:           }
0A86  01A4     CLRF 0x24
165:           
166:           
167:           // ******************************************************************************************************
168:           // ************** USB Callback Functions ****************************************************************
169:           // ******************************************************************************************************
170:           // The USB firmware stack will call the callback functions USBCBxxx() in response to certain USB related
171:           // events.  For example, if the host PC is powering down, it will stop sending out Start of Frame (SOF)
172:           // packets to your device.  In response to this, all USB devices are supposed to decrease their power
173:           // consumption from the USB Vbus to <2.5mA* each.  The USB module detects this condition (which according
174:           // to the USB specifications is 3+ms of no bus activity/SOF packets) and then calls the USBCBSuspend()
175:           // function.  You should modify these callback functions to take appropriate actions for each of these
176:           // conditions.  For example, in the USBCBSuspend(), you may wish to add code that will decrease power
177:           // consumption from Vbus to <2.5mA (such as by clock switching, turning off LEDs, putting the
178:           // microcontroller to sleep, etc.).  Then, in the USBCBWakeFromSuspend() function, you may then wish to
179:           // add code that undoes the power saving things done in the USBCBSuspend() function.
180:           
181:           // The USBCBSendResume() function is special, in that the USB stack will not automatically call this
182:           // function.  This function is meant to be called from the application firmware instead.  See the
183:           // additional comments near the function.
184:           
185:           // Note *: The "usb_20.pdf" specs indicate 500uA or 2.5mA, depending upon device classification. However,
186:           // the USB-IF has officially issued an ECN (engineering change notice) changing this to 2.5mA for all 
187:           // devices.  Make sure to re-download the latest specifications to get all of the newest ECNs.
188:           
189:           /******************************************************************************
190:            * Function:        void USBCBSuspend(void)
191:            *
192:            * PreCondition:    None
193:            *
194:            * Input:           None
195:            *
196:            * Output:          None
197:            *
198:            * Side Effects:    None
199:            *
200:            * Overview:        Call back that is invoked when a USB suspend is detected
201:            *
202:            * Note:            None
203:            *****************************************************************************/
204:           void USBCBSuspend(void)
205:           {
206:           	//Example power saving code.  Insert appropriate code here for the desired
207:           	//application behavior.  If the microcontroller will be put to sleep, a
208:           	//process similar to that shown below may be used:
209:           	
210:           	//ConfigureIOPinsForLowPower();
211:           	//SaveStateOfAllInterruptEnableBits();
212:           	//DisableAllInterruptEnableBits();
213:           	//EnableOnlyTheInterruptsWhichWillBeUsedToWakeTheMicro();	//should enable at least USBActivityIF as a wake source
214:           	//Sleep();
215:           	//RestoreStateOfAllPreviouslySavedInterruptEnableBits();	//Preferrably, this should be done in the USBCBWakeFromSuspend() function instead.
216:           	//RestoreIOPinsToNormal();									//Preferrably, this should be done in the USBCBWakeFromSuspend() function instead.
217:           
218:           	//IMPORTANT NOTE: Do not clear the USBActivityIF (ACTVIF) bit here.  This bit is 
219:           	//cleared inside the usb_device.c file.  Clearing USBActivityIF here will cause 
220:           	//things to not work as intended.	
221:           	
222:           
223:               #if defined(__C30__) || defined __XC16__
224:                   USBSleepOnSuspend();
225:               #endif
226:           }
03EE  0008     RETURN
227:           
228:           /******************************************************************************
229:            * Function:        void USBCBWakeFromSuspend(void)
230:            *
231:            * PreCondition:    None
232:            *
233:            * Input:           None
234:            *
235:            * Output:          None
236:            *
237:            * Side Effects:    None
238:            *
239:            * Overview:        The host may put USB peripheral devices in low power
240:            *					suspend mode (by "sending" 3+ms of idle).  Once in suspend
241:            *					mode, the host may wake the device back up by sending non-
242:            *					idle state signalling.
243:            *					
244:            *					This call back is invoked when a wakeup from USB suspend 
245:            *					is detected.
246:            *
247:            * Note:            None
248:            *****************************************************************************/
249:           void USBCBWakeFromSuspend(void)
250:           {
251:           	// If clock switching or other power savings measures were taken when
252:           	// executing the USBCBSuspend() function, now would be a good time to
253:           	// switch back to normal full power run mode conditions.  The host allows
254:           	// 10+ milliseconds of wakeup time, after which the device must be 
255:           	// fully back to normal, and capable of receiving and processing USB
256:           	// packets.  In order to do this, the USB module must receive proper
257:           	// clocking (IE: 48MHz clock must be available to SIE for full speed USB
258:           	// operation).  
259:           	// Make sure the selected oscillator settings are consistent with USB 
260:               // operation before returning from this function.
261:           }
03ED  0008     RETURN
262:           
263:           /********************************************************************
264:            * Function:        void USBCB_SOF_Handler(void)
265:            *
266:            * PreCondition:    None
267:            *
268:            * Input:           None
269:            *
270:            * Output:          None
271:            *
272:            * Side Effects:    None
273:            *
274:            * Overview:        The USB host sends out a SOF packet to full-speed
275:            *                  devices every 1 ms. This interrupt may be useful
276:            *                  for isochronous pipes. End designers should
277:            *                  implement callback routine as necessary.
278:            *
279:            * Note:            None
280:            *******************************************************************/
281:           void USBCB_SOF_Handler(void)
282:           {
283:               // No need to clear UIRbits.SOFIF to 0 here.
284:               // Callback caller is already doing that.
285:           
286:           
287:           }
03EC  0008     RETURN
288:           
289:           /*******************************************************************
290:            * Function:        void USBCBErrorHandler(void)
291:            *
292:            * PreCondition:    None
293:            *
294:            * Input:           None
295:            *
296:            * Output:          None
297:            *
298:            * Side Effects:    None
299:            *
300:            * Overview:        The purpose of this callback is mainly for
301:            *                  debugging during development. Check UEIR to see
302:            *                  which error causes the interrupt.
303:            *
304:            * Note:            None
305:            *******************************************************************/
306:           void USBCBErrorHandler(void)
307:           {
308:               // No need to clear UEIR to 0 here.
309:               // Callback caller is already doing that.
310:           
311:           	// Typically, user firmware does not need to do anything special
312:           	// if a USB error occurs.  For example, if the host sends an OUT
313:           	// packet to your device, but the packet gets corrupted (ex:
314:           	// because of a bad connection, or the user unplugs the
315:           	// USB cable during the transmission) this will typically set
316:           	// one or more USB error interrupt flags.  Nothing specific
317:           	// needs to be done however, since the SIE will automatically
318:           	// send a "NAK" packet to the host.  In response to this, the
319:           	// host will normally retry to send the packet again, and no
320:           	// data loss occurs.  The system will typically recover
321:           	// automatically, without the need for application firmware
322:           	// intervention.
323:           	
324:           	// Nevertheless, this callback function is provided, such as
325:           	// for debugging purposes.
326:           }
03EB  0008     RETURN
327:           
328:           
329:           /*******************************************************************
330:            * Function:        void USBCBCheckOtherReq(void)
331:            *
332:            * PreCondition:    None
333:            *
334:            * Input:           None
335:            *
336:            * Output:          None
337:            *
338:            * Side Effects:    None
339:            *
340:            * Overview:        When SETUP packets arrive from the host, some
341:            * 					firmware must process the request and respond
342:            *					appropriately to fulfill the request.  Some of
343:            *					the SETUP packets will be for standard
344:            *					USB "chapter 9" (as in, fulfilling chapter 9 of
345:            *					the official USB specifications) requests, while
346:            *					others may be specific to the USB device class
347:            *					that is being implemented.  For example, a HID
348:            *					class device needs to be able to respond to
349:            *					"GET REPORT" type of requests.  This
350:            *					is not a standard USB chapter 9 request, and 
351:            *					therefore not handled by usb_device.c.  Instead
352:            *					this request should be handled by class specific 
353:            *					firmware, such as that contained in usb_function_hid.c.
354:            *
355:            * Note:            None
356:            *******************************************************************/
357:           void USBCBCheckOtherReq(void)
358:           {
359:               USBCheckCDCRequest();
03E9  3197     MOVLP 0x17
03EA  2FB0     GOTO 0x7B0
360:           }//end
03EB  0008     RETURN
361:           
362:           
363:           /*******************************************************************
364:            * Function:        void USBCBStdSetDscHandler(void)
365:            *
366:            * PreCondition:    None
367:            *
368:            * Input:           None
369:            *
370:            * Output:          None
371:            *
372:            * Side Effects:    None
373:            *
374:            * Overview:        The USBCBStdSetDscHandler() callback function is
375:            *					called when a SETUP, bRequest: SET_DESCRIPTOR request
376:            *					arrives.  Typically SET_DESCRIPTOR requests are
377:            *					not used in most applications, and it is
378:            *					optional to support this type of request.
379:            *
380:            * Note:            None
381:            *******************************************************************/
382:           void USBCBStdSetDscHandler(void)
383:           {
384:               // Must claim session ownership if supporting this request
385:           }//end
03E8  0008     RETURN
386:           
387:           
388:           /*******************************************************************
389:            * Function:        void USBCBInitEP(void)
390:            *
391:            * PreCondition:    None
392:            *
393:            * Input:           None
394:            *
395:            * Output:          None
396:            *
397:            * Side Effects:    None
398:            *
399:            * Overview:        This function is called when the device becomes
400:            *                  initialized, which occurs after the host sends a
401:            * 					SET_CONFIGURATION (wValue not = 0) request.  This 
402:            *					callback function should initialize the endpoints 
403:            *					for the device's usage according to the current 
404:            *					configuration.
405:            *
406:            * Note:            None
407:            *******************************************************************/
408:           void USBCBInitEP(void)
409:           {
410:               //Enable the CDC data endpoints
411:               CDCInitEP();
0349  2B4A     GOTO 0x34A
412:           }
034A  0022     MOVLB 0x2
413:           
414:           /********************************************************************
415:            * Function:        void USBCBSendResume(void)
416:            *
417:            * PreCondition:    None
418:            *
419:            * Input:           None
420:            *
421:            * Output:          None
422:            *
423:            * Side Effects:    None
424:            *
425:            * Overview:        The USB specifications allow some types of USB
426:            * 					peripheral devices to wake up a host PC (such
427:            *					as if it is in a low power suspend to RAM state).
428:            *					This can be a very useful feature in some
429:            *					USB applications, such as an Infrared remote
430:            *					control	receiver.  If a user presses the "power"
431:            *					button on a remote control, it is nice that the
432:            *					IR receiver can detect this signalling, and then
433:            *					send a USB "command" to the PC to wake up.
434:            *					
435:            *					The USBCBSendResume() "callback" function is used
436:            *					to send this special USB signalling which wakes 
437:            *					up the PC.  This function may be called by
438:            *					application firmware to wake up the PC.  This
439:            *					function will only be able to wake up the host if
440:            *                  all of the below are true:
441:            *					
442:            *					1.  The USB driver used on the host PC supports
443:            *						the remote wakeup capability.
444:            *					2.  The USB configuration descriptor indicates
445:            *						the device is remote wakeup capable in the
446:            *						bmAttributes field.
447:            *					3.  The USB host PC is currently sleeping,
448:            *						and has previously sent your device a SET 
449:            *						FEATURE setup packet which "armed" the
450:            *						remote wakeup capability.   
451:            *
452:            *                  If the host has not armed the device to perform remote wakeup,
453:            *                  then this function will return without actually performing a
454:            *                  remote wakeup sequence.  This is the required behavior, 
455:            *                  as a USB device that has not been armed to perform remote 
456:            *                  wakeup must not drive remote wakeup signalling onto the bus;
457:            *                  doing so will cause USB compliance testing failure.
458:            *                  
459:            *					This callback should send a RESUME signal that
460:            *                  has the period of 1-15ms.
461:            *
462:            * Note:            This function does nothing and returns quickly, if the USB
463:            *                  bus and host are not in a suspended condition, or are 
464:            *                  otherwise not in a remote wakeup ready state.  Therefore, it
465:            *                  is safe to optionally call this function regularly, ex: 
466:            *                  anytime application stimulus occurs, as the function will
467:            *                  have no effect, until the bus really is in a state ready
468:            *                  to accept remote wakeup. 
469:            *
470:            *                  When this function executes, it may perform clock switching,
471:            *                  depending upon the application specific code in 
472:            *                  USBCBWakeFromSuspend().  This is needed, since the USB
473:            *                  bus will no longer be suspended by the time this function
474:            *                  returns.  Therefore, the USB module will need to be ready
475:            *                  to receive traffic from the host.
476:            *
477:            *                  The modifiable section in this routine may be changed
478:            *                  to meet the application needs. Current implementation
479:            *                  temporary blocks other functions from executing for a
480:            *                  period of ~3-15 ms depending on the core frequency.
481:            *
482:            *                  According to USB 2.0 specification section 7.1.7.7,
483:            *                  "The remote wakeup device must hold the resume signaling
484:            *                  for at least 1 ms but for no more than 15 ms."
485:            *                  The idea here is to use a delay counter loop, using a
486:            *                  common value that would work over a wide range of core
487:            *                  frequencies.
488:            *                  That value selected is 1800. See table below:
489:            *                  ==========================================================
490:            *                  Core Freq(MHz)      MIP         RESUME Signal Period (ms)
491:            *                  ==========================================================
492:            *                      48              12          1.05
493:            *                       4              1           12.6
494:            *                  ==========================================================
495:            *                  * These timing could be incorrect when using code
496:            *                    optimization or extended instruction mode,
497:            *                    or when having other interrupts enabled.
498:            *                    Make sure to verify using the MPLAB SIM's Stopwatch
499:            *                    and verify the actual signal on an oscilloscope.
500:            *******************************************************************/
501:           void USBCBSendResume(void)
502:           {
503:               static WORD delay_count;
504:               
505:               //First verify that the host has armed us to perform remote wakeup.
506:               //It does this by sending a SET_FEATURE request to enable remote wakeup,
507:               //usually just before the host goes to standby mode (note: it will only
508:               //send this SET_FEATURE request if the configuration descriptor declares
509:               //the device as remote wakeup capable, AND, if the feature is enabled
510:               //on the host (ex: on Windows based hosts, in the device manager 
511:               //properties page for the USB device, power management tab, the 
512:               //"Allow this device to bring the computer out of standby." checkbox 
513:               //should be checked).
514:               if(USBGetRemoteWakeupStatus() == TRUE) 
515:               {
516:                   //Verify that the USB bus is in fact suspended, before we send
517:                   //remote wakeup signalling.
518:                   if(USBIsBusSuspended() == TRUE)
519:                   {
520:                       USBMaskInterrupts();
521:                       
522:                       //Clock switch to settings consistent with normal USB operation.
523:                       USBCBWakeFromSuspend();
524:                       USBSuspendControl = 0; 
525:                       USBBusIsSuspended = FALSE;  //So we don't execute this code again, 
526:                                                   //until a new suspend condition is detected.
527:           
528:                       //Section 7.1.7.7 of the USB 2.0 specifications indicates a USB
529:                       //device must continuously see 5ms+ of idle on the bus, before it sends
530:                       //remote wakeup signalling.  One way to be certain that this parameter
531:                       //gets met, is to add a 2ms+ blocking delay here (2ms plus at 
532:                       //least 3ms from bus idle to USBIsBusSuspended() == TRUE, yeilds
533:                       //5ms+ total delay since start of idle).
534:                       delay_count = 3600U;        
535:                       do
536:                       {
537:                           delay_count--;
538:                       }while(delay_count);
539:                       
540:                       //Now drive the resume K-state signalling onto the USB bus.
541:                       USBResumeControl = 1;       // Start RESUME signaling
542:                       delay_count = 1800U;        // Set RESUME line for 1-13 ms
543:                       do
544:                       {
545:                           delay_count--;
546:                       }while(delay_count);
547:                       USBResumeControl = 0;       //Finished driving resume signalling
548:           
549:                       USBUnmaskInterrupts();
550:                   }
551:               }
552:           }
553:           
554:           
555:           /*******************************************************************
556:            * Function:        void USBCBEP0DataReceived(void)
557:            *
558:            * PreCondition:    ENABLE_EP0_DATA_RECEIVED_CALLBACK must be
559:            *                  defined already (in usb_config.h)
560:            *
561:            * Input:           None
562:            *
563:            * Output:          None
564:            *
565:            * Side Effects:    None
566:            *
567:            * Overview:        This function is called whenever a EP0 data
568:            *                  packet is received.  This gives the user (and
569:            *                  thus the various class examples a way to get
570:            *                  data that is received via the control endpoint.
571:            *                  This function needs to be used in conjunction
572:            *                  with the USBCBCheckOtherReq() function since 
573:            *                  the USBCBCheckOtherReq() function is the apps
574:            *                  method for getting the initial control transfer
575:            *                  before the data arrives.
576:            *
577:            * Note:            None
578:            *******************************************************************/
579:           #if defined(ENABLE_EP0_DATA_RECEIVED_CALLBACK)
580:           void USBCBEP0DataReceived(void)
581:           {
582:           }
583:           #endif
584:           
585:           /*******************************************************************
586:            * Function:        BOOL USER_USB_CALLBACK_EVENT_HANDLER(
587:            *                        int event, void *pdata, WORD size)
588:            *
589:            * PreCondition:    None
590:            *
591:            * Input:           int event - the type of event
592:            *                  void *pdata - pointer to the event data
593:            *                  WORD size - size of the event data
594:            *
595:            * Output:          None
596:            *
597:            * Side Effects:    None
598:            *
599:            * Overview:        This function is called from the USB stack to
600:            *                  notify a user application that a USB event
601:            *                  occured.  This callback is in interrupt context
602:            *                  when the USB_INTERRUPT option is selected.
603:            *
604:            * Note:            None
605:            *******************************************************************/
606:           BOOL USER_USB_CALLBACK_EVENT_HANDLER(int event, void *pdata, WORD size)
607:           {
608:               switch( event )
01E5  0861     MOVF 0x61, W
01F5  0860     MOVF event, W
01F6  3A01     XORLW 0x1
01F7  1903     BTFSC STATUS, 0x2
01F8  29F0     GOTO 0x1F0
01F9  3A03     XORLW 0x3
01FA  1903     BTFSC STATUS, 0x2
01FB  29F1     GOTO 0x1F1
01FC  3A01     XORLW 0x1
01FD  1903     BTFSC STATUS, 0x2
01FE  29F2     GOTO 0x1F2
01FF  3A06     XORLW 0x6
0200  1903     BTFSC STATUS, 0x2
0201  2A14     GOTO 0x214
0202  3A77     XORLW 0x77
0203  1903     BTFSC STATUS, 0x2
0204  2A14     GOTO 0x214
0205  3A01     XORLW 0x1
0206  1903     BTFSC STATUS, 0x2
0207  29ED     GOTO 0x1ED
0208  3A07     XORLW 0x7
0209  1903     BTFSC STATUS, 0x2
020A  29EF     GOTO 0x1EF
020B  3A01     XORLW 0x1
020C  1903     BTFSC STATUS, 0x2
020D  29EE     GOTO 0x1EE
020E  2A14     GOTO 0x214
020F  0860     MOVF event, W
0210  3AFF     XORLW 0xFF
0211  1903     BTFSC STATUS, 0x2
0212  29F4     GOTO 0x1F4
0213  2A14     GOTO 0x214
609:               {
610:                   case EVENT_TRANSFER:
611:                       //Add application specific callback task or callback function here if desired.
612:                       break;
613:                   case EVENT_SOF:
614:                       USBCB_SOF_Handler();
01ED  2BEC     GOTO 0x3EC
615:                       break;
616:                   case EVENT_SUSPEND:
617:                       USBCBSuspend();
01EE  2BEE     GOTO 0x3EE
618:                       break;
619:                   case EVENT_RESUME:
620:                       USBCBWakeFromSuspend();
01EF  2BED     GOTO 0x3ED
621:                       break;
622:                   case EVENT_CONFIGURED: 
623:                       USBCBInitEP();
01F0  2B4A     GOTO 0x34A
624:                       break;
625:                   case EVENT_SET_DESCRIPTOR:
626:                       USBCBStdSetDscHandler();
01F1  2BE8     GOTO 0x3E8
627:                       break;
628:                   case EVENT_EP0_REQUEST:
629:                       USBCBCheckOtherReq();
01F2  3197     MOVLP 0x17
01F3  2FB0     GOTO 0x7B0
630:                       break;
631:                   case EVENT_BUS_ERROR:
632:                       USBCBErrorHandler();
01F4  2BEB     GOTO 0x3EB
633:                       break;
634:                   case EVENT_TRANSFER_TERMINATED:
635:                       //Add application specific callback task or callback function here if desired.
636:                       //The EVENT_TRANSFER_TERMINATED event occurs when the host performs a CLEAR
637:                       //FEATURE (endpoint halt) request on an application endpoint which was 
638:                       //previously armed (UOWN was = 1).  Here would be a good place to:
639:                       //1.  Determine which endpoint the transaction that just got terminated was 
640:                       //      on, by checking the handle value in the *pdata.
641:                       //2.  Re-arm the endpoint if desired (typically would be the case for OUT 
642:                       //      endpoints).
643:                       break;
644:                   default:
645:                       break;
646:               }      
647:               return TRUE; 
648:           }
0214  0008     RETURN
649:           
650:           
651:           /** EOF main.c *************************************************/
652:           
---  /home/chris/Dev/klondike/firmware/klondike.c  ------------------------------------------------------
1:             /********
2:              * klondike.c - cmd processing and support functions
3:              *
4:              * (C) Copyright 2013 Chris Savery. All rights reserved.
5:              *
6:              */
7:             #include "GenericTypeDefs.h"
8:             #include "Compiler.h"
9:             #include <xc.h>
10:            #include "klondike.h"
11:            
12:            const IDENTITY ID = { 0x10, 0xDEADBEEF, "K16" };
13:            const DWORD BankRanges[8] = { 0, 0x40000000, 0x2aaaaaaa, 0x20000000, 0x19999999, 0x15555555, 0x12492492, 0x10000000 };
14:            const WORKTASK TestWork = { 0xFF, GOOD_MIDSTATE, GOOD_DATA };
15:            const DWORD GoodNonce = GOOD_NONCE;
16:            const DWORD TestNonce = (GOOD_NONCE - DETECT_DELAY_COUNT);
17:            
18:            BYTE WorkNow, BankSize, ResultQC, SlowTick;
19:            BYTE SlaveAddress = MASTER_ADDRESS;
20:            BYTE HashTime = 256-(TICK_FACTOR/DEFAULT_HASHCLOCK);
21:            volatile WORKSTATUS Status = {'I',0,0,0,0,0,0,0,0};
22:            volatile WORD WorkTicks = WORK_TICKS;
23:            WORKCFG Cfg = { DEFAULT_HASHCLOCK, DEFAULT_TEMP_TARGET, DEFAULT_TEMP_CRITICAL, DEFAULT_FAN_TARGET };
24:            WORKTASK WorkQue[MAX_WORK_COUNT];
25:            volatile BYTE ResultQue[MAX_RESULT_COUNT*4];
26:            DWORD ClockCfg[2] = { ((DWORD)DEFAULT_HASHCLOCK << 18) | CLOCK_LOW_CFG, ((DWORD)CLOCK_R_VALUE >> 3) | CLOCK_HIGH_CFG };
27:            
28:            DWORD NonceRanges[8];
29:            
30:            void ProcessCmd(char *cmd)
31:            {
08FD  0021     MOVLB 0x1
08FE  00EF     MOVWF pBDTEntryEP0OutNext
32:                // cmd is one char, dest address 1 byte, data follows
33:                // we already know address is ours here
34:                switch(cmd[0]) {
08FF  2A37     GOTO 0x237
0A37  086F     MOVF pBDTEntryEP0OutNext, W
0A38  0086     MOVWF FSR1L
0A39  3003     MOVLW 0x3
0A3A  0087     MOVWF FSR1H
0A3B  0801     MOVF INDF1, W
0A3C  3A41     XORLW 0x41
0A3D  1903     BTFSC STATUS, 0x2
0A3E  2964     GOTO 0x164
0A3F  3A02     XORLW 0x2
0A40  1903     BTFSC STATUS, 0x2
0A41  29A6     GOTO 0x1A6
0A42  3A07     XORLW 0x7
0A43  1903     BTFSC STATUS, 0x2
0A44  2A27     GOTO 0x227
0A45  3A01     XORLW 0x1
0A46  1903     BTFSC STATUS, 0x2
0A47  2A05     GOTO 0x205
0A48  3A0C     XORLW 0xC
0A49  1903     BTFSC STATUS, 0x2
0A4A  2999     GOTO 0x199
0A4B  3A1A     XORLW 0x1A
0A4C  1903     BTFSC STATUS, 0x2
0A4D  2956     GOTO 0x156
0A4E  3A04     XORLW 0x4
0A4F  1903     BTFSC STATUS, 0x2
0A50  2900     GOTO 0x100
0A51  2A52     GOTO 0x252
35:                    case 'W': // queue new work
36:                        if( Status.WorkQC < MAX_WORK_COUNT-1 ) {
0900  3003     MOVLW 0x3
0901  0023     MOVLB 0x3
0902  0254     SUBWF 0x54, W
0903  1803     BTFSC STATUS, 0x0
0904  2A52     GOTO 0x252
37:                            WorkQue[ (WorkNow + Status.WorkQC) & WORKMASK ] = TestWork;//*(WORKTASK *)(cmd+2);
0905  3016     MOVLW 0x16
0906  0084     MOVWF FSR0L
0907  3091     MOVLW 0x91
0908  0085     MOVWF FSR0H
0909  0022     MOVLB 0x2
090A  0851     MOVF 0x51, W
090B  0021     MOVLB 0x1
090C  00A0     MOVWF BDT
090D  01A1     CLRF 0x21
090E  0023     MOVLB 0x3
090F  0854     MOVF 0x54, W
0910  0021     MOVLB 0x1
0911  07A0     ADDWF BDT, F
0912  1803     BTFSC STATUS, 0x0
0913  0AA1     INCF 0x21, F
0914  3003     MOVLW 0x3
0915  05A0     ANDWF BDT, F
0916  302D     MOVLW 0x2D
0917  01A1     CLRF 0x21
0918  00A2     MOVWF 0x22
0919  01A3     CLRF 0x23
091A  2286     CALL 0x286
091B  3188     MOVLP 0x8
091C  303C     MOVLW 0x3C
091D  0022     MOVLB 0x2
091E  00E9     MOVWF p
091F  3023     MOVLW 0x23
0920  00EA     MOVWF 0x6A
0921  0021     MOVLB 0x1
0922  0820     MOVF BDT, W
0923  0022     MOVLB 0x2
0924  0769     ADDWF p, W
0925  0086     MOVWF FSR1L
0926  0021     MOVLB 0x1
0927  0821     MOVF 0x21, W
0928  0022     MOVLB 0x2
0929  3D6A     ADDWFC 0x6A, W
092A  0087     MOVWF FSR1H
092B  302D     MOVLW 0x2D
092C  00EB     MOVWF 0x6B
092D  0012     MOVIW FSR0++
092E  001E     MOVWI FSR1++
092F  0BEB     DECFSZ 0x6B, F
0930  292D     GOTO 0x12D
38:                            if(Status.WorkQC++ == 0) {
0931  0023     MOVLB 0x3
0932  0AD4     INCF 0x54, F
0933  0B54     DECFSZ 0x54, W
0934  2956     GOTO 0x156
39:                                AsicPreCalc(&WorkQue[WorkNow]);
0935  303C     MOVLW 0x3C
0936  0021     MOVLB 0x1
0937  00B0     MOVWF 0x30
0938  3023     MOVLW 0x23
0939  00B1     MOVWF 0x31
093A  0022     MOVLB 0x2
093B  0851     MOVF 0x51, W
093C  0021     MOVLB 0x1
093D  00A0     MOVWF BDT
093E  302D     MOVLW 0x2D
093F  01A1     CLRF 0x21
0940  00A2     MOVWF 0x22
0941  01A3     CLRF 0x23
0942  2286     CALL 0x286
0943  3188     MOVLP 0x8
0944  0820     MOVF BDT, W
0945  0022     MOVLB 0x2
0946  00E9     MOVWF p
0947  0021     MOVLB 0x1
0948  0821     MOVF 0x21, W
0949  0022     MOVLB 0x2
094A  00EA     MOVWF 0x6A
094B  0869     MOVF p, W
094C  0021     MOVLB 0x1
094D  07B0     ADDWF 0x30, F
094E  0022     MOVLB 0x2
094F  086A     MOVF 0x6A, W
0950  0021     MOVLB 0x1
0951  3DB1     ADDWFC 0x31, F
0952  231F     CALL 0x31F
0953  3188     MOVLP 0x8
40:                                AsicPushWork();
0954  22C0     CALL 0x2C0
0955  3188     MOVLP 0x8
41:                            }
42:                            SendCmdReply(cmd, (char *)&Status, sizeof(Status));
0956  0021     MOVLB 0x1
0957  086F     MOVF pBDTEntryEP0OutNext, W
0958  00A2     MOVWF 0x22
0959  3003     MOVLW 0x3
095A  00A3     MOVWF 0x23
095B  30D1     MOVLW 0xD1
095C  00A4     MOVWF 0x24
095D  3001     MOVLW 0x1
095E  00A5     MOVWF 0x25
095F  300D     MOVLW 0xD
0960  00A6     MOVWF 0x26
0961  2255     CALL 0x255
0962  3188     MOVLP 0x8
0963  2A52     GOTO 0x252
43:                        }
44:                        break;
45:                    case 'A': // abort work, reply with hash completion count
46:                        Status.WorkQC = WorkNow = 0;
0964  0022     MOVLB 0x2
0965  01D1     CLRF 0x51
0966  0023     MOVLB 0x3
0967  01D4     CLRF 0x54
47:                        WorkQue[ (WorkNow + Status.WorkQC++) & WORKMASK ] = *(WORKTASK *)(cmd+2);
0968  0021     MOVLB 0x1
0969  086F     MOVF pBDTEntryEP0OutNext, W
096A  3E02     ADDLW 0x2
096B  0086     MOVWF FSR1L
096C  3003     MOVLW 0x3
096D  0087     MOVWF FSR1H
096E  0022     MOVLB 0x2
096F  0851     MOVF 0x51, W
0970  0021     MOVLB 0x1
0971  00A0     MOVWF BDT
0972  01A1     CLRF 0x21
0973  0023     MOVLB 0x3
0974  0854     MOVF 0x54, W
0975  0021     MOVLB 0x1
0976  07A0     ADDWF BDT, F
0977  1803     BTFSC STATUS, 0x0
0978  0AA1     INCF 0x21, F
0979  3003     MOVLW 0x3
097A  05A0     ANDWF BDT, F
097B  302D     MOVLW 0x2D
097C  01A1     CLRF 0x21
097D  00A2     MOVWF 0x22
097E  01A3     CLRF 0x23
097F  2286     CALL 0x286
0980  3188     MOVLP 0x8
0981  303C     MOVLW 0x3C
0982  0022     MOVLB 0x2
0983  00E9     MOVWF p
0984  3023     MOVLW 0x23
0985  00EA     MOVWF 0x6A
0986  0021     MOVLB 0x1
0987  0820     MOVF BDT, W
0988  0022     MOVLB 0x2
0989  0769     ADDWF p, W
098A  0084     MOVWF FSR0L
098B  0021     MOVLB 0x1
098C  0821     MOVF 0x21, W
098D  0022     MOVLB 0x2
098E  3D6A     ADDWFC 0x6A, W
098F  0085     MOVWF FSR0H
0990  302D     MOVLW 0x2D
0991  00FF     MOVWF 0x7F
0992  0016     MOVIW FSR1++
0993  001A     MOVWI FSR0++
0994  0BFF     DECFSZ 0x7F, F
0995  2992     GOTO 0x192
0996  0023     MOVLB 0x3
0997  0AD4     INCF 0x54, F
0998  2935     GOTO 0x135
48:                        AsicPreCalc(&WorkQue[WorkNow]);
49:                        AsicPushWork();
50:                        SendCmdReply(cmd, (char *)&Status, sizeof(Status));
51:                        break;
52:                    case 'I': // return identity 
53:                        SendCmdReply(cmd, (char *)&ID, sizeof(ID));
0999  086F     MOVF pBDTEntryEP0OutNext, W
099A  00A2     MOVWF 0x22
099B  3003     MOVLW 0x3
099C  00A3     MOVWF 0x23
099D  3055     MOVLW 0x55
099E  00A4     MOVWF 0x24
099F  3091     MOVLW 0x91
09A0  00A5     MOVWF 0x25
09A1  300D     MOVLW 0xD
09A2  00A6     MOVWF 0x26
09A3  2255     CALL 0x255
09A4  3188     MOVLP 0x8
54:                        break;
09A5  2A52     GOTO 0x252
55:                    case 'S': // return status 
56:                        SendCmdReply(cmd, (char *)&Status, sizeof(Status)); 
57:                        break;
58:                    case 'C': // set config values 
59:                        if( cmd[2] != 0 ) {
09A6  086F     MOVF pBDTEntryEP0OutNext, W
09A7  3E02     ADDLW 0x2
09A8  0086     MOVWF FSR1L
09A9  3003     MOVLW 0x3
09AA  0087     MOVWF FSR1H
09AB  0801     MOVF INDF1, W
09AC  3A00     XORLW 0x0
09AD  1903     BTFSC STATUS, 0x2
09AE  29F7     GOTO 0x1F7
60:                            Cfg = *(WORKCFG *)(cmd+2);
09AF  086F     MOVF pBDTEntryEP0OutNext, W
09B0  3E02     ADDLW 0x2
09B1  0086     MOVWF FSR1L
09B2  30E6     MOVLW 0xE6
09B3  0084     MOVWF FSR0L
09B4  3001     MOVLW 0x1
09B5  0085     MOVWF FSR0H
09B6  3005     MOVLW 0x5
09B7  00FF     MOVWF 0x7F
09B8  0016     MOVIW FSR1++
09B9  001A     MOVWI FSR0++
09BA  0BFF     DECFSZ 0x7F, F
09BB  29B8     GOTO 0x1B8
61:                            if(Cfg.HashClock < MIN_HASH_CLOCK)
09BC  3001     MOVLW 0x1
09BD  0023     MOVLB 0x3
09BE  0267     SUBWF 0x67, W
09BF  30F4     MOVLW 0xF4
09C0  1903     BTFSC STATUS, 0x2
09C1  0266     SUBWF pUEP, W
09C2  1803     BTFSC STATUS, 0x0
09C3  29C8     GOTO 0x1C8
62:                                Cfg.HashClock = MIN_HASH_CLOCK;
09C4  30F4     MOVLW 0xF4
09C5  00E6     MOVWF pUEP
09C6  3001     MOVLW 0x1
09C7  00E7     MOVWF 0x67
63:                            if(Cfg.HashClock > MAX_HASH_CLOCK)
09C8  3003     MOVLW 0x3
09C9  0267     SUBWF 0x67, W
09CA  3085     MOVLW 0x85
09CB  1903     BTFSC STATUS, 0x2
09CC  0266     SUBWF pUEP, W
09CD  1C03     BTFSS STATUS, 0x0
09CE  29D3     GOTO 0x1D3
64:                                Cfg.HashClock = MAX_HASH_CLOCK;
09CF  3084     MOVLW 0x84
09D0  00E6     MOVWF pUEP
09D1  3003     MOVLW 0x3
09D2  00E7     MOVWF 0x67
65:                            ClockCfg[0] = ((DWORD)Cfg.HashClock << 18) | 0x00000003;
09D3  0866     MOVF pUEP, W
09D4  00DE     MOVWF 0x5E
09D5  0867     MOVF 0x67, W
09D6  00DF     MOVWF 0x5F
09D7  3012     MOVLW 0x12
09D8  01E0     CLRF event
09D9  01E1     CLRF 0x61
09DA  35DE     LSLF 0x5E, F
09DB  0DDF     RLF 0x5F, F
09DC  0DE0     RLF event, F
09DD  0DE1     RLF 0x61, F
09DE  0B89     DECFSZ WREG, F
09DF  29DA     GOTO 0x1DA
09E0  3003     MOVLW 0x3
09E1  04DE     IORWF 0x5E, F
09E2  3000     MOVLW 0x0
09E3  04DF     IORWF 0x5F, F
09E4  04E0     IORWF event, F
09E5  04E1     IORWF 0x61, F
66:                            HashTime = 256-(TICK_FACTOR/Cfg.HashClock);
09E6  0867     MOVF 0x67, W
09E7  0021     MOVLB 0x1
09E8  00A1     MOVWF 0x21
09E9  0023     MOVLB 0x3
09EA  0866     MOVF pUEP, W
09EB  0021     MOVLB 0x1
09EC  00A0     MOVWF BDT
09ED  30C0     MOVLW 0xC0
09EE  00A2     MOVWF 0x22
09EF  305D     MOVLW 0x5D
09F0  00A3     MOVWF 0x23
09F1  229B     CALL 0x29B
09F2  3188     MOVLP 0x8
09F3  0820     MOVF BDT, W
09F4  3C00     SUBLW 0x0
09F5  0022     MOVLB 0x2
09F6  00EE     MOVWF i
67:                        }
68:                        SendCmdReply(cmd, (char *)&Cfg, sizeof(Cfg));
09F7  0021     MOVLB 0x1
09F8  086F     MOVF pBDTEntryEP0OutNext, W
09F9  00A2     MOVWF 0x22
09FA  3003     MOVLW 0x3
09FB  00A3     MOVWF 0x23
09FC  30E6     MOVLW 0xE6
09FD  00A4     MOVWF 0x24
09FE  3001     MOVLW 0x1
09FF  00A5     MOVWF 0x25
0A00  3005     MOVLW 0x5
0A01  00A6     MOVWF 0x26
0A02  2255     CALL 0x255
0A03  3188     MOVLP 0x8
69:                        break;
0A04  2A52     GOTO 0x252
70:                    case 'E': // enable/disable work
71:                        HASH_CLK_EN = (cmd[2] == '1');
0A05  086F     MOVF pBDTEntryEP0OutNext, W
0A06  3E02     ADDLW 0x2
0A07  0086     MOVWF FSR1L
0A08  3003     MOVLW 0x3
0A09  0087     MOVWF FSR1H
0A0A  0801     MOVF INDF1, W
0A0B  3A31     XORLW 0x31
0A0C  3000     MOVLW 0x0
0A0D  1903     BTFSC STATUS, 0x2
0A0E  3001     MOVLW 0x1
0A0F  0022     MOVLB 0x2
0A10  00E9     MOVWF p
0A11  0EE9     SWAPF p, F
0A12  080C     MOVF PORTA, W
0A13  0669     XORWF p, W
0A14  39EF     ANDLW 0xEF
0A15  0669     XORWF p, W
0A16  008C     MOVWF PORTA
72:                        Status.State = (cmd[2] == '1') ? 'R' : 'D';
0A17  0021     MOVLB 0x1
0A18  086F     MOVF pBDTEntryEP0OutNext, W
0A19  3E02     ADDLW 0x2
0A1A  0086     MOVWF FSR1L
0A1B  0801     MOVF INDF1, W
0A1C  3A31     XORLW 0x31
0A1D  1903     BTFSC STATUS, 0x2
0A1E  2A21     GOTO 0x221
0A1F  3044     MOVLW 0x44
0A20  2A22     GOTO 0x222
0A21  3052     MOVLW 0x52
0A22  00ED     MOVWF 0x6D
0A23  01EE     CLRF i
0A24  0023     MOVLB 0x3
0A25  00D1     MOVWF 0x51
0A26  2956     GOTO 0x156
73:                        SendCmdReply(cmd, (char *)&Status, sizeof(Status));
74:                        break;
75:                    case 'D': // detect asics
76:                        DetectAsics();
0A27  2724     CALL 0x724
0A28  3188     MOVLP 0x8
77:                        SendCmdReply(cmd, (char *)&Status, sizeof(Status));
0A29  0021     MOVLB 0x1
0A2A  086F     MOVF pBDTEntryEP0OutNext, W
0A2B  00A2     MOVWF 0x22
0A2C  3003     MOVLW 0x3
0A2D  00A3     MOVWF 0x23
0A2E  30D1     MOVLW 0xD1
0A2F  00A4     MOVWF 0x24
0A30  3001     MOVLW 0x1
0A31  00A5     MOVWF 0x25
0A32  300D     MOVLW 0xD
0A33  00A6     MOVWF 0x26
0A34  2255     CALL 0x255
0A35  3188     MOVLP 0x8
78:                        break;
0A36  2A52     GOTO 0x252
79:                    default:
80:                        break;
81:                    }
82:                LED_On();
0A52  0022     MOVLB 0x2
0A53  168C     BSF PORTA, 0x5
83:            }
0A54  0008     RETURN
84:            
85:            void AsicPushWork(void)
86:            {
87:                Status.WorkID = WorkQue[WorkNow].WorkID;
0AC0  0022     MOVLB 0x2
0AC1  0851     MOVF 0x51, W
0AC2  0021     MOVLB 0x1
0AC3  00A0     MOVWF BDT
0AC4  302D     MOVLW 0x2D
0AC5  01A1     CLRF 0x21
0AC6  00A2     MOVWF 0x22
0AC7  01A3     CLRF 0x23
0AC8  2286     CALL 0x286
0AC9  3188     MOVLP 0x8
0ACA  303C     MOVLW 0x3C
0ACB  00E7     MOVWF 0x67
0ACC  3023     MOVLW 0x23
0ACD  00E8     MOVWF current_ep_data
0ACE  0820     MOVF BDT, W
0ACF  0767     ADDWF 0x67, W
0AD0  0086     MOVWF FSR1L
0AD1  0821     MOVF 0x21, W
0AD2  3D68     ADDWFC current_ep_data, W
0AD3  0087     MOVWF FSR1H
0AD4  0801     MOVF INDF1, W
0AD5  0023     MOVLB 0x3
0AD6  00D5     MOVWF 0x55
88:                SendAsicData(&WorkQue[WorkNow], DATA_SPLIT);
0AD7  303C     MOVLW 0x3C
0AD8  0021     MOVLB 0x1
0AD9  00A6     MOVWF 0x26
0ADA  3023     MOVLW 0x23
0ADB  00A7     MOVWF 0x27
0ADC  0022     MOVLB 0x2
0ADD  0851     MOVF 0x51, W
0ADE  0021     MOVLB 0x1
0ADF  00A0     MOVWF BDT
0AE0  302D     MOVLW 0x2D
0AE1  01A1     CLRF 0x21
0AE2  00A2     MOVWF 0x22
0AE3  01A3     CLRF 0x23
0AE4  2286     CALL 0x286
0AE5  3188     MOVLP 0x8
0AE6  0820     MOVF BDT, W
0AE7  00E7     MOVWF 0x67
0AE8  0821     MOVF 0x21, W
0AE9  00E8     MOVWF current_ep_data
0AEA  0867     MOVF 0x67, W
0AEB  07A6     ADDWF 0x26, F
0AEC  0868     MOVF current_ep_data, W
0AED  3DA7     ADDWFC 0x27, F
0AEE  3050     MOVLW 0x50
0AEF  00A8     MOVWF 0x28
0AF0  2628     CALL 0x628
0AF1  3188     MOVLP 0x8
89:                Status.WorkQC--;
0AF2  0023     MOVLB 0x3
0AF3  03D4     DECF 0x54, F
90:                WorkNow = (WorkNow+1) & WORKMASK;
0AF4  0022     MOVLB 0x2
0AF5  3003     MOVLW 0x3
0AF6  0AD1     INCF 0x51, F
0AF7  05D1     ANDWF 0x51, F
91:                Status.HashCount = 0;
0AF8  0023     MOVLB 0x3
0AF9  01D8     CLRF CtrlTrfData
0AFA  01D9     CLRF 0x59
0AFB  01DA     CLRF 0x5A
0AFC  01DB     CLRF 0x5B
92:                Status.State ='W';
0AFD  3057     MOVLW 0x57
0AFE  00D1     MOVWF 0x51
93:                TMR0 = HashTime;
0AFF  0022     MOVLB 0x2
0B00  086E     MOVF i, W
0B01  0020     MOVLB 0x0
0B02  0095     MOVWF TMR0
94:                if(Status.WorkQC > 0)
0B03  0023     MOVLB 0x3
0B04  0854     MOVF 0x54, W
0B05  1903     BTFSC STATUS, 0x2
0B06  0008     RETURN
95:                    AsicPreCalc(&WorkQue[WorkNow]);
0B07  303C     MOVLW 0x3C
0B08  0021     MOVLB 0x1
0B09  00B0     MOVWF 0x30
0B0A  3023     MOVLW 0x23
0B0B  00B1     MOVWF 0x31
0B0C  0022     MOVLB 0x2
0B0D  0851     MOVF 0x51, W
0B0E  0021     MOVLB 0x1
0B0F  00A0     MOVWF BDT
0B10  302D     MOVLW 0x2D
0B11  01A1     CLRF 0x21
0B12  00A2     MOVWF 0x22
0B13  01A3     CLRF 0x23
0B14  2286     CALL 0x286
0B15  3188     MOVLP 0x8
0B16  0820     MOVF BDT, W
0B17  00E7     MOVWF 0x67
0B18  0821     MOVF 0x21, W
0B19  00E8     MOVWF current_ep_data
0B1A  0867     MOVF 0x67, W
0B1B  07B0     ADDWF 0x30, F
0B1C  0868     MOVF current_ep_data, W
0B1D  3DB1     ADDWFC 0x31, F
0B1E  2B1F     GOTO 0x31F
96:            }
0B1F  01E6     CLRF pUEP
97:            
98:            void SlaveDataRelay(char *data, BYTE count)
99:            {
100:               // just write address,data to I2C bus
101:           }
0887  0008     RETURN
102:           
103:           // Housekeeping functons
104:           
105:           void CheckFanSpeed(void)
106:           {
107:               FAN_PWM = 1; // force PWM fan output to ON
108:               PWM1OE=0;
109:               T1CONbits.TMR1CS = 0;
110:               T1CONbits.T1CKPS = 3;
111:               T1CONbits.TMR1ON = TMR1GE = 1;
112:               T1GCONbits.T1GPOL = 1;
113:               T1GCONbits.T1GSS = T1GCONbits.T1GTM = 0;
114:               T1GSPM = 1;
115:               TMR1H = TMR1L = 0;
116:               TMR1GIE = 1;
117:               T1GCONbits.T1GGO_nDONE = 1;
118:           }
119:           
120:           // Auto-Config functions
121:           
122:           void DetectAsics(void)
123:           {
124:               BankSize = 8;
0F24  3008     MOVLW 0x8
0F25  0023     MOVLB 0x3
0F26  00EB     MOVWF 0x6B
125:               Status.ChipCount = 0;
0F27  01D2     CLRF 0x52
126:               for(BYTE x = 0; x < BankSize; x++)
0F28  0022     MOVLB 0x2
0F29  01E7     CLRF 0x67
0F2A  0023     MOVLB 0x3
0F2B  086B     MOVF 0x6B, W
0F2C  0022     MOVLB 0x2
0F2D  0267     SUBWF 0x67, W
0F2E  1803     BTFSC STATUS, 0x0
0F2F  2F41     GOTO 0x741
0F3F  0AE7     INCF 0x67, F
0F40  2F2A     GOTO 0x72A
127:                   NonceRanges[x] = TestNonce;
128:               AsicPreCalc(&TestWork);
0F41  3016     MOVLW 0x16
0F42  0021     MOVLB 0x1
0F43  00B0     MOVWF 0x30
0F44  3091     MOVLW 0x91
0F45  00B1     MOVWF 0x31
0F46  231F     CALL 0x31F
0F47  3188     MOVLP 0x8
129:               SendAsicData(&TestWork, (TestNonce & 0x80000000) ? DATA_ONE : DATA_ZERO);
0F48  3016     MOVLW 0x16
0F49  00A6     MOVWF 0x26
0F4A  3091     MOVLW 0x91
0F4B  00A7     MOVWF 0x27
0F4C  3048     MOVLW 0x48
0F4D  00A8     MOVWF 0x28
0F4E  2628     CALL 0x628
0F4F  3188     MOVLP 0x8
130:               // wait for "push work time" for results to return and be counted
131:               Status.ChipCount = 16; // just for now
0F50  3010     MOVLW 0x10
0F51  0023     MOVLB 0x3
0F52  00D2     MOVWF 0x52
132:               
133:               // pre-calc nonce range values
134:               BankSize = (Status.ChipCount+1)/2;
0F53  3002     MOVLW 0x2
0F54  0021     MOVLB 0x1
0F55  00A0     MOVWF BDT
0F56  01A1     CLRF 0x21
0F57  0023     MOVLB 0x3
0F58  0852     MOVF 0x52, W
0F59  3E01     ADDLW 0x1
0F5A  0021     MOVLB 0x1
0F5B  00A2     MOVWF 0x22
0F5C  3000     MOVLW 0x0
0F5D  1803     BTFSC STATUS, 0x0
0F5E  3001     MOVLW 0x1
0F5F  00A3     MOVWF 0x23
0F60  27C0     CALL 0x7C0
0F61  3188     MOVLP 0x8
0F62  0820     MOVF BDT, W
0F63  0023     MOVLB 0x3
0F64  00EB     MOVWF 0x6B
135:               WorkTicks = WORK_TICKS / BankSize;
0F65  0021     MOVLB 0x1
0F66  00A0     MOVWF BDT
0F67  3089     MOVLW 0x89
0F68  01A1     CLRF 0x21
0F69  00A2     MOVWF 0x22
0F6A  3041     MOVLW 0x41
0F6B  00A3     MOVWF 0x23
0F6C  27C0     CALL 0x7C0
0F6D  3188     MOVLP 0x8
0F6E  0821     MOVF 0x21, W
0F6F  0023     MOVLB 0x3
0F70  00D0     MOVWF SetupPkt
0F71  0021     MOVLB 0x1
0F72  0820     MOVF BDT, W
0F73  0023     MOVLB 0x3
0F74  00CF     MOVWF 0x4F
136:               NonceRanges[0] = 0;
0F75  0026     MOVLB 0x6
0F76  01A0     CLRF BDT
0F77  01A1     CLRF 0x21
0F78  01A2     CLRF 0x22
0F79  01A3     CLRF 0x23
137:               for(BYTE x = 1; x < BankSize; x++)
0F7A  0022     MOVLB 0x2
0F7B  01E8     CLRF current_ep_data
0F7C  0AE8     INCF current_ep_data, F
0F7D  0023     MOVLB 0x3
0F7E  086B     MOVF 0x6B, W
0F7F  0022     MOVLB 0x2
0F80  0268     SUBWF current_ep_data, W
0F81  1803     BTFSC STATUS, 0x0
0F82  2FBC     GOTO 0x7BC
0FBA  0022     MOVLB 0x2
0FBB  2F7C     GOTO 0x77C
138:                   NonceRanges[x] = NonceRanges[x-1] + BankRanges[BankSize-1];
0F83  0023     MOVLB 0x3
0F84  086B     MOVF 0x6B, W
0F85  0021     MOVLB 0x1
0F86  00E7     MOVWF 0x67
0F87  30FD     MOVLW 0xFD
0F88  01E8     CLRF current_ep_data
0F89  35E7     LSLF 0x67, F
0F8A  0DE8     RLF current_ep_data, F
0F8B  35E7     LSLF 0x67, F
0F8C  0DE8     RLF current_ep_data, F
0F8D  0767     ADDWF 0x67, W
0F8E  0084     MOVWF FSR0L
0F8F  308F     MOVLW 0x8F
0F90  3D68     ADDWFC current_ep_data, W
0F91  0085     MOVWF FSR0H
0F92  3F00     MOVIW [0]FSR0
0F93  00E9     MOVWF p
0F94  3F01     MOVIW [1]FSR0
0F95  00EA     MOVWF 0x6A
0F96  3F02     MOVIW [2]FSR0
0F97  00EB     MOVWF 0x6B
0F98  3F03     MOVIW [3]FSR0
0F99  00EC     MOVWF setup_cnt
0F9A  0022     MOVLB 0x2
0F9B  0868     MOVF current_ep_data, W
0F9C  0709     ADDWF WREG, W
0F9D  0709     ADDWF WREG, W
0F9E  3E1C     ADDLW 0x1C
0F9F  0086     MOVWF FSR1L
0FA0  3003     MOVLW 0x3
0FA1  0087     MOVWF FSR1H
0FA2  3F40     MOVIW [0]FSR1
0FA3  0021     MOVLB 0x1
0FA4  07E9     ADDWF p, F
0FA5  3F41     MOVIW [1]FSR1
0FA6  3DEA     ADDWFC 0x6A, F
0FA7  3F42     MOVIW [2]FSR1
0FA8  3DEB     ADDWFC 0x6B, F
0FA9  3F43     MOVIW [3]FSR1
0FAA  3DEC     ADDWFC setup_cnt, F
0FAB  0022     MOVLB 0x2
0FAC  0868     MOVF current_ep_data, W
0FAD  0709     ADDWF WREG, W
0FAE  0709     ADDWF WREG, W
0FAF  3E20     ADDLW 0x20
0FB0  0086     MOVWF FSR1L
0FB1  0021     MOVLB 0x1
0FB2  0869     MOVF p, W
0FB3  3FC0     MOVWI [0]FSR1
0FB4  086A     MOVF 0x6A, W
0FB5  3FC1     MOVWI [1]FSR1
0FB6  086B     MOVF 0x6B, W
0FB7  3FC2     MOVWI [2]FSR1
0FB8  086C     MOVF setup_cnt, W
0FB9  3FC3     MOVWI [3]FSR1
139:               Status.State ='R';
0FBC  3052     MOVLW 0x52
0FBD  0023     MOVLB 0x3
0FBE  00D1     MOVWF 0x51
140:           }
0FBF  0008     RETURN
141:           
142:           void DetectSlaves(void)
143:           {
144:               // write address 0
145:               // write cmd ID '?'
146:               // read 4 bytes serial
147:               // if serial not valid start again
148:               // increment slave count
149:               // write cmd ASSIGN: '='
150:               // write 4 byte serial
151:               // write address assignment: slave count
152:               // repeat
153:           }
154:           
155:           // ISR functions
156:           
157:           void WorkTick(void)
158:           {
159:               TMR0IF = 0;
1739  110B     BCF INTCON, 0x2
160:               if(++SlowTick == 0)
173A  0022     MOVLB 0x2
173B  0FC9     INCFSZ 0x49, F
173C  2F3E     GOTO 0x73E
161:                   LED_Off();
173D  128C     BCF PORTA, 0x5
162:               if((Status.State == 'W') && (++Status.HashCount == WorkTicks)) {
173E  0023     MOVLB 0x3
173F  0851     MOVF 0x51, W
1740  3A57     XORLW 0x57
1741  1D03     BTFSS STATUS, 0x2
1742  2F69     GOTO 0x769
1743  084F     MOVF 0x4F, W
1744  00F0     MOVWF dir
1745  0850     MOVF SetupPkt, W
1746  00F1     MOVWF data
1747  01F2     CLRF p
1748  01F3     CLRF handle
1749  0AD8     INCF CtrlTrfData, F
174A  1903     BTFSC STATUS, 0x2
174B  0AD9     INCF 0x59, F
174C  1903     BTFSC STATUS, 0x2
174D  0ADA     INCF 0x5A, F
174E  1903     BTFSC STATUS, 0x2
174F  0ADB     INCF 0x5B, F
1750  0873     MOVF handle, W
1751  065B     XORWF 0x5B, W
1752  1D03     BTFSS STATUS, 0x2
1753  2F5E     GOTO 0x75E
1754  0872     MOVF p, W
1755  065A     XORWF 0x5A, W
1756  1D03     BTFSS STATUS, 0x2
1757  2F5E     GOTO 0x75E
1758  0871     MOVF data, W
1759  0659     XORWF 0x59, W
175A  1D03     BTFSS STATUS, 0x2
175B  2F5E     GOTO 0x75E
175C  0870     MOVF dir, W
175D  0658     XORWF CtrlTrfData, W
175E  1D03     BTFSS STATUS, 0x2
175F  2F69     GOTO 0x769
163:                   if(Status.WorkQC > 0)
1760  0854     MOVF 0x54, W
1761  1903     BTFSC STATUS, 0x2
1762  2F66     GOTO 0x766
164:                       Status.State = 'P';//AsicPushWork();
1763  3050     MOVLW 0x50
1764  00D1     MOVWF 0x51
1765  0008     RETURN
165:                   else
166:                       Status.State = 'R';
1766  3052     MOVLW 0x52
1767  00D1     MOVWF 0x51
1768  0008     RETURN
167:               }
168:               else
169:                   TMR0 = HashTime;
1769  0022     MOVLB 0x2
176A  086E     MOVF i, W
176B  0020     MOVLB 0x0
176C  0095     MOVWF TMR0
170:           }
176D  0008     RETURN
171:           
172:           void ResultDataReady(void)
173:           {
174:               GIE = 0;
175:               RCIF = 0;
176:               BYTE Rw = ResultQC & 0xFC;
177:               ResultQue[ResultQC] = RCREGbits.RCREG;
178:               ResultQC = (ResultQC+1) & (MAX_RESULT_COUNT*4-1);
179:           
180:               if(RCSTAbits.OERR) { // error occured
181:                   Status.ErrorCount++;
182:                   RCSTAbits.CREN = 0x00U; // clear error
183:                   RCSTAbits.CREN = 0x01U; // renable
184:               }
185:               
186:               if((ResultQC & 2) == 0) {
187:                   BYTE buf[5];
188:                   buf[0] = WorkQue[WorkNow].WorkID;
189:                   buf[1] = ResultQue[Rw++];
190:                   buf[2] = ResultQue[Rw++];
191:                   buf[3] = ResultQue[Rw++];
192:                   buf[4] = ResultQue[Rw];
193:                   // todo: adjust non-zero address byte in slave mode
194:                   SendCmdReply((char *)"R", buf, sizeof(DWORD));
195:               }
196:               GIE = 1;
197:           }
198:           
199:           void PollSlaveData(void)
200:           {
201:               // write address 0
202:               // write POLL cmd: 'P'
203:               // read data until no ACK
204:               // if valid send cmd reply
205:           }
206:           
207:           void UpdateTemp(void)
208:           {
209:               ADIF = 0;
210:               Status.Temp = ADRESH;
211:               // todo: adjust FAN PWM for temp target
212:           }
213:           
214:           void UpdateFanSpeed(void)
215:           {
216:               TMR1GIE = TMR1GIF = 0;
217:               TMR1ON = 0;
218:               Status.FanSpeed = TACH_FACTOR / TMR1H; // todo: adjust for rollovers below 690RPM
219:               FAN_PWM = 0; // re-enable PWM fan output
220:               PWM1OE=1;
221:               TMR1GIE = 1;
222:           }
223:           
224:           // Init functions
225:           
226:           void InitI2CSlave(void)
227:           {
228:               // todo: get this right
229:               //I2C_TRIS_DATA = 1;
230:               //I2C_TRIS_CLK = 1;
231:               //SSPCON = 0x37;
232:               //SSPADD = 0;
233:           }
234:           
235:           void InitI2CMaster(void)
236:           {
237:               // todo: tsetup master mode
238:               DetectSlaves();
239:           }
240:           
241:           void InitFAN(void)
242:           {
243:               FAN_TRIS = 1;
07BC  168E     BSF PORTC, 0x5
244:               PWM1CON = 0;
07BD  002C     MOVLB 0xC
07BE  0193     CLRF 0x13
245:               PR2 = 0xFF;
07BF  30FF     MOVLW 0xFF
07C0  0020     MOVLB 0x0
07C1  009B     MOVWF PR2
246:               PWM1CON = 0xC0;
07C2  30C0     MOVLW 0xC0
07C3  002C     MOVLB 0xC
07C4  0093     MOVWF 0x13
247:               PWM1DCH = 64;
07C5  3040     MOVLW 0x40
07C6  0092     MOVWF PIR2
248:               PWM1DCL = 0;
07C7  0191     CLRF PIR1
249:               TMR2IF = 0;
07C8  0020     MOVLB 0x0
07C9  1091     BCF PIR1, 0x1
250:               T2CONbits.T2CKPS = 0;
07CA  30FC     MOVLW 0xFC
07CB  059C     ANDWF T2CON, F
251:               TMR2ON = 1;
07CC  151C     BSF T2CON, 0x2
252:               FAN_TRIS = 0;
07CD  0021     MOVLB 0x1
07CE  128E     BCF PORTC, 0x5
253:               PWM1OE=1;
07CF  002C     MOVLB 0xC
07D0  1713     BSF 0x13, 0x6
254:           }
07D1  0008     RETURN
255:           
256:           void InitThermistor(void)
257:           { 
258:               THERM_TRIS=1;
07D2  0021     MOVLB 0x1
07D3  150E     BSF PORTC, 0x2
259:               ADCON0bits.CHS = TEMP_INTERNAL;
07D4  081D     MOVF 0x1D, W
07D5  3983     ANDLW 0x83
07D6  3874     IORLW 0x74
07D7  009D     MOVWF 0x1D
260:               ADCON0bits.ADON = 1;
07D8  141D     BSF 0x1D, 0x0
261:               ADCON1bits.ADFM = 0;
07D9  139E     BCF 0x1E, 0x7
262:               ADCON1bits.ADCS = 6;
07DA  081E     MOVF 0x1E, W
07DB  398F     ANDLW 0x8F
07DC  3860     IORLW 0x60
07DD  009E     MOVWF 0x1E
263:               ADCON1bits.ADPREF = 0;
07DE  30FC     MOVLW 0xFC
07DF  059E     ANDWF 0x1E, F
264:               ADCON2bits.TRIGSEL = 3;
07E0  081F     MOVF 0x1F, W
07E1  398F     ANDLW 0x8F
07E2  3830     IORLW 0x30
07E3  009F     MOVWF 0x1F
265:           }
07E4  0008     RETURN
266:           
267:           void InitWorkTick(void)
268:           {
269:               TMR0CS = 0;
07E5  0021     MOVLB 0x1
07E6  1295     BCF TMR0, 0x5
270:               OPTION_REGbits.PSA = 0;
07E7  1195     BCF TMR0, 0x3
271:               OPTION_REGbits.PS = 7;
07E8  3007     MOVLW 0x7
07E9  0495     IORWF TMR0, F
272:               TMR0 = HashTime;
07EA  0022     MOVLB 0x2
07EB  086E     MOVF i, W
07EC  0020     MOVLB 0x0
07ED  0095     MOVWF TMR0
273:           
274:               HASH_TRIS_0P = 0;
07EE  0021     MOVLB 0x1
07EF  138E     BCF PORTC, 0x7
275:               HASH_TRIS_0N = 0;
07F0  130E     BCF PORTC, 0x6
276:               HASH_TRIS_1P = 0;
07F1  120E     BCF PORTC, 0x4
277:               HASH_TRIS_1N = 0;
07F2  118E     BCF PORTC, 0x3
278:               HASH_IDLE();
07F3  30D8     MOVLW 0xD8
07F4  0022     MOVLB 0x2
07F5  008E     MOVWF PORTC
279:               
280:           }
07F6  0008     RETURN
281:           
282:           void InitResultRx(void)
283:           {
284:               TXSTAbits.SYNC = 1;
285:               RCSTAbits.SPEN = 1;
286:               TXSTAbits.CSRC = 0;
287:               ANSELBbits.ANSB5 = 0;
288:               PIE1bits.RCIE = 1;
289:               INTCONbits.PEIE = 1;
290:               INTCONbits.GIE = 1;
291:               RCSTAbits.CREN = 1;
292:           }
---  /home/chris/Dev/klondike/firmware/asic.c  ----------------------------------------------------------
1:             /********
2:              * asic.c - Avalon ASIC serial data shifting support
3:              *
4:              * (C) Copyright 2013 Chris Savery. All rights reserved.
5:              *
6:              */
7:             #include "GenericTypeDefs.h"
8:             #include "Compiler.h"
9:             #include <xc.h>
10:            #include "klondike.h"
11:            
12:            extern BYTE BankSize;
13:            extern DWORD ClockCfg[2];
14:            extern DWORD NonceRanges[8];
15:            
16:            DWORD PrecalcHashes[6];
17:            
18:            bank2 WORD send32_data; // place in same bank as latc registers!
19:            bank2 BYTE send32_count; // count DWORDS
20:            bank2 BYTE last_bit0, last_bit1;
21:            
22:            void SendAsicData(WORKTASK *work, BYTE split)
23:            {
24:                GIE = 0;
0E28  138B     BCF INTCON, 0x7
25:                last_bit0 = DATA_ZERO; last_bit1 = DATA_ONE;
0E29  3048     MOVLW 0x48
0E2A  0022     MOVLB 0x2
0E2B  00D8     MOVWF CtrlTrfData
0E2C  3090     MOVLW 0x90
0E2D  00D9     MOVWF 0x59
26:                send32_data = (WORD)&ClockCfg; send32_count = 2;
0E2E  30DE     MOVLW 0xDE
0E2F  00C3     MOVWF 0x43
0E30  3001     MOVLW 0x1
0E31  00C4     MOVWF 0x44
0E32  3002     MOVLW 0x2
0E33  00DC     MOVWF 0x5C
27:                Send32();
0E34  2675     CALL 0x675
0E35  3188     MOVLP 0x8
28:                send32_data = (WORD)&work->Merkle; send32_count = 3;
0E36  0021     MOVLB 0x1
0E37  0827     MOVF 0x27, W
0E38  0022     MOVLB 0x2
0E39  00C4     MOVWF 0x44
0E3A  0021     MOVLB 0x1
0E3B  0826     MOVF 0x26, W
0E3C  0022     MOVLB 0x2
0E3D  00C3     MOVWF 0x43
0E3E  3021     MOVLW 0x21
0E3F  07C3     ADDWF 0x43, F
0E40  1803     BTFSC STATUS, 0x0
0E41  0AC4     INCF 0x44, F
0E42  3003     MOVLW 0x3
0E43  00DC     MOVWF 0x5C
29:                Send32();
0E44  2675     CALL 0x675
0E45  3188     MOVLP 0x8
30:                send32_data = (WORD)&PrecalcHashes; send32_count = 5;
0E46  30AD     MOVLW 0xAD
0E47  00C3     MOVWF 0x43
0E48  3001     MOVLW 0x1
0E49  00C4     MOVWF 0x44
0E4A  3005     MOVLW 0x5
0E4B  00DC     MOVWF 0x5C
31:                Send32();
0E4C  2675     CALL 0x675
0E4D  3188     MOVLP 0x8
32:                send32_data = (WORD)&work->MidState; send32_count = 8;
0E4E  0021     MOVLB 0x1
0E4F  0827     MOVF 0x27, W
0E50  0022     MOVLB 0x2
0E51  00C4     MOVWF 0x44
0E52  0021     MOVLB 0x1
0E53  0826     MOVF 0x26, W
0E54  0022     MOVLB 0x2
0E55  00C3     MOVWF 0x43
0E56  0AC3     INCF 0x43, F
0E57  1903     BTFSC STATUS, 0x2
0E58  0AC4     INCF 0x44, F
0E59  3008     MOVLW 0x8
0E5A  00DC     MOVWF 0x5C
33:                Send32();
0E5B  2675     CALL 0x675
0E5C  3188     MOVLP 0x8
34:                send32_data = (WORD)&PrecalcHashes[5]; send32_count = 1;
0E5D  30C1     MOVLW 0xC1
0E5E  00C3     MOVWF 0x43
0E5F  3001     MOVLW 0x1
0E60  00C4     MOVWF 0x44
0E61  01DC     CLRF 0x5C
0E62  0ADC     INCF 0x5C, F
35:                Send32();
0E63  2675     CALL 0x675
0E64  3188     MOVLP 0x8
36:                last_bit0 = last_bit1 = split;
0E65  0021     MOVLB 0x1
0E66  0828     MOVF 0x28, W
0E67  0022     MOVLB 0x2
0E68  00D9     MOVWF 0x59
0E69  00D8     MOVWF CtrlTrfData
37:                send32_data = (WORD)&NonceRanges; send32_count = BankSize;
0E6A  3020     MOVLW 0x20
0E6B  00C3     MOVWF 0x43
0E6C  3003     MOVLW 0x3
0E6D  00C4     MOVWF 0x44
0E6E  0023     MOVLB 0x3
0E6F  086B     MOVF 0x6B, W
0E70  0022     MOVLB 0x2
0E71  00DC     MOVWF 0x5C
38:                Send32();
0E72  2675     CALL 0x675
39:                GIE = 1;
0E73  178B     BSF INTCON, 0x7
40:            }
0E74  0008     RETURN
41:            
42:            void Send32(void)
43:            {
44:                #asm
45:                BANKSEL(LATC) 
0E75  0022     MOVLB 0x2
46:                MOVF (_send32_data) & 0x7F, W
0E76  0843     MOVF 0x43, W
47:                MOVWF FSR1L
0E77  0086     MOVWF FSR1L
48:                MOVF (_send32_data+1) & 0x7F, W
0E78  0844     MOVF 0x44, W
49:                MOVWF FSR1H
0E79  0087     MOVWF FSR1H
50:            
51:            next_word:
52:                // bit 0
53:                MOVLW DATA_ZERO
0E7A  3048     MOVLW 0x48
54:                CLRF LATC & 0x7F
0E7B  018E     CLRF PORTC
55:                BTFSC INDF1,0
0E7C  1801     BTFSC INDF1, 0x0
56:                MOVLW 0x90
0E7D  3090     MOVLW 0x90
57:                MOVWF LATC & 0x7F
0E7E  008E     MOVWF PORTC
58:            
59:                // bit 1
60:                MOVLW DATA_ZERO
0E7F  3048     MOVLW 0x48
61:                CLRF LATC & 0x7F
0E80  018E     CLRF PORTC
62:                BTFSC INDF1,1
0E81  1881     BTFSC INDF1, 0x1
63:                MOVLW DATA_ONE
0E82  3090     MOVLW 0x90
64:                MOVWF LATC & 0x7F
0E83  008E     MOVWF PORTC
65:            
66:                // bit 2
67:                MOVLW DATA_ZERO
0E84  3048     MOVLW 0x48
68:                CLRF LATC & 0x7F
0E85  018E     CLRF PORTC
69:                BTFSC INDF1,2
0E86  1901     BTFSC INDF1, 0x2
70:                MOVLW DATA_ONE
0E87  3090     MOVLW 0x90
71:                MOVWF LATC & 0x7F
0E88  008E     MOVWF PORTC
72:            
73:                // bit 3
74:                MOVLW DATA_ZERO
0E89  3048     MOVLW 0x48
75:                CLRF LATC & 0x7F
0E8A  018E     CLRF PORTC
76:                BTFSC INDF1,3
0E8B  1981     BTFSC INDF1, 0x3
77:                MOVLW DATA_ONE
0E8C  3090     MOVLW 0x90
78:                MOVWF LATC & 0x7F
0E8D  008E     MOVWF PORTC
79:            
80:                // bit 4
81:                MOVLW DATA_ZERO
0E8E  3048     MOVLW 0x48
82:                CLRF LATC & 0x7F
0E8F  018E     CLRF PORTC
83:                BTFSC INDF1,4
0E90  1A01     BTFSC INDF1, 0x4
84:                MOVLW DATA_ONE
0E91  3090     MOVLW 0x90
85:                MOVWF LATC & 0x7F
0E92  008E     MOVWF PORTC
86:            
87:                // bit 5
88:                MOVLW DATA_ZERO
0E93  3048     MOVLW 0x48
89:                CLRF LATC & 0x7F
0E94  018E     CLRF PORTC
90:                BTFSC INDF1,5
0E95  1A81     BTFSC INDF1, 0x5
91:                MOVLW DATA_ONE
0E96  3090     MOVLW 0x90
92:                MOVWF LATC & 0x7F
0E97  008E     MOVWF PORTC
93:            
94:                // bit 6
95:                MOVLW DATA_ZERO
0E98  3048     MOVLW 0x48
96:                CLRF LATC & 0x7F
0E99  018E     CLRF PORTC
97:                BTFSC INDF1,6
0E9A  1B01     BTFSC INDF1, 0x6
98:                MOVLW DATA_ONE
0E9B  3090     MOVLW 0x90
99:                MOVWF LATC & 0x7F
0E9C  008E     MOVWF PORTC
100:           
101:               // bit 7
102:               MOVLW DATA_ZERO
0E9D  3048     MOVLW 0x48
103:               CLRF LATC & 0x7F
0E9E  018E     CLRF PORTC
104:               BTFSC INDF1,7
0E9F  1B81     BTFSC INDF1, 0x7
105:               MOVLW DATA_ONE
0EA0  3090     MOVLW 0x90
106:               MOVWF LATC & 0x7F
0EA1  008E     MOVWF PORTC
107:           
108:               // select next byte
109:               ADDFSR FSR1, 0x01 & 0x3F
0EA2  3141     ADDFSR 1, 1
110:           
111:               // bit 8
112:               MOVLW DATA_ZERO
0EA3  3048     MOVLW 0x48
113:               CLRF LATC & 0x7F
0EA4  018E     CLRF PORTC
114:               BTFSC INDF1,0
0EA5  1801     BTFSC INDF1, 0x0
115:               MOVLW DATA_ONE
0EA6  3090     MOVLW 0x90
116:               MOVWF LATC & 0x7F
0EA7  008E     MOVWF PORTC
117:           
118:               // bit 9
119:               MOVLW DATA_ZERO
0EA8  3048     MOVLW 0x48
120:               CLRF LATC & 0x7F
0EA9  018E     CLRF PORTC
121:               BTFSC INDF1,1
0EAA  1881     BTFSC INDF1, 0x1
122:               MOVLW DATA_ONE
0EAB  3090     MOVLW 0x90
123:               MOVWF LATC & 0x7F
0EAC  008E     MOVWF PORTC
124:           
125:               // bit 10
126:               MOVLW DATA_ZERO
0EAD  3048     MOVLW 0x48
127:               CLRF LATC & 0x7F
0EAE  018E     CLRF PORTC
128:               BTFSC INDF1,2
0EAF  1901     BTFSC INDF1, 0x2
129:               MOVLW DATA_ONE
0EB0  3090     MOVLW 0x90
130:               MOVWF LATC & 0x7F
0EB1  008E     MOVWF PORTC
131:           
132:               // bit 11
133:               MOVLW DATA_ZERO
0EB2  3048     MOVLW 0x48
134:               CLRF LATC & 0x7F
0EB3  018E     CLRF PORTC
135:               BTFSC INDF1,3
0EB4  1981     BTFSC INDF1, 0x3
136:               MOVLW DATA_ONE
0EB5  3090     MOVLW 0x90
137:               MOVWF LATC & 0x7F
0EB6  008E     MOVWF PORTC
138:           
139:               // bit 12
140:               MOVLW DATA_ZERO
0EB7  3048     MOVLW 0x48
141:               CLRF LATC & 0x7F
0EB8  018E     CLRF PORTC
142:               BTFSC INDF1,4
0EB9  1A01     BTFSC INDF1, 0x4
143:               MOVLW DATA_ONE
0EBA  3090     MOVLW 0x90
144:               MOVWF LATC & 0x7F
0EBB  008E     MOVWF PORTC
145:           
146:               // bit 13
147:               MOVLW DATA_ZERO
0EBC  3048     MOVLW 0x48
148:               CLRF LATC & 0x7F
0EBD  018E     CLRF PORTC
149:               BTFSC INDF1,5
0EBE  1A81     BTFSC INDF1, 0x5
150:               MOVLW DATA_ONE
0EBF  3090     MOVLW 0x90
151:               MOVWF LATC & 0x7F
0EC0  008E     MOVWF PORTC
152:           
153:               // bit 14
154:               MOVLW DATA_ZERO
0EC1  3048     MOVLW 0x48
155:               CLRF LATC & 0x7F
0EC2  018E     CLRF PORTC
156:               BTFSC INDF1,6
0EC3  1B01     BTFSC INDF1, 0x6
157:               MOVLW DATA_ONE
0EC4  3090     MOVLW 0x90
158:               MOVWF LATC & 0x7F
0EC5  008E     MOVWF PORTC
159:           
160:               // bit 15
161:               MOVLW DATA_ZERO
0EC6  3048     MOVLW 0x48
162:               CLRF LATC & 0x7F
0EC7  018E     CLRF PORTC
163:               BTFSC INDF1,7
0EC8  1B81     BTFSC INDF1, 0x7
164:               MOVLW DATA_ONE
0EC9  3090     MOVLW 0x90
165:               MOVWF LATC & 0x7F
0ECA  008E     MOVWF PORTC
166:           
167:               // select next byte
168:               ADDFSR FSR1, 0x01 & 0x3F
0ECB  3141     ADDFSR 1, 1
169:           
170:               // bit 16
171:               MOVLW DATA_ZERO
0ECC  3048     MOVLW 0x48
172:               CLRF LATC & 0x7F
0ECD  018E     CLRF PORTC
173:               BTFSC INDF1,0
0ECE  1801     BTFSC INDF1, 0x0
174:               MOVLW DATA_ONE
0ECF  3090     MOVLW 0x90
175:               MOVWF LATC & 0x7F
0ED0  008E     MOVWF PORTC
176:           
177:               // bit 17
178:               MOVLW DATA_ZERO
0ED1  3048     MOVLW 0x48
179:               CLRF LATC & 0x7F
0ED2  018E     CLRF PORTC
180:               BTFSC INDF1,1
0ED3  1881     BTFSC INDF1, 0x1
181:               MOVLW DATA_ONE
0ED4  3090     MOVLW 0x90
182:               MOVWF LATC & 0x7F
0ED5  008E     MOVWF PORTC
183:           
184:               // bit 18
185:               MOVLW DATA_ZERO
0ED6  3048     MOVLW 0x48
186:               CLRF LATC & 0x7F
0ED7  018E     CLRF PORTC
187:               BTFSC INDF1,2
0ED8  1901     BTFSC INDF1, 0x2
188:               MOVLW DATA_ONE
0ED9  3090     MOVLW 0x90
189:               MOVWF LATC & 0x7F
0EDA  008E     MOVWF PORTC
190:           
191:               // bit 19
192:               MOVLW DATA_ZERO
0EDB  3048     MOVLW 0x48
193:               CLRF LATC & 0x7F
0EDC  018E     CLRF PORTC
194:               BTFSC INDF1,3
0EDD  1981     BTFSC INDF1, 0x3
195:               MOVLW DATA_ONE
0EDE  3090     MOVLW 0x90
196:               MOVWF LATC & 0x7F
0EDF  008E     MOVWF PORTC
197:           
198:               // bit 20
199:               MOVLW DATA_ZERO
0EE0  3048     MOVLW 0x48
200:               CLRF LATC & 0x7F
0EE1  018E     CLRF PORTC
201:               BTFSC INDF1,4
0EE2  1A01     BTFSC INDF1, 0x4
202:               MOVLW DATA_ONE
0EE3  3090     MOVLW 0x90
203:               MOVWF LATC & 0x7F
0EE4  008E     MOVWF PORTC
204:           
205:               // bit 21
206:               MOVLW DATA_ZERO
0EE5  3048     MOVLW 0x48
207:               CLRF LATC & 0x7F
0EE6  018E     CLRF PORTC
208:               BTFSC INDF1,5
0EE7  1A81     BTFSC INDF1, 0x5
209:               MOVLW DATA_ONE
0EE8  3090     MOVLW 0x90
210:               MOVWF LATC & 0x7F
0EE9  008E     MOVWF PORTC
211:           
212:               // bit 22
213:               MOVLW DATA_ZERO
0EEA  3048     MOVLW 0x48
214:               CLRF LATC & 0x7F
0EEB  018E     CLRF PORTC
215:               BTFSC INDF1,6
0EEC  1B01     BTFSC INDF1, 0x6
216:               MOVLW DATA_ONE
0EED  3090     MOVLW 0x90
217:               MOVWF LATC & 0x7F
0EEE  008E     MOVWF PORTC
218:           
219:               // bit 23
220:               MOVLW DATA_ZERO
0EEF  3048     MOVLW 0x48
221:               CLRF LATC & 0x7F
0EF0  018E     CLRF PORTC
222:               BTFSC INDF1,7
0EF1  1B81     BTFSC INDF1, 0x7
223:               MOVLW DATA_ONE
0EF2  3090     MOVLW 0x90
224:               MOVWF LATC & 0x7F
0EF3  008E     MOVWF PORTC
225:           
226:               // select next byte
227:               ADDFSR FSR1, 0x01 & 0x3F
0EF4  3141     ADDFSR 1, 1
228:           
229:               // bit 24
230:               MOVLW DATA_ZERO
0EF5  3048     MOVLW 0x48
231:               CLRF LATC & 0x7F
0EF6  018E     CLRF PORTC
232:               BTFSC INDF1,0
0EF7  1801     BTFSC INDF1, 0x0
233:               MOVLW DATA_ONE
0EF8  3090     MOVLW 0x90
234:               MOVWF LATC & 0x7F
0EF9  008E     MOVWF PORTC
235:           
236:               // bit 25
237:               MOVLW DATA_ZERO
0EFA  3048     MOVLW 0x48
238:               CLRF LATC & 0x7F
0EFB  018E     CLRF PORTC
239:               BTFSC INDF1,1
0EFC  1881     BTFSC INDF1, 0x1
240:               MOVLW DATA_ONE
0EFD  3090     MOVLW 0x90
241:               MOVWF LATC & 0x7F
0EFE  008E     MOVWF PORTC
242:           
243:               // bit 26
244:               MOVLW DATA_ZERO
0EFF  3048     MOVLW 0x48
245:               CLRF LATC & 0x7F
0F00  018E     CLRF PORTC
246:               BTFSC INDF1,2
0F01  1901     BTFSC INDF1, 0x2
247:               MOVLW DATA_ONE
0F02  3090     MOVLW 0x90
248:               MOVWF LATC & 0x7F
0F03  008E     MOVWF PORTC
249:           
250:               // bit 27
251:               MOVLW DATA_ZERO
0F04  3048     MOVLW 0x48
252:               CLRF LATC & 0x7F
0F05  018E     CLRF PORTC
253:               BTFSC INDF1,3
0F06  1981     BTFSC INDF1, 0x3
254:               MOVLW DATA_ONE
0F07  3090     MOVLW 0x90
255:               MOVWF LATC & 0x7F
0F08  008E     MOVWF PORTC
256:           
257:               // bit 28
258:               MOVLW DATA_ZERO
0F09  3048     MOVLW 0x48
259:               CLRF LATC & 0x7F
0F0A  018E     CLRF PORTC
260:               BTFSC INDF1,4
0F0B  1A01     BTFSC INDF1, 0x4
261:               MOVLW DATA_ONE
0F0C  3090     MOVLW 0x90
262:               MOVWF LATC & 0x7F
0F0D  008E     MOVWF PORTC
263:           
264:               // bit 29
265:               MOVLW DATA_ZERO
0F0E  3048     MOVLW 0x48
266:               CLRF LATC & 0x7F
0F0F  018E     CLRF PORTC
267:               BTFSC INDF1,5
0F10  1A81     BTFSC INDF1, 0x5
268:               MOVLW DATA_ONE
0F11  3090     MOVLW 0x90
269:               MOVWF LATC & 0x7F
0F12  008E     MOVWF PORTC
270:           
271:               // bit 30
272:               MOVLW DATA_ZERO
0F13  3048     MOVLW 0x48
273:               CLRF LATC & 0x7F
0F14  018E     CLRF PORTC
274:               BTFSC INDF1,6
0F15  1B01     BTFSC INDF1, 0x6
275:               MOVLW DATA_ONE
0F16  3090     MOVLW 0x90
276:               MOVWF LATC & 0x7F
0F17  008E     MOVWF PORTC
277:           
278:               // bit 31
279:               MOVF _last_bit0 & 0x7F,W
0F18  0858     MOVF CtrlTrfData, W
280:               CLRF LATC & 0x7F
0F19  018E     CLRF PORTC
281:               BTFSC INDF1,7
0F1A  1B81     BTFSC INDF1, 0x7
282:               MOVF _last_bit1 & 0x7F,W
0F1B  0859     MOVF 0x59, W
283:               MOVWF LATC & 0x7F
0F1C  008E     MOVWF PORTC
284:           
285:               // select next byte
286:               ADDFSR FSR1, 0x01 & 0x3F
0F1D  3141     ADDFSR 1, 1
287:           
288:               // check if done
289:               DECFSZ _send32_count & 0x7F, F
0F1E  0BDC     DECFSZ 0x5C, F
290:               GOTO next_word
0F1F  2E7A     GOTO 0x67A
291:               #endasm
292:               HASH_IDLE();
0F20  30D8     MOVLW 0xD8
0F21  0022     MOVLB 0x2
0F22  008E     MOVWF PORTC
293:           }
0F23  0008     RETURN
294:           
295:           #define r(x) ((x-n)&7)
296:           
297:           DWORD rotate(DWORD x, BYTE y)
298:           {
299:               return ((x<<y) | (x>>(32-y)));
0DF3  0823     MOVF 0x23, W
0DF4  00A8     MOVWF 0x28
0DF5  0824     MOVF 0x24, W
0DF6  00A9     MOVWF 0x29
0DF7  0825     MOVF 0x25, W
0DF8  00AA     MOVWF 0x2A
0DF9  0826     MOVF 0x26, W
0DFA  00AB     MOVWF 0x2B
0DFB  0827     MOVF 0x27, W
0DFC  3C20     SUBLW 0x20
0DFD  0A89     INCF WREG, F
0DFE  2E04     GOTO 0x604
0DFF  1003     BCF STATUS, 0x0
0E00  0CAB     RRF 0x2B, F
0E01  0CAA     RRF 0x2A, F
0E02  0CA9     RRF 0x29, F
0E03  0CA8     RRF 0x28, F
0E04  3EFF     ADDLW 0xFF
0E05  1D03     BTFSS STATUS, 0x2
0E06  2DFF     GOTO 0x5FF
0E07  0823     MOVF 0x23, W
0E08  00AC     MOVWF 0x2C
0E09  0824     MOVF 0x24, W
0E0A  00AD     MOVWF 0x2D
0E0B  0825     MOVF 0x25, W
0E0C  00AE     MOVWF 0x2E
0E0D  0826     MOVF 0x26, W
0E0E  00AF     MOVWF 0x2F
0E0F  0A27     INCF 0x27, W
0E10  2E15     GOTO 0x615
0E11  35AC     LSLF 0x2C, F
0E12  0DAD     RLF 0x2D, F
0E13  0DAE     RLF 0x2E, F
0E14  0DAF     RLF 0x2F, F
0E15  0B89     DECFSZ WREG, F
0E16  2E11     GOTO 0x611
0E17  082C     MOVF 0x2C, W
0E18  04A8     IORWF 0x28, F
0E19  082D     MOVF 0x2D, W
0E1A  04A9     IORWF 0x29, F
0E1B  082E     MOVF 0x2E, W
0E1C  04AA     IORWF 0x2A, F
0E1D  082F     MOVF 0x2F, W
0E1E  04AB     IORWF 0x2B, F
0E1F  082B     MOVF 0x2B, W
0E20  00A6     MOVWF 0x26
0E21  082A     MOVF 0x2A, W
0E22  00A5     MOVWF 0x25
0E23  0829     MOVF 0x29, W
0E24  00A4     MOVWF 0x24
0E25  0828     MOVF 0x28, W
0E26  00A3     MOVWF 0x23
300:           }
0E27  0008     RETURN
301:           
302:           void AsicPreCalc(WORKTASK *work)
303:           {
304:               const DWORD K[3] = { 0x428a2f98, 0x71374491, 0xb5c0fbcf };
1021  3498     RETLW 0x98
1022  342F     RETLW 0x2F
1023  348A     RETLW 0x8A
1024  3442     RETLW 0x42
1025  3491     RETLW 0x91
1026  3444     RETLW 0x44
1027  3437     RETLW 0x37
1028  3471     RETLW 0x71
1029  34CF     RETLW 0xCF
102A  34FB     RETLW 0xFB
102B  34C0     RETLW 0xC0
102C  34B5     RETLW 0xB5
305:               DWORD x, y, z;
306:               DWORD m[8];
307:               BYTE n;
308:               
309:               for(n = 0; n < 8; n++)
0B1F  01E6     CLRF pUEP
0B4A  3008     MOVLW 0x8
0B4B  0AE6     INCF pUEP, F
0B4C  0266     SUBWF pUEP, W
0B4D  1C03     BTFSS STATUS, 0x0
0B4E  2B20     GOTO 0x320
310:                   m[n] = work->MidState[n];
0B20  0866     MOVF pUEP, W
0B21  00B2     MOVWF 0x32
0B22  01B3     CLRF 0x33
0B23  35B2     LSLF 0x32, F
0B24  0DB3     RLF 0x33, F
0B25  35B2     LSLF 0x32, F
0B26  0DB3     RLF 0x33, F
0B27  0832     MOVF 0x32, W
0B28  0730     ADDWF 0x30, W
0B29  00B4     MOVWF 0x34
0B2A  0833     MOVF 0x33, W
0B2B  3D31     ADDWFC 0x31, W
0B2C  00B5     MOVWF 0x35
0B2D  3001     MOVLW 0x1
0B2E  0734     ADDWF 0x34, W
0B2F  0084     MOVWF FSR0L
0B30  0835     MOVF 0x35, W
0B31  1803     BTFSC STATUS, 0x0
0B32  0A35     INCF 0x35, W
0B33  0085     MOVWF FSR0H
0B34  3F00     MOVIW [0]FSR0
0B35  00B6     MOVWF 0x36
0B36  3F01     MOVIW [1]FSR0
0B37  00B7     MOVWF 0x37
0B38  3F02     MOVIW [2]FSR0
0B39  00B8     MOVWF 0x38
0B3A  3F03     MOVIW [3]FSR0
0B3B  00B9     MOVWF 0x39
0B3C  0866     MOVF pUEP, W
0B3D  0709     ADDWF WREG, W
0B3E  0709     ADDWF WREG, W
0B3F  3EBE     ADDLW 0xBE
0B40  0086     MOVWF FSR1L
0B41  0187     CLRF FSR1H
0B42  0836     MOVF 0x36, W
0B43  3FC0     MOVWI [0]FSR1
0B44  0837     MOVF 0x37, W
0B45  3FC1     MOVWI [1]FSR1
0B46  0838     MOVF 0x38, W
0B47  3FC2     MOVWI [2]FSR1
0B48  0839     MOVF 0x39, W
0B49  3FC3     MOVWI [3]FSR1
311:           
312:               for(n = 0; n < 3; n++) {
0B4F  01E6     CLRF pUEP
0DE1  3003     MOVLW 0x3
0DE2  0AE6     INCF pUEP, F
0DE3  0266     SUBWF pUEP, W
0DE4  1803     BTFSC STATUS, 0x0
0DE5  0008     RETURN
0DE6  2B50     GOTO 0x350
313:           
314:                   x = m[5-n] ^ m[6-n];
0B50  30FC     MOVLW 0xFC
0B51  00A0     MOVWF BDT
0B52  0866     MOVF pUEP, W
0B53  25E7     CALL 0x5E7
0B54  3188     MOVLP 0x8
0B55  3E18     ADDLW 0x18
0B56  3EBE     ADDLW 0xBE
0B57  0086     MOVWF FSR1L
0B58  0187     CLRF FSR1H
0B59  3F40     MOVIW [0]FSR1
0B5A  00B2     MOVWF 0x32
0B5B  3F41     MOVIW [1]FSR1
0B5C  00B3     MOVWF 0x33
0B5D  3F42     MOVIW [2]FSR1
0B5E  00B4     MOVWF 0x34
0B5F  3F43     MOVIW [3]FSR1
0B60  00B5     MOVWF 0x35
0B61  30FC     MOVLW 0xFC
0B62  00A0     MOVWF BDT
0B63  0866     MOVF pUEP, W
0B64  25E7     CALL 0x5E7
0B65  3188     MOVLP 0x8
0B66  3E14     ADDLW 0x14
0B67  3EBE     ADDLW 0xBE
0B68  0086     MOVWF FSR1L
0B69  0187     CLRF FSR1H
0B6A  3F40     MOVIW [0]FSR1
0B6B  00B6     MOVWF 0x36
0B6C  3F41     MOVIW [1]FSR1
0B6D  00B7     MOVWF 0x37
0B6E  3F42     MOVIW [2]FSR1
0B6F  00B8     MOVWF 0x38
0B70  3F43     MOVIW [3]FSR1
0B71  00B9     MOVWF 0x39
0B72  0832     MOVF 0x32, W
0B73  0636     XORWF 0x36, W
0B74  00E2     MOVWF 0x62
0B75  0833     MOVF 0x33, W
0B76  0637     XORWF 0x37, W
0B77  00E3     MOVWF 0x63
0B78  0834     MOVF 0x34, W
0B79  0638     XORWF 0x38, W
0B7A  00E4     MOVWF 0x64
0B7B  0835     MOVF 0x35, W
0B7C  0639     XORWF 0x39, W
0B7D  00E5     MOVWF 0x65
315:                   x = x & m[4-n];
0B7E  30FC     MOVLW 0xFC
0B7F  00A0     MOVWF BDT
0B80  0866     MOVF pUEP, W
0B81  25E7     CALL 0x5E7
0B82  3188     MOVLP 0x8
0B83  3E10     ADDLW 0x10
0B84  3EBE     ADDLW 0xBE
0B85  0086     MOVWF FSR1L
0B86  0187     CLRF FSR1H
0B87  3F40     MOVIW [0]FSR1
0B88  00B2     MOVWF 0x32
0B89  3F41     MOVIW [1]FSR1
0B8A  00B3     MOVWF 0x33
0B8B  3F42     MOVIW [2]FSR1
0B8C  00B4     MOVWF 0x34
0B8D  3F43     MOVIW [3]FSR1
0B8E  00B5     MOVWF 0x35
0B8F  0832     MOVF 0x32, W
0B90  05E2     ANDWF 0x62, F
0B91  0833     MOVF 0x33, W
0B92  05E3     ANDWF 0x63, F
0B93  0834     MOVF 0x34, W
0B94  05E4     ANDWF 0x64, F
0B95  0835     MOVF 0x35, W
0B96  05E5     ANDWF 0x65, F
316:                   x = m[6-n] ^ x;
0B97  30FC     MOVLW 0xFC
0B98  00A0     MOVWF BDT
0B99  0866     MOVF pUEP, W
0B9A  25E7     CALL 0x5E7
0B9B  3188     MOVLP 0x8
0B9C  3E18     ADDLW 0x18
0B9D  3EBE     ADDLW 0xBE
0B9E  0086     MOVWF FSR1L
0B9F  0187     CLRF FSR1H
0BA0  3F40     MOVIW [0]FSR1
0BA1  00B2     MOVWF 0x32
0BA2  3F41     MOVIW [1]FSR1
0BA3  00B3     MOVWF 0x33
0BA4  3F42     MOVIW [2]FSR1
0BA5  00B4     MOVWF 0x34
0BA6  3F43     MOVIW [3]FSR1
0BA7  00B5     MOVWF 0x35
0BA8  0832     MOVF 0x32, W
0BA9  06E2     XORWF 0x62, F
0BAA  0833     MOVF 0x33, W
0BAB  06E3     XORWF 0x63, F
0BAC  0834     MOVF 0x34, W
0BAD  06E4     XORWF 0x64, F
0BAE  0835     MOVF 0x35, W
0BAF  06E5     XORWF 0x65, F
317:                   x += K[n];
0BB0  0866     MOVF pUEP, W
0BB1  00B2     MOVWF 0x32
0BB2  3021     MOVLW 0x21
0BB3  01B3     CLRF 0x33
0BB4  35B2     LSLF 0x32, F
0BB5  0DB3     RLF 0x33, F
0BB6  35B2     LSLF 0x32, F
0BB7  0DB3     RLF 0x33, F
0BB8  00B4     MOVWF 0x34
0BB9  3090     MOVLW 0x90
0BBA  00B5     MOVWF 0x35
0BBB  0832     MOVF 0x32, W
0BBC  0734     ADDWF 0x34, W
0BBD  0086     MOVWF FSR1L
0BBE  0833     MOVF 0x33, W
0BBF  3D35     ADDWFC 0x35, W
0BC0  0087     MOVWF FSR1H
0BC1  3F40     MOVIW [0]FSR1
0BC2  07E2     ADDWF 0x62, F
0BC3  3F41     MOVIW [1]FSR1
0BC4  3DE3     ADDWFC 0x63, F
0BC5  3F42     MOVIW [2]FSR1
0BC6  3DE4     ADDWFC 0x64, F
0BC7  3F43     MOVIW [3]FSR1
0BC8  3DE5     ADDWFC 0x65, F
318:                   x += work->Merkle[n];
0BC9  0866     MOVF pUEP, W
0BCA  00B2     MOVWF 0x32
0BCB  01B3     CLRF 0x33
0BCC  35B2     LSLF 0x32, F
0BCD  0DB3     RLF 0x33, F
0BCE  35B2     LSLF 0x32, F
0BCF  0DB3     RLF 0x33, F
0BD0  0832     MOVF 0x32, W
0BD1  0730     ADDWF 0x30, W
0BD2  00B4     MOVWF 0x34
0BD3  0833     MOVF 0x33, W
0BD4  3D31     ADDWFC 0x31, W
0BD5  00B5     MOVWF 0x35
0BD6  0834     MOVF 0x34, W
0BD7  3E21     ADDLW 0x21
0BD8  0086     MOVWF FSR1L
0BD9  3000     MOVLW 0x0
0BDA  3D35     ADDWFC 0x35, W
0BDB  0087     MOVWF FSR1H
0BDC  3F40     MOVIW [0]FSR1
0BDD  07E2     ADDWF 0x62, F
0BDE  3F41     MOVIW [1]FSR1
0BDF  3DE3     ADDWFC 0x63, F
0BE0  3F42     MOVIW [2]FSR1
0BE1  3DE4     ADDWFC 0x64, F
0BE2  3F43     MOVIW [3]FSR1
0BE3  3DE5     ADDWFC 0x65, F
319:                   x += m[7-n];
0BE4  30FC     MOVLW 0xFC
0BE5  00A0     MOVWF BDT
0BE6  0866     MOVF pUEP, W
0BE7  25E7     CALL 0x5E7
0BE8  3188     MOVLP 0x8
0BE9  3E1C     ADDLW 0x1C
0BEA  3EBE     ADDLW 0xBE
0BEB  0086     MOVWF FSR1L
0BEC  0187     CLRF FSR1H
0BED  3F40     MOVIW [0]FSR1
0BEE  07E2     ADDWF 0x62, F
0BEF  3F41     MOVIW [1]FSR1
0BF0  3DE3     ADDWFC 0x63, F
0BF1  3F42     MOVIW [2]FSR1
0BF2  3DE4     ADDWFC 0x64, F
0BF3  3F43     MOVIW [3]FSR1
0BF4  3DE5     ADDWFC 0x65, F
320:                   y = rotate(m[4-n], 26);
0BF5  30FC     MOVLW 0xFC
0BF6  00A0     MOVWF BDT
0BF7  0866     MOVF pUEP, W
0BF8  25E7     CALL 0x5E7
0BF9  3188     MOVLP 0x8
0BFA  3E10     ADDLW 0x10
0BFB  3EBE     ADDLW 0xBE
0BFC  0086     MOVWF FSR1L
0BFD  0187     CLRF FSR1H
0BFE  3F40     MOVIW [0]FSR1
0BFF  00A3     MOVWF 0x23
0C00  3F41     MOVIW [1]FSR1
0C01  00A4     MOVWF 0x24
0C02  3F42     MOVIW [2]FSR1
0C03  00A5     MOVWF 0x25
0C04  3F43     MOVIW [3]FSR1
0C05  00A6     MOVWF 0x26
0C06  301A     MOVLW 0x1A
0C07  00A7     MOVWF 0x27
0C08  25F3     CALL 0x5F3
0C09  3188     MOVLP 0x8
0C0A  0826     MOVF 0x26, W
0C0B  00E1     MOVWF 0x61
0C0C  0825     MOVF 0x25, W
0C0D  00E0     MOVWF event
0C0E  0824     MOVF 0x24, W
0C0F  00DF     MOVWF 0x5F
0C10  0823     MOVF 0x23, W
0C11  00DE     MOVWF 0x5E
321:                   z = rotate(m[4-n], 21);
0C12  30FC     MOVLW 0xFC
0C13  00A0     MOVWF BDT
0C14  0866     MOVF pUEP, W
0C15  25E7     CALL 0x5E7
0C16  3188     MOVLP 0x8
0C17  3E10     ADDLW 0x10
0C18  3EBE     ADDLW 0xBE
0C19  0086     MOVWF FSR1L
0C1A  0187     CLRF FSR1H
0C1B  3F40     MOVIW [0]FSR1
0C1C  00A3     MOVWF 0x23
0C1D  3F41     MOVIW [1]FSR1
0C1E  00A4     MOVWF 0x24
0C1F  3F42     MOVIW [2]FSR1
0C20  00A5     MOVWF 0x25
0C21  3F43     MOVIW [3]FSR1
0C22  00A6     MOVWF 0x26
0C23  3015     MOVLW 0x15
0C24  00A7     MOVWF 0x27
0C25  25F3     CALL 0x5F3
0C26  3188     MOVLP 0x8
0C27  0826     MOVF 0x26, W
0C28  00BD     MOVWF 0x3D
0C29  0825     MOVF 0x25, W
0C2A  00BC     MOVWF 0x3C
0C2B  0824     MOVF 0x24, W
0C2C  00BB     MOVWF 0x3B
0C2D  0823     MOVF 0x23, W
0C2E  00BA     MOVWF 0x3A
322:                   z = y^z;
0C2F  085E     MOVF 0x5E, W
0C30  06BA     XORWF 0x3A, F
0C31  085F     MOVF 0x5F, W
0C32  06BB     XORWF 0x3B, F
0C33  0860     MOVF event, W
0C34  06BC     XORWF 0x3C, F
0C35  0861     MOVF 0x61, W
0C36  06BD     XORWF 0x3D, F
323:                   y = rotate(m[4-n], 7);
0C37  30FC     MOVLW 0xFC
0C38  00A0     MOVWF BDT
0C39  0866     MOVF pUEP, W
0C3A  25E7     CALL 0x5E7
0C3B  3188     MOVLP 0x8
0C3C  3E10     ADDLW 0x10
0C3D  3EBE     ADDLW 0xBE
0C3E  0086     MOVWF FSR1L
0C3F  0187     CLRF FSR1H
0C40  3F40     MOVIW [0]FSR1
0C41  00A3     MOVWF 0x23
0C42  3F41     MOVIW [1]FSR1
0C43  00A4     MOVWF 0x24
0C44  3F42     MOVIW [2]FSR1
0C45  00A5     MOVWF 0x25
0C46  3F43     MOVIW [3]FSR1
0C47  00A6     MOVWF 0x26
0C48  3007     MOVLW 0x7
0C49  00A7     MOVWF 0x27
0C4A  25F3     CALL 0x5F3
0C4B  3188     MOVLP 0x8
0C4C  0826     MOVF 0x26, W
0C4D  00E1     MOVWF 0x61
0C4E  0825     MOVF 0x25, W
0C4F  00E0     MOVWF event
0C50  0824     MOVF 0x24, W
0C51  00DF     MOVWF 0x5F
0C52  0823     MOVF 0x23, W
0C53  00DE     MOVWF 0x5E
324:                   z = y^z;
0C54  06BA     XORWF 0x3A, F
0C55  085F     MOVF 0x5F, W
0C56  06BB     XORWF 0x3B, F
0C57  0860     MOVF event, W
0C58  06BC     XORWF 0x3C, F
0C59  0861     MOVF 0x61, W
0C5A  06BD     XORWF 0x3D, F
325:                   m[7-n] = z+x;
0C5B  083A     MOVF 0x3A, W
0C5C  0762     ADDWF 0x62, W
0C5D  00B2     MOVWF 0x32
0C5E  083B     MOVF 0x3B, W
0C5F  3D63     ADDWFC 0x63, W
0C60  00B3     MOVWF 0x33
0C61  083C     MOVF 0x3C, W
0C62  3D64     ADDWFC 0x64, W
0C63  00B4     MOVWF 0x34
0C64  083D     MOVF 0x3D, W
0C65  3D65     ADDWFC 0x65, W
0C66  00B5     MOVWF 0x35
0C67  30FC     MOVLW 0xFC
0C68  00A0     MOVWF BDT
0C69  0866     MOVF pUEP, W
0C6A  25E7     CALL 0x5E7
0C6B  3188     MOVLP 0x8
0C6C  3E1C     ADDLW 0x1C
0C6D  3EBE     ADDLW 0xBE
0C6E  0086     MOVWF FSR1L
0C6F  0187     CLRF FSR1H
0C70  0832     MOVF 0x32, W
0C71  3FC0     MOVWI [0]FSR1
0C72  0833     MOVF 0x33, W
0C73  3FC1     MOVWI [1]FSR1
0C74  0834     MOVF 0x34, W
0C75  3FC2     MOVWI [2]FSR1
0C76  0835     MOVF 0x35, W
0C77  3FC3     MOVWI [3]FSR1
326:                   m[3-n] = m[3-n] + m[7-n];
0C78  30FC     MOVLW 0xFC
0C79  00A0     MOVWF BDT
0C7A  0866     MOVF pUEP, W
0C7B  25E7     CALL 0x5E7
0C7C  3188     MOVLP 0x8
0C7D  3E1C     ADDLW 0x1C
0C7E  3EBE     ADDLW 0xBE
0C7F  0086     MOVWF FSR1L
0C80  0187     CLRF FSR1H
0C81  3F40     MOVIW [0]FSR1
0C82  00B2     MOVWF 0x32
0C83  3F41     MOVIW [1]FSR1
0C84  00B3     MOVWF 0x33
0C85  3F42     MOVIW [2]FSR1
0C86  00B4     MOVWF 0x34
0C87  3F43     MOVIW [3]FSR1
0C88  00B5     MOVWF 0x35
0C89  30FC     MOVLW 0xFC
0C8A  00A0     MOVWF BDT
0C8B  0866     MOVF pUEP, W
0C8C  25E7     CALL 0x5E7
0C8D  3188     MOVLP 0x8
0C8E  3E0C     ADDLW 0xC
0C8F  3EBE     ADDLW 0xBE
0C90  0086     MOVWF FSR1L
0C91  0187     CLRF FSR1H
0C92  3F40     MOVIW [0]FSR1
0C93  07B2     ADDWF 0x32, F
0C94  3F41     MOVIW [1]FSR1
0C95  3DB3     ADDWFC 0x33, F
0C96  3F42     MOVIW [2]FSR1
0C97  3DB4     ADDWFC 0x34, F
0C98  3F43     MOVIW [3]FSR1
0C99  3DB5     ADDWFC 0x35, F
0C9A  30FC     MOVLW 0xFC
0C9B  00A0     MOVWF BDT
0C9C  0866     MOVF pUEP, W
0C9D  25E7     CALL 0x5E7
0C9E  3188     MOVLP 0x8
0C9F  3E0C     ADDLW 0xC
0CA0  3EBE     ADDLW 0xBE
0CA1  0086     MOVWF FSR1L
0CA2  0187     CLRF FSR1H
0CA3  0832     MOVF 0x32, W
0CA4  3FC0     MOVWI [0]FSR1
0CA5  0833     MOVF 0x33, W
0CA6  3FC1     MOVWI [1]FSR1
0CA7  0834     MOVF 0x34, W
0CA8  3FC2     MOVWI [2]FSR1
0CA9  0835     MOVF 0x35, W
0CAA  3FC3     MOVWI [3]FSR1
327:                   x = rotate(m[r(0)], 30);
0CAB  0866     MOVF pUEP, W
0CAC  3C00     SUBLW 0x0
0CAD  3907     ANDLW 0x7
0CAE  0709     ADDWF WREG, W
0CAF  0709     ADDWF WREG, W
0CB0  3EBE     ADDLW 0xBE
0CB1  0086     MOVWF FSR1L
0CB2  3F40     MOVIW [0]FSR1
0CB3  00A3     MOVWF 0x23
0CB4  3F41     MOVIW [1]FSR1
0CB5  00A4     MOVWF 0x24
0CB6  3F42     MOVIW [2]FSR1
0CB7  00A5     MOVWF 0x25
0CB8  3F43     MOVIW [3]FSR1
0CB9  00A6     MOVWF 0x26
0CBA  301E     MOVLW 0x1E
0CBB  00A7     MOVWF 0x27
0CBC  25F3     CALL 0x5F3
0CBD  3188     MOVLP 0x8
0CBE  0826     MOVF 0x26, W
0CBF  00E5     MOVWF 0x65
0CC0  0825     MOVF 0x25, W
0CC1  00E4     MOVWF 0x64
0CC2  0824     MOVF 0x24, W
0CC3  00E3     MOVWF 0x63
0CC4  0823     MOVF 0x23, W
0CC5  00E2     MOVWF 0x62
328:                   y = rotate(m[r(0)], 19);
0CC6  0866     MOVF pUEP, W
0CC7  3C00     SUBLW 0x0
0CC8  3907     ANDLW 0x7
0CC9  0709     ADDWF WREG, W
0CCA  0709     ADDWF WREG, W
0CCB  3EBE     ADDLW 0xBE
0CCC  0086     MOVWF FSR1L
0CCD  0187     CLRF FSR1H
0CCE  3F40     MOVIW [0]FSR1
0CCF  00A3     MOVWF 0x23
0CD0  3F41     MOVIW [1]FSR1
0CD1  00A4     MOVWF 0x24
0CD2  3F42     MOVIW [2]FSR1
0CD3  00A5     MOVWF 0x25
0CD4  3F43     MOVIW [3]FSR1
0CD5  00A6     MOVWF 0x26
0CD6  3013     MOVLW 0x13
0CD7  00A7     MOVWF 0x27
0CD8  25F3     CALL 0x5F3
0CD9  3188     MOVLP 0x8
0CDA  0826     MOVF 0x26, W
0CDB  00E1     MOVWF 0x61
0CDC  0825     MOVF 0x25, W
0CDD  00E0     MOVWF event
0CDE  0824     MOVF 0x24, W
0CDF  00DF     MOVWF 0x5F
0CE0  0823     MOVF 0x23, W
0CE1  00DE     MOVWF 0x5E
329:                   y = y^x;
0CE2  0862     MOVF 0x62, W
0CE3  06DE     XORWF 0x5E, F
0CE4  0863     MOVF 0x63, W
0CE5  06DF     XORWF 0x5F, F
0CE6  0864     MOVF 0x64, W
0CE7  06E0     XORWF event, F
0CE8  0865     MOVF 0x65, W
0CE9  06E1     XORWF 0x61, F
330:                   x = rotate(m[r(0)], 10);
0CEA  0866     MOVF pUEP, W
0CEB  3C00     SUBLW 0x0
0CEC  3907     ANDLW 0x7
0CED  0709     ADDWF WREG, W
0CEE  0709     ADDWF WREG, W
0CEF  3EBE     ADDLW 0xBE
0CF0  0086     MOVWF FSR1L
0CF1  0187     CLRF FSR1H
0CF2  3F40     MOVIW [0]FSR1
0CF3  00A3     MOVWF 0x23
0CF4  3F41     MOVIW [1]FSR1
0CF5  00A4     MOVWF 0x24
0CF6  3F42     MOVIW [2]FSR1
0CF7  00A5     MOVWF 0x25
0CF8  3F43     MOVIW [3]FSR1
0CF9  00A6     MOVWF 0x26
0CFA  300A     MOVLW 0xA
0CFB  00A7     MOVWF 0x27
0CFC  25F3     CALL 0x5F3
0CFD  3188     MOVLP 0x8
0CFE  0826     MOVF 0x26, W
0CFF  00E5     MOVWF 0x65
0D00  0825     MOVF 0x25, W
0D01  00E4     MOVWF 0x64
0D02  0824     MOVF 0x24, W
0D03  00E3     MOVWF 0x63
0D04  0823     MOVF 0x23, W
0D05  00E2     MOVWF 0x62
331:                   y = x^y;
0D06  06DE     XORWF 0x5E, F
0D07  0863     MOVF 0x63, W
0D08  06DF     XORWF 0x5F, F
0D09  0864     MOVF 0x64, W
0D0A  06E0     XORWF event, F
0D0B  0865     MOVF 0x65, W
0D0C  06E1     XORWF 0x61, F
332:                   x = m[r(0)] | m[r(1)];
0D0D  0866     MOVF pUEP, W
0D0E  3C01     SUBLW 0x1
0D0F  3907     ANDLW 0x7
0D10  0709     ADDWF WREG, W
0D11  0709     ADDWF WREG, W
0D12  3EBE     ADDLW 0xBE
0D13  0086     MOVWF FSR1L
0D14  0187     CLRF FSR1H
0D15  3F40     MOVIW [0]FSR1
0D16  00B2     MOVWF 0x32
0D17  3F41     MOVIW [1]FSR1
0D18  00B3     MOVWF 0x33
0D19  3F42     MOVIW [2]FSR1
0D1A  00B4     MOVWF 0x34
0D1B  3F43     MOVIW [3]FSR1
0D1C  00B5     MOVWF 0x35
0D1D  0866     MOVF pUEP, W
0D1E  3C00     SUBLW 0x0
0D1F  3907     ANDLW 0x7
0D20  0709     ADDWF WREG, W
0D21  0709     ADDWF WREG, W
0D22  3EBE     ADDLW 0xBE
0D23  0086     MOVWF FSR1L
0D24  3F40     MOVIW [0]FSR1
0D25  00B6     MOVWF 0x36
0D26  3F41     MOVIW [1]FSR1
0D27  00B7     MOVWF 0x37
0D28  3F42     MOVIW [2]FSR1
0D29  00B8     MOVWF 0x38
0D2A  3F43     MOVIW [3]FSR1
0D2B  00B9     MOVWF 0x39
0D2C  0832     MOVF 0x32, W
0D2D  0436     IORWF 0x36, W
0D2E  00E2     MOVWF 0x62
0D2F  0833     MOVF 0x33, W
0D30  0437     IORWF 0x37, W
0D31  00E3     MOVWF 0x63
0D32  0834     MOVF 0x34, W
0D33  0438     IORWF 0x38, W
0D34  00E4     MOVWF 0x64
0D35  0835     MOVF 0x35, W
0D36  0439     IORWF 0x39, W
0D37  00E5     MOVWF 0x65
333:                   x = m[r(2)] & x;
0D38  0866     MOVF pUEP, W
0D39  3C02     SUBLW 0x2
0D3A  3907     ANDLW 0x7
0D3B  0709     ADDWF WREG, W
0D3C  0709     ADDWF WREG, W
0D3D  3EBE     ADDLW 0xBE
0D3E  0086     MOVWF FSR1L
0D3F  3F40     MOVIW [0]FSR1
0D40  00B2     MOVWF 0x32
0D41  3F41     MOVIW [1]FSR1
0D42  00B3     MOVWF 0x33
0D43  3F42     MOVIW [2]FSR1
0D44  00B4     MOVWF 0x34
0D45  3F43     MOVIW [3]FSR1
0D46  00B5     MOVWF 0x35
0D47  0832     MOVF 0x32, W
0D48  05E2     ANDWF 0x62, F
0D49  0833     MOVF 0x33, W
0D4A  05E3     ANDWF 0x63, F
0D4B  0834     MOVF 0x34, W
0D4C  05E4     ANDWF 0x64, F
0D4D  0835     MOVF 0x35, W
0D4E  05E5     ANDWF 0x65, F
334:                   z = m[r(0)] & m[r(1)];
0D4F  0866     MOVF pUEP, W
0D50  3C01     SUBLW 0x1
0D51  3907     ANDLW 0x7
0D52  0709     ADDWF WREG, W
0D53  0709     ADDWF WREG, W
0D54  3EBE     ADDLW 0xBE
0D55  0086     MOVWF FSR1L
0D56  3F40     MOVIW [0]FSR1
0D57  00B2     MOVWF 0x32
0D58  3F41     MOVIW [1]FSR1
0D59  00B3     MOVWF 0x33
0D5A  3F42     MOVIW [2]FSR1
0D5B  00B4     MOVWF 0x34
0D5C  3F43     MOVIW [3]FSR1
0D5D  00B5     MOVWF 0x35
0D5E  0866     MOVF pUEP, W
0D5F  3C00     SUBLW 0x0
0D60  3907     ANDLW 0x7
0D61  0709     ADDWF WREG, W
0D62  0709     ADDWF WREG, W
0D63  3EBE     ADDLW 0xBE
0D64  0086     MOVWF FSR1L
0D65  3F40     MOVIW [0]FSR1
0D66  00B6     MOVWF 0x36
0D67  3F41     MOVIW [1]FSR1
0D68  00B7     MOVWF 0x37
0D69  3F42     MOVIW [2]FSR1
0D6A  00B8     MOVWF 0x38
0D6B  3F43     MOVIW [3]FSR1
0D6C  00B9     MOVWF 0x39
0D6D  0832     MOVF 0x32, W
0D6E  0536     ANDWF 0x36, W
0D6F  00BA     MOVWF 0x3A
0D70  0833     MOVF 0x33, W
0D71  0537     ANDWF 0x37, W
0D72  00BB     MOVWF 0x3B
0D73  0834     MOVF 0x34, W
0D74  0538     ANDWF 0x38, W
0D75  00BC     MOVWF 0x3C
0D76  0835     MOVF 0x35, W
0D77  0539     ANDWF 0x39, W
0D78  00BD     MOVWF 0x3D
335:                   x = x | z;
0D79  083A     MOVF 0x3A, W
0D7A  04E2     IORWF 0x62, F
0D7B  083B     MOVF 0x3B, W
0D7C  04E3     IORWF 0x63, F
0D7D  083C     MOVF 0x3C, W
0D7E  04E4     IORWF 0x64, F
0D7F  083D     MOVF 0x3D, W
0D80  04E5     IORWF 0x65, F
336:                   m[7-n] += y + x;
0D81  085E     MOVF 0x5E, W
0D82  0762     ADDWF 0x62, W
0D83  00B2     MOVWF 0x32
0D84  085F     MOVF 0x5F, W
0D85  3D63     ADDWFC 0x63, W
0D86  00B3     MOVWF 0x33
0D87  0860     MOVF event, W
0D88  3D64     ADDWFC 0x64, W
0D89  00B4     MOVWF 0x34
0D8A  0861     MOVF 0x61, W
0D8B  3D65     ADDWFC 0x65, W
0D8C  00B5     MOVWF 0x35
0D8D  30FC     MOVLW 0xFC
0D8E  00A0     MOVWF BDT
0D8F  0866     MOVF pUEP, W
0D90  25E7     CALL 0x5E7
0D91  3188     MOVLP 0x8
0D92  3E1C     ADDLW 0x1C
0D93  3EBE     ADDLW 0xBE
0D94  0086     MOVWF FSR1L
0D95  0187     CLRF FSR1H
0D96  0832     MOVF 0x32, W
0D97  0781     ADDWF INDF1, F
0D98  3141     ADDFSR 1, 1
0D99  0833     MOVF 0x33, W
0D9A  3D81     ADDWFC INDF1, F
0D9B  3141     ADDFSR 1, 1
0D9C  0834     MOVF 0x34, W
0D9D  3D81     ADDWFC INDF1, F
0D9E  3141     ADDFSR 1, 1
0D9F  0835     MOVF 0x35, W
0DA0  3D81     ADDWFC INDF1, F
337:           
338:                   PrecalcHashes[n] = m[7-n];
0DA1  30FC     MOVLW 0xFC
0DA2  00A0     MOVWF BDT
0DA3  0866     MOVF pUEP, W
0DA4  25E7     CALL 0x5E7
0DA5  3188     MOVLP 0x8
0DA6  3E1C     ADDLW 0x1C
0DA7  3EBE     ADDLW 0xBE
0DA8  0086     MOVWF FSR1L
0DA9  0187     CLRF FSR1H
0DAA  3F40     MOVIW [0]FSR1
0DAB  00B2     MOVWF 0x32
0DAC  3F41     MOVIW [1]FSR1
0DAD  00B3     MOVWF 0x33
0DAE  3F42     MOVIW [2]FSR1
0DAF  00B4     MOVWF 0x34
0DB0  3F43     MOVIW [3]FSR1
0DB1  00B5     MOVWF 0x35
0DB2  0866     MOVF pUEP, W
0DB3  0709     ADDWF WREG, W
0DB4  0709     ADDWF WREG, W
0DB5  3EAD     ADDLW 0xAD
0DB6  0086     MOVWF FSR1L
0DB7  3001     MOVLW 0x1
0DB8  0087     MOVWF FSR1H
0DB9  0832     MOVF 0x32, W
0DBA  3FC0     MOVWI [0]FSR1
0DBB  0833     MOVF 0x33, W
0DBC  3FC1     MOVWI [1]FSR1
0DBD  0834     MOVF 0x34, W
0DBE  3FC2     MOVWI [2]FSR1
0DBF  0835     MOVF 0x35, W
0DC0  3FC3     MOVWI [3]FSR1
339:                   PrecalcHashes[n+2] = m[3-n];
0DC1  30FC     MOVLW 0xFC
0DC2  00A0     MOVWF BDT
0DC3  0866     MOVF pUEP, W
0DC4  25E7     CALL 0x5E7
0DC5  3188     MOVLP 0x8
0DC6  3E0C     ADDLW 0xC
0DC7  3EBE     ADDLW 0xBE
0DC8  0086     MOVWF FSR1L
0DC9  0187     CLRF FSR1H
0DCA  3F40     MOVIW [0]FSR1
0DCB  00B2     MOVWF 0x32
0DCC  3F41     MOVIW [1]FSR1
0DCD  00B3     MOVWF 0x33
0DCE  3F42     MOVIW [2]FSR1
0DCF  00B4     MOVWF 0x34
0DD0  3F43     MOVIW [3]FSR1
0DD1  00B5     MOVWF 0x35
0DD2  0866     MOVF pUEP, W
0DD3  0709     ADDWF WREG, W
0DD4  0709     ADDWF WREG, W
0DD5  3EB5     ADDLW 0xB5
0DD6  0086     MOVWF FSR1L
0DD7  3001     MOVLW 0x1
0DD8  0087     MOVWF FSR1H
0DD9  0832     MOVF 0x32, W
0DDA  3FC0     MOVWI [0]FSR1
0DDB  0833     MOVF 0x33, W
0DDC  3FC1     MOVWI [1]FSR1
0DDD  0834     MOVF 0x34, W
0DDE  3FC2     MOVWI [2]FSR1
0DDF  0835     MOVF 0x35, W
0DE0  3FC3     MOVWI [3]FSR1
340:               }
341:           }
0DE7  00A2     MOVWF 0x22
342:           
343:           //#define R(a, b, c, d, e, f, g, h, w, k) \
344:           //    h = h + (rotate(e, 26) ^ rotate(e, 21) ^ rotate(e, 7)) + (g ^ (e & (f ^ g))) + k + w; \
345:           //    d = d + h; \
346:           //    h = h + (rotate(a, 30) ^ rotate(a, 19) ^ rotate(a, 10)) + ((a & b) | (c & (a | b)))
347:           
348:           /* this version uses too much stack and causes overflow
349:            * re-written above to be more flat and as first step to
350:            * assembly optimization
351:            *
352:           DWORD rotate(DWORD x, BYTE y)
353:           {
354:               return ((x<<y) | (x>>(32-y)));
355:           }
356:           
357:           void R1(DWORD *m, DWORD w, DWORD k)
358:           {
359:               m[7] = m[7] + (rotate(m[4], 26) ^ rotate(m[4], 21) ^ rotate(m[4], 7)) + (m[6] ^ (m[4] & (m[5] ^ m[6]))) + k + w;
360:               m[3] = m[3] + m[7];
361:               m[7] = m[7] + (rotate(m[0], 30) ^ rotate(m[0], 19) ^ rotate(m[0], 10)) + ((m[0] & m[1]) | (m[2] & (m[0] | m[1])));
362:           }
363:           
364:           void R2(DWORD *m)
365:           {
366:               DWORD hold = m[7];
367:               for(BYTE x=7; x > 0; x--)
368:                   m[x] = m[x-1];
369:               m[0] = hold;
370:           }
371:           
372:           extern BYTE WorkNow;
373:           extern WORKTASK WorkQue[MAX_WORK_COUNT];
374:           
375:           DWORD precalc_hash[6];
376:           
377:           void HasherPreCalc(void)
378:           {
379:               const DWORD K[3] = { 0x428a2f98, 0x71374491, 0xb5c0fbcf };
380:               DWORD m[8];
381:               BYTE n;
382:               for(n = 0; n < 8; n++)
383:                   m[n] = WorkQue[WorkNow].MidState[n];
384:           
385:               R1(m, WorkQue[WorkNow].Merkle[0], K[0]);
386:               precalc_hash[0] = m[7];
387:               precalc_hash[3] = m[3];
388:               R2(m);
389:               R1(m, WorkQue[WorkNow].Merkle[1], K[1]);
390:               precalc_hash[1] = m[7];
391:               precalc_hash[4] = m[3];
392:               R2(m);
393:               R1(m, WorkQue[WorkNow].Merkle[2], K[2]);
394:               precalc_hash[2] = m[7];
395:               precalc_hash[5] = m[3];
396:           }
397:           */
---  /home/chris/Dev/klondike/firmware/USB/usb_device.c  ------------------------------------------------
1:             /********************************************************************
2:               File Information:
3:                 FileName:     	usb_device.c
4:                 Dependencies:	See INCLUDES section
5:                 Processor:		PIC18,PIC24, PIC32 and dsPIC33E USB Microcontrollers
6:                 Hardware:		This code is natively intended to be used on Mirochip USB
7:                                 demo boards.  See www.microchip.com/usb (Software & Tools 
8:                                 section) for list of available platforms.  The firmware may 
9:                                 be modified for use on other USB platforms by editing the
10:                				HardwareProfile.h and HardwareProfile - [platform].h files.
11:                Complier:  	    Microchip C18 (for PIC18),C30 (for PIC24 and dsPIC33E)
12:                                and C32 (for PIC32)
13:                Company:		Microchip Technology, Inc.
14:                
15:                Software License Agreement:
16:                
17:                The software supplied herewith by Microchip Technology Incorporated
18:                (the "Company") for its PIC(r) Microcontroller is intended and
19:                supplied to you, the Company's customer, for use solely and
20:                exclusively on Microchip PIC Microcontroller products. The
21:                software is owned by the Company and/or its supplier, and is
22:                protected under applicable copyright laws. All rights are reserved.
23:                Any use in violation of the foregoing restrictions may subject the
24:                user to criminal sanctions under applicable laws, as well as to
25:                civil liability for the breach of the terms and conditions of this
26:                license.
27:                
28:                THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
29:                WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
30:                TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
31:                PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
32:                IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
33:                CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
34:            
35:              Summary:
36:                This file contains functions, macros, definitions, variables,
37:                datatypes, etc. that are required for usage with the MCHPFSUSB device
38:                stack. This file should be included in projects that use the device stack. 
39:                
40:                This file is located in the "\<Install Directory\>\\Microchip\\USB"
41:                directory.
42:            
43:              Description:
44:                USB Device Stack File
45:                
46:                This file contains functions, macros, definitions, variables,
47:                datatypes, etc. that are required for usage with the MCHPFSUSB device
48:                stack. This file should be included in projects that use the device stack.
49:                
50:                This file is located in the "\<Install Directory\>\\Microchip\\USB"
51:                directory.
52:                
53:                When including this file in a new project, this file can either be
54:                referenced from the directory in which it was installed or copied
55:                directly into the user application folder. If the first method is
56:                chosen to keep the file located in the folder in which it is installed
57:                then include paths need to be added so that the library and the
58:                application both know where to reference each others files. If the
59:                application folder is located in the same folder as the Microchip
60:                folder (like the current demo folders), then the following include
61:                paths need to be added to the application's project:
62:                
63:                .
64:                ..\\..\\MicrochipInclude
65:                
66:                If a different directory structure is used, modify the paths as
67:                required. An example using absolute paths instead of relative paths
68:                would be the following:
69:                
70:                C:\\Microchip Solutions\\Microchip\\Include
71:                
72:                C:\\Microchip Solutions\\My Demo Application 
73:            
74:            ********************************************************************
75:             File Description:
76:            
77:             Change History:
78:              Rev    Description
79:              ----   -----------
80:              2.6    Added USBCancelIO() function.  Moved and some stack
81:                     defintions to be more consistant with the host stack.
82:            
83:              2.6a   Fixed issue where a SET_CONFIGURATION received could cause
84:                     inability to transmit on an endpoint if using ping-pong
85:                     and an odd number of packets had been sent on that endpoint 
86:            
87:              2.7    Fixed error where the USB error interrupt flag was not getting
88:                     cleared properly for PIC32 resulting in lots of extra error interrupts.
89:                     http://www.microchip.com/forums/tm.aspx?m=479085
90:            
91:                     Fixed issue with dual role mode when device run in polling
92:                     mode.  Interrupts were remaining enabled after the host mode
93:                     operation was complete.  This was incompatible with polling
94:                     mode operation.
95:            
96:                     Changed how the bus sensing works.  In previous revisions it
97:                     was impossible to use the USBDeviceDetach to detach from the
98:                     bus if the bus voltage was still present.  This is now
99:                     possible.  It was also possible to move the device to the 
100:                    ATTACHED state in interrupt mode even if the bus voltage 
101:                    wasn't available.  This is now prohibited unless VBUS is
102:                    present.
103:                    
104:                    Improved error case handling when the host sends more OUT
105:                    bytes in a control transfer than the firmware was expecting
106:                    to receive (based on the size parameter when calling USBEP0Receive()).
107:                    
108:                    In the USBStdSetCfgHandler(), modified the code so the USBDeviceState
109:                    variable only gets updated to the CONFIGURED_STATE at the end of the 
110:                    function.  
111:           
112:             2.7a   Update to support the PIC18F47J53 A1 and later revision
113:                    devices.
114:           
115:                    Fixed an error on 16-bit and 32-bit processors where a word access
116:                    could be performed on a byte pointer resulting in possible address
117:                    errors with odd aligned pointers.
118:                    
119:             2.8    Several changes to the way control transfers get processed,
120:                    so as to support the ability to allow application/class specific
121:                    handler code to defer the status stage.  
122:                    Implemented USBCtrlEPAllowStatusStage() API function.
123:                    Implemented USBDeferStatusStage() API function (macro).
124:                    These changes also greatly relax the USBDeviceTasks() calling frequency 
125:                    requirement, while allowing USB class handlers more flexibility.
126:                    
127:                    Also implemented the following API functions and macros, for delaying 
128:                    the data stage of a control transfer (with data stage):
129:                    USBDeferINDataStage()
130:                    USBDeferOUTDataStage()
131:                    USBOUTDataStageDeferred()
132:                    USBINDataStageDeferred()
133:                    USBCtrlEPAllowDataStage()      
134:                    
135:                    Fixed USB reset event handler issue, where the USB stack would 
136:                    re-initialize global interrupt settings in the interrupt context, on 
137:                    PIC18 devices with the stack operated in USB_INTERRUPT mode.
138:                    
139:                    Fixed handling of SET/CLEAR FEATURE (endpoint halt) host requests.
140:                    Previous implementation would not always initialize endpoints correctly 
141:                    to DATA0 DTS state after a clear feature endpoint halt request, for 
142:                    all ping pong mode and usage scenarios.
143:                    
144:              2.9   Fixed an issue with STALL handling behavior on non-EP0 endpoints, for 
145:                    PIC24 and PIC32 devices.  
146:              		  
147:              		 Fixed an issue where the ep_data_in[]/ep_data_out[] flags weren't 
148:              		 getting re-initialized coincident with the hardware ping pong pointer 
149:              		 reset during set configuration events.
150:              		 
151:              		 Implemented USBGetNextHandle() API function (actually a macro, defined
152:              		 in usb_device.h).
153:           
154:              2.9d  Added build option for disabling DTS checking
155:              
156:              2.9f  Adding pragma for PIC18F97J94 Family BDT location.
157:           
158:              2.9h  Updated to be able to support optional Microsoft OS Descriptors
159:           
160:              2.9i  Updated to set UCON<SUSPND> bit on PIC16F USB devices during 
161:                    suspend, so as to save power.
162:              
163:           ********************************************************************/
164:           
165:           /*----------------------------------------------------------------------------------
166:           The USBDeviceTasks() function is responsible for detecting and processing various
167:           USB bus events and host requests, such as those required for USB enumeration, when
168:           the USB cable is first attached to the host.  This function is the main dispatcher
169:           routine for the USB stack.
170:           
171:           Additional API functions and macros are also provided by the USB stack, which can be 
172:           used to send/receive USB data to/from the host, among other things.  A full list 
173:           of the available implemented functions/macros are provided in the 
174:           "MCHPFSUSB Library Help".  For normal installations of the MCHPFSUSB Framework,
175:           the USB API documentation can be found from:
176:           
177:           Start menu --> (All Programs) --> Microchip --> MCHPFSUSB vX.x --> Documents --> MCHPFSUSB Library Help
178:           
179:           Once the help file is opened, the API functions/macros are described in the following section:
180:           Library Interface (API) --> Device/Peripheral --> Device Stack --> Interface Routines
181:           Additional API functions may also be provided depending upon the specific USB device class
182:           implemented, and these functions are also documented in the MCHPFSUSB Library Help.
183:           
184:           
185:           If the USB stack is operated in "USB_POLLING" mode (user selectable option in 
186:           usb_config.h), then the application firmware is reponsible for calling the 
187:           USBDeviceTasks() function periodically.  If the USB stack is operated in the 
188:           "USB_INTERRUPT" mode, then the application firmware does not have to directly 
189:           call USBDeviceTasks(), as it will execute only when necessary as an interrupt handler.
190:           
191:           In order to properly operate a USB connection, and to correctly process and respond
192:           to control transfers in the maximum time allowed by the USB specifications, the
193:           USBDeviceTasks() function/interrupt handler must be allowed to execute in a timely
194:           fashion.
195:           
196:           When the USB module is enabled, the USB cable is attached to the host, the USB bus
197:           is not in the suspend state, and the USB stack is operated in the USB_POLLING mode 
198:           with ping pong buffering enabled (at least) on EP0 OUT,  then the maximum allowed 
199:           time between calls to the USBDeviceTasks() function needs to be:
200:           
201:           The faster of:
202:           1.  Once per ~1.8ms, when USBDeviceState == ADR_PENDING_STATE
203:           2.  Once per ~9.8ms, when USBDeviceState == (any other value other than ADR_PENDING_STATE)
204:           3.  Fast enough to ensure the USTAT FIFO can never get full.  See additional explanation below.
205:           
206:           Additional details of the above timing limits are provided:
207:           
208:           Timing item #1: This parameter originates from the 2ms set address "recovery interval"
209:           specification dictated by section "9.2.6.3 Set Address Processing" of the official 
210:           USB 2.0 specifications.
211:           
212:           Timing item #2: This parameter originates from several "10 ms" criteria in the 
213:           USB 2.0 specifications.  For example, reset recovery intervals, resume recovery 
214:           intervals, suspend to actual current reduction, etc. have timing maximums of 10ms.
215:           
216:           Timing item #3: This is not a fixed X.X ms parameter, but depends on the  
217:           transaction rate implemented by the application.  The USBDeviceTasks() function is
218:           responsible for popping entries off the USTAT FIFO.  If the FIFO ever gets full,
219:           then no further USB transactions are allowed to occur, until the firmware pops entries
220:           off the FIFO.  In practice, this means the firmware should call USBDeviceTasks() at
221:           a rate at least as fast as once every three times the USBTransferOnePacket() function
222:           is called.  This ensures that the rate that USTAT FIFO entries are getting added to
223:           the FIFO is lower than the rate that the entries are getting popped off the FIFO (the
224:           USBDeviceTasks() function will pop up to 4 entries per call), which is a
225:           necessary criteria to ensure the USTAT FIFO entries don't "pile up."  Calling
226:           USBDeviceTasks() even more often, ex: >=1 to 1 ratio of USBDeviceTasks() to 
227:           USBTransferOnePacket(), adds further protection against the USTAT FIFO getting full,
228:           and is therefore recommended.
229:           
230:           When the USB stack is operated in USB_INTERRUPT mode, then the above timing 
231:           parameters should be interpreted to be the longest allowed time that the USB 
232:           interrupts may be masked/disabled for, before re-enabling the USB interrupts.
233:           
234:           Calling USBDeviceTasks() (or allowing USBDeviceTasks() to be called) more often 
235:           will still have potential USB data rate speed and processing latency benefits.
236:           It is also beneficial to call USBDeviceTasks() more often than theoretically 
237:           required, since it has been observed that not all host/drivers/bios/hubs are 
238:           100% consistently compliant with all timing parameters of the USB 2.0 specifications.
239:           Therefore, in a USB_POLLING based application, it is still suggested to call 
240:           USBDeviceTasks() as often as there are free CPU cycles.  This ensures best 
241:           performance, along with best possible compatibility with all existing USB 
242:           hosts/hubs (both those that are compliant and [partially] non-compliant).
243:           
244:           If ping pong buffering is not enabled on (at least) EP0 OUT, then it is required
245:           to call (or allow to execute) USBDeviceTasks() much more frequently (ex: once 
246:           per 100us, or preferrably faster).  Therefore, in all applications, it is 
247:           normally recommended to select either the USB_PING_PONG__FULL_PING_PONG or 
248:           USB_PING_PONG__EP0_OUT_ONLY mode (user option in usb_config.h), as these modes
249:           allow for much more relaxed timing requirements, and therefore greater application
250:           firmware design flexibility.
251:           //----------------------------------------------------------------------------------*/
252:           
253:           /** INCLUDES *******************************************************/
254:           #include "./USB/usb.h"
255:           #include "HardwareProfile.h"
256:           
257:           #include "../USB/usb_device_local.h"
258:           
259:           
260:           #if defined(USB_USE_MSD)
261:               #include "./USB/usb_function_msd.h"
262:           #endif
263:           
264:           #if !defined(USE_USB_BUS_SENSE_IO)
265:               #undef USB_BUS_SENSE
266:               #define USB_BUS_SENSE 1
267:           #endif
268:           
269:           #if defined(USB_DEVICE_DISABLE_DTS_CHECKING)
270:               #define _DTS_CHECKING_ENABLED 0
271:           #else
272:               #define _DTS_CHECKING_ENABLED _DTSEN
273:           #endif
274:           
275:           /** DEFINITIONS ****************************************************/
276:           
277:           /** VARIABLES ******************************************************/
278:           #if defined(__18CXX)
279:               #pragma udata
280:           #endif
281:           
282:           USB_VOLATILE USB_DEVICE_STATE USBDeviceState;
283:           USB_VOLATILE BYTE USBActiveConfiguration;
284:           USB_VOLATILE BYTE USBAlternateInterface[USB_MAX_NUM_INT];
285:           volatile BDT_ENTRY *pBDTEntryEP0OutCurrent;
286:           volatile BDT_ENTRY *pBDTEntryEP0OutNext;
287:           volatile BDT_ENTRY *pBDTEntryOut[USB_MAX_EP_NUMBER+1];
288:           volatile BDT_ENTRY *pBDTEntryIn[USB_MAX_EP_NUMBER+1];
289:           USB_VOLATILE BYTE shortPacketStatus;
290:           USB_VOLATILE BYTE controlTransferState;
291:           USB_VOLATILE IN_PIPE inPipes[1];
292:           USB_VOLATILE OUT_PIPE outPipes[1];
293:           USB_VOLATILE BYTE *pDst;
294:           USB_VOLATILE BOOL RemoteWakeup;
295:           USB_VOLATILE BOOL USBBusIsSuspended;
296:           USB_VOLATILE USTAT_FIELDS USTATcopy;
297:           USB_VOLATILE BYTE endpoint_number;
298:           USB_VOLATILE BOOL BothEP0OutUOWNsSet;
299:           USB_VOLATILE EP_STATUS ep_data_in[USB_MAX_EP_NUMBER+1];
300:           USB_VOLATILE EP_STATUS ep_data_out[USB_MAX_EP_NUMBER+1];
301:           USB_VOLATILE BYTE USBStatusStageTimeoutCounter;
302:           volatile BOOL USBDeferStatusStagePacket;
303:           volatile BOOL USBStatusStageEnabledFlag1;
304:           volatile BOOL USBStatusStageEnabledFlag2;
305:           volatile BOOL USBDeferINDataStagePackets;
306:           volatile BOOL USBDeferOUTDataStagePackets;
307:           
308:           
309:           #if (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
310:               #define BDT_NUM_ENTRIES      ((USB_MAX_EP_NUMBER + 1) * 2)
311:           #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
312:               #define BDT_NUM_ENTRIES      (((USB_MAX_EP_NUMBER + 1) * 2)+1)
313:           #elif (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
314:               #define BDT_NUM_ENTRIES      ((USB_MAX_EP_NUMBER + 1) * 4)
315:           #elif (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
316:               #define BDT_NUM_ENTRIES      (((USB_MAX_EP_NUMBER + 1) * 4)-2)
317:           #else
318:               #error "No ping pong mode defined."
319:           #endif
320:           
321:           /** USB FIXED LOCATION VARIABLES ***********************************/
322:           #if defined(__18CXX)
323:               #pragma udata USB_BDT=USB_BDT_ADDRESS
324:           #endif
325:           
326:           volatile BDT_ENTRY BDT[BDT_NUM_ENTRIES] BDT_BASE_ADDR_TAG;
327:           
328:           /********************************************************************
329:            * Section B: EP0 Buffer Space
330:            *******************************************************************/
331:           volatile CTRL_TRF_SETUP SetupPkt CTRL_TRF_SETUP_ADDR_TAG;
332:           volatile BYTE CtrlTrfData[USB_EP0_BUFF_SIZE] CTRL_TRF_DATA_ADDR_TAG;
333:           
334:           /********************************************************************
335:            * Section C: non-EP0 Buffer Space
336:            *******************************************************************/
337:           #if defined(USB_USE_MSD)
338:           	//volatile far USB_MSD_CBW_CSW msd_cbw_csw;
339:           	volatile USB_MSD_CBW msd_cbw;
340:           	volatile USB_MSD_CSW msd_csw;
341:           	//#pragma udata
342:           
343:           	#if defined(__18CXX)
344:           		#pragma udata myMSD=MSD_BUFFER_ADDRESS
345:           	#endif
346:           	volatile char msd_buffer[512];
347:           #endif
348:           
349:           
350:           
351:           ////Depricated in v2.2 - will be removed in a future revision
352:           #if !defined(USB_USER_DEVICE_DESCRIPTOR)
353:               //Device descriptor
354:               extern ROM USB_DEVICE_DESCRIPTOR device_dsc;
355:           #else
356:               USB_USER_DEVICE_DESCRIPTOR_INCLUDE;
357:           #endif
358:           
359:           #if !defined(USB_USER_CONFIG_DESCRIPTOR)
360:               //Array of configuration descriptors
361:               extern ROM BYTE *ROM USB_CD_Ptr[];
362:           #else
363:               USB_USER_CONFIG_DESCRIPTOR_INCLUDE;
364:           #endif
365:           
366:           extern ROM BYTE *ROM USB_SD_Ptr[];
367:           
368:           /** DECLARATIONS ***************************************************/
369:           #if defined(__18CXX)
370:               #pragma code
371:           #endif
372:           
373:           /** Macros *********************************************************/
374:           
375:           /** Function Prototypes ********************************************/
376:           //External
377:           //This is the prototype for the required user event handler
378:           BOOL USER_USB_CALLBACK_EVENT_HANDLER(int event, void *pdata, WORD size);
379:           
380:           //Internal Functions
381:           static void USBCtrlEPService(void);
382:           static void USBCtrlTrfSetupHandler(void);
383:           static void USBCtrlTrfInHandler(void);
384:           static void USBCheckStdRequest(void);
385:           static void USBStdGetDscHandler(void);
386:           static void USBCtrlEPServiceComplete(void);
387:           static void USBCtrlTrfTxService(void);
388:           static void USBCtrlTrfRxService(void);
389:           static void USBStdSetCfgHandler(void);
390:           static void USBStdGetStatusHandler(void);
391:           static void USBStdFeatureReqHandler(void);
392:           static void USBCtrlTrfOutHandler(void);
393:           static void USBConfigureEndpoint(BYTE EPNum, BYTE direction);
394:           static void USBWakeFromSuspend(void);
395:           static void USBSuspend(void);
396:           static void USBStallHandler(void);
397:           
398:           //static BOOL USBIsTxBusy(BYTE EPNumber);
399:           //static void USBPut(BYTE EPNum, BYTE Data);
400:           //static void USBEPService(void);
401:           //static void USBProtocolResetHandler(void);
402:           
403:           /******************************************************************************/
404:           /** Function Implementations *************************************************/
405:           /******************************************************************************/
406:           
407:           /******************************************************************************/
408:           /** Internal Macros *********************************************************/
409:           /******************************************************************************/
410:           
411:           /****************************************************************************
412:             Function:
413:               void USBAdvancePingPongBuffer(BDT_ENTRY** buffer)
414:           
415:             Description:
416:               This function will advance the passed pointer to the next buffer based on
417:               the ping pong option setting.  This function should be used for EP1-EP15
418:               only.  This function is not valid for EP0.
419:           
420:             Precondition:
421:               None
422:           
423:             Parameters:
424:               BDT_ENTRY** - pointer to the BDT_ENTRY pointer that you want to be advanced
425:               to the next buffer state
426:           
427:             Return Values:
428:               None
429:           
430:             Remarks:
431:               None
432:           
433:             ***************************************************************************/
434:           #define USBAdvancePingPongBuffer(buffer) ((BYTE_VAL*)buffer)->Val ^= USB_NEXT_PING_PONG;
435:           #define USBHALPingPongSetToOdd(buffer)   {((BYTE_VAL*)buffer)->Val |= USB_NEXT_PING_PONG;}
436:           #define USBHALPingPongSetToEven(buffer)  {((BYTE_VAL*)buffer)->Val &= ~USB_NEXT_PING_PONG;}
437:           
438:           
439:           /******************************************************************************/
440:           /** External API Functions ****************************************************/
441:           /******************************************************************************/
442:           
443:           /**************************************************************************
444:               Function:
445:                   void USBDeviceInit(void)
446:               
447:               Description:
448:                   This function initializes the device stack it in the default state. The
449:                   USB module will be completely reset including all of the internal
450:                   variables, registers, and interrupt flags.
451:                           
452:               Precondition:
453:                   This function must be called before any of the other USB Device
454:                   functions can be called, including USBDeviceTasks().
455:                   
456:               Parameters:
457:                   None
458:                
459:               Return Values:
460:                   None
461:                   
462:               Remarks:
463:                   None
464:                                                                     
465:             ***************************************************************************/
466:           void USBDeviceInit(void)
467:           {
468:               BYTE i;
469:           
470:               USBDisableInterrupts();
0215  0021     MOVLB 0x1
0216  1112     BCF PIR2, 0x2
065E  0021     MOVLB 0x1
065F  1112     BCF PIR2, 0x2
471:           
472:               // Clear all USB error flags
473:               USBClearInterruptRegister(U1EIR);  
0217  003D     MOVLB 0x1D
0218  0193     CLRF 0x13
0660  003D     MOVLB 0x1D
0661  0193     CLRF 0x13
474:                  
475:               // Clears all USB interrupts          
476:               USBClearInterruptRegister(U1IR); 
0219  0190     CLRF 0x10
0662  0190     CLRF 0x10
477:           
478:               //Clear all of the endpoint control registers
479:               U1EP0 = 0;
021A  0198     CLRF T1CON
0663  0198     CLRF T1CON
480:               
481:               DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
021B  300E     MOVLW 0xE
021C  00F3     MOVWF handle
021D  3099     MOVLW 0x99
021E  00F2     MOVWF p
021F  01F4     CLRF i_750
0220  0872     MOVF p, W
0221  0086     MOVWF FSR1L
0222  0873     MOVF handle, W
0223  0087     MOVWF FSR1H
0224  0181     CLRF INDF1
0225  0AF2     INCF p, F
0226  1903     BTFSC STATUS, 0x2
0227  0AF3     INCF handle, F
0228  3002     MOVLW 0x2
0229  0AF4     INCF i_750, F
022A  0274     SUBWF i_750, W
022B  1C03     BTFSS STATUS, 0x0
022C  2A20     GOTO 0x220
0664  300E     MOVLW 0xE
0665  0021     MOVLB 0x1
0666  00A3     MOVWF 0x23
0667  3099     MOVLW 0x99
0668  00A2     MOVWF 0x22
0669  01A4     CLRF 0x24
066A  0822     MOVF 0x22, W
066B  0086     MOVWF FSR1L
066C  0823     MOVF 0x23, W
066D  0087     MOVWF FSR1H
066E  0181     CLRF INDF1
066F  0AA2     INCF 0x22, F
0670  1903     BTFSC STATUS, 0x2
0671  0AA3     INCF 0x23, F
0672  3002     MOVLW 0x2
0673  0AA4     INCF 0x24, F
0674  0224     SUBWF 0x24, W
0675  1C03     BTFSS STATUS, 0x0
0676  2E6A     GOTO 0x66A
482:           
483:               SetConfigurationOptions();
022D  3016     MOVLW 0x16
022E  0091     MOVWF PIR1
022F  309F     MOVLW 0x9F
0230  0097     MOVWF TMR1H
0231  307B     MOVLW 0x7B
0232  0092     MOVWF PIR2
0677  3016     MOVLW 0x16
0678  003D     MOVLB 0x1D
0679  0091     MOVWF PIR1
067A  309F     MOVLW 0x9F
067B  0097     MOVWF TMR1H
067C  307B     MOVLW 0x7B
067D  0092     MOVWF PIR2
484:           
485:               //power up the module (if not already powered)
486:               USBPowerModule();
487:           
488:               //set the address of the BDT (if applicable)
489:               USBSetBDTAddress(BDT);
490:           
491:               //Clear all of the BDT entries
492:               for(i=0;i<(sizeof(BDT)/sizeof(BDT_ENTRY));i++)
0233  01F5     CLRF i
023F  300C     MOVLW 0xC
0240  0AF5     INCF i, F
0241  0275     SUBWF i, W
0242  1C03     BTFSS STATUS, 0x0
0243  2A34     GOTO 0x234
067E  0021     MOVLB 0x1
067F  01A5     CLRF 0x25
068B  300C     MOVLW 0xC
068C  0AA5     INCF 0x25, F
068D  0225     SUBWF 0x25, W
068E  1C03     BTFSS STATUS, 0x0
068F  2E80     GOTO 0x680
493:               {
494:                   BDT[i].Val = 0x00;
0234  0875     MOVF i, W
0235  0709     ADDWF WREG, W
0236  0709     ADDWF WREG, W
0237  3E20     ADDLW 0x20
0238  0086     MOVWF FSR1L
0239  3000     MOVLW 0x0
023A  0187     CLRF FSR1H
023B  3FC0     MOVWI [0]FSR1
023C  3FC1     MOVWI [1]FSR1
023D  3FC2     MOVWI [2]FSR1
023E  3FC3     MOVWI [3]FSR1
0680  0825     MOVF 0x25, W
0681  0709     ADDWF WREG, W
0682  0709     ADDWF WREG, W
0683  3E20     ADDLW 0x20
0684  0086     MOVWF FSR1L
0685  3000     MOVLW 0x0
0686  0187     CLRF FSR1H
0687  3FC0     MOVWI [0]FSR1
0688  3FC1     MOVWI [1]FSR1
0689  3FC2     MOVWI [2]FSR1
068A  3FC3     MOVWI [3]FSR1
495:               }
496:           
497:               // Assert reset request to all of the Ping Pong buffer pointers
498:               USBPingPongBufferReset = 1;                    
0244  170E     BSF PORTC, 0x6
0690  003D     MOVLB 0x1D
0691  170E     BSF PORTC, 0x6
499:           
500:               // Reset to default address
501:               U1ADDR = 0x00;                   
0245  0196     CLRF TMR1L
0692  0196     CLRF TMR1L
502:           
503:               // Make sure packet processing is enabled
504:               USBPacketDisable = 0;           
0246  120E     BCF PORTC, 0x4
0693  120E     BCF PORTC, 0x4
505:           
506:               //Stop trying to reset ping pong buffer pointers
507:               USBPingPongBufferReset = 0;
0247  130E     BCF PORTC, 0x6
0694  130E     BCF PORTC, 0x6
508:           
509:               // Flush any pending transactions
510:               while(USBTransactionCompleteIF == 1)      
0248  003D     MOVLB 0x1D
0249  1D90     BTFSS 0x10, 0x3
024A  2A52     GOTO 0x252
0251  2A48     GOTO 0x248
0695  003D     MOVLB 0x1D
0696  1D90     BTFSS 0x10, 0x3
0697  2E9F     GOTO 0x69F
069E  2E95     GOTO 0x695
511:               {
512:                   USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
024B  1190     BCF 0x10, 0x3
0698  1190     BCF 0x10, 0x3
513:                   //Initialize USB stack software state variables
514:                   inPipes[0].info.Val = 0;
024C  0022     MOVLB 0x2
024D  01E0     CLRF event
0699  0022     MOVLB 0x2
069A  01E0     CLRF event
515:                   outPipes[0].info.Val = 0;
024E  01B3     CLRF 0x33
069B  01B3     CLRF 0x33
516:                   outPipes[0].wCount.Val = 0;
024F  01B4     CLRF 0x34
0250  01B5     CLRF 0x35
069C  01B4     CLRF 0x34
069D  01B5     CLRF 0x35
517:               }
518:           
519:               //Set flags to TRUE, so the USBCtrlEPAllowStatusStage() function knows not to
520:               //try and arm a status stage, even before the first control transfer starts.
521:               USBStatusStageEnabledFlag1 = TRUE;  
0252  3001     MOVLW 0x1
0253  0022     MOVLB 0x2
0254  00CE     MOVWF 0x4E
069F  3001     MOVLW 0x1
06A0  0022     MOVLB 0x2
06A1  00CE     MOVWF 0x4E
522:               USBStatusStageEnabledFlag2 = TRUE;
0255  00CF     MOVWF 0x4F
06A2  00CF     MOVWF 0x4F
523:               //Initialize other flags
524:               USBDeferINDataStagePackets = FALSE;
0256  01CA     CLRF 0x4A
06A3  01CA     CLRF 0x4A
525:               USBDeferOUTDataStagePackets = FALSE;
0257  01CB     CLRF 0x4B
06A4  01CB     CLRF 0x4B
526:               USBBusIsSuspended = FALSE;
0258  0023     MOVLB 0x3
0259  01AC     CLRF 0x2C
06A5  0023     MOVLB 0x3
06A6  01AC     CLRF 0x2C
527:           
528:           	//Initialize all pBDTEntryIn[] and pBDTEntryOut[]
529:           	//pointers to NULL, so they don't get used inadvertently.  
530:           	for(i = 0; i < (BYTE)(USB_MAX_EP_NUMBER+1u); i++)
025A  01F5     CLRF i
026C  3003     MOVLW 0x3
026E  0AF5     INCF i, F
026F  0275     SUBWF i, W
0270  1C03     BTFSS STATUS, 0x0
0271  2A5B     GOTO 0x25B
06A7  0021     MOVLB 0x1
06A8  01A5     CLRF 0x25
06BA  3003     MOVLW 0x3
06BC  0AA5     INCF 0x25, F
06BD  0225     SUBWF 0x25, W
06BE  1C03     BTFSS STATUS, 0x0
06BF  2EA9     GOTO 0x6A9
531:           	{
532:           		pBDTEntryIn[i] = 0u;
025B  0875     MOVF i, W
025C  3E3D     ADDLW 0x3D
025D  0086     MOVWF FSR1L
025E  3001     MOVLW 0x1
025F  0087     MOVWF FSR1H
0260  0181     CLRF INDF1
06A9  0825     MOVF 0x25, W
06AA  3E3D     ADDLW 0x3D
06AB  0086     MOVWF FSR1L
06AC  3001     MOVLW 0x1
06AD  0087     MOVWF FSR1H
06AE  0181     CLRF INDF1
533:           		pBDTEntryOut[i] = 0u;		
0261  0875     MOVF i, W
0262  3E40     ADDLW 0x40
0263  0086     MOVWF FSR1L
0264  0181     CLRF INDF1
06AF  0825     MOVF 0x25, W
06B0  3E40     ADDLW 0x40
06B1  0086     MOVWF FSR1L
06B2  0181     CLRF INDF1
534:           		ep_data_in[i].Val = 0u;
0265  0875     MOVF i, W
0266  3E37     ADDLW 0x37
0267  0086     MOVWF FSR1L
0268  0181     CLRF INDF1
06B3  0825     MOVF 0x25, W
06B4  3E37     ADDLW 0x37
06B5  0086     MOVWF FSR1L
06B6  0181     CLRF INDF1
535:                   ep_data_out[i].Val = 0u;
0269  0875     MOVF i, W
026A  3E3A     ADDLW 0x3A
026B  0086     MOVWF FSR1L
026D  0181     CLRF INDF1
06B7  0825     MOVF 0x25, W
06B8  3E3A     ADDLW 0x3A
06B9  0086     MOVWF FSR1L
06BB  0181     CLRF INDF1
536:           	}
537:           
538:               //Get ready for the first packet
539:               pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
0272  3028     MOVLW 0x28
0273  0022     MOVLB 0x2
0274  00BD     MOVWF 0x3D
06C0  3028     MOVLW 0x28
06C1  0022     MOVLB 0x2
06C2  00BD     MOVWF 0x3D
540:               // Initialize EP0 as a Ctrl EP
541:               U1EP0 = EP_CTRL|USB_HANDSHAKE_ENABLED;        
0275  3016     MOVLW 0x16
0276  003D     MOVLB 0x1D
0277  0098     MOVWF T1CON
06C3  3016     MOVLW 0x16
06C4  003D     MOVLB 0x1D
06C5  0098     MOVWF T1CON
542:           	//Prepare for the first SETUP on EP0 OUT
543:               BDT[EP0_OUT_EVEN].ADR = ConvertToPhysicalAddress(&SetupPkt);
0278  3050     MOVLW 0x50
0279  00F0     MOVWF dir
027A  01F1     CLRF data
027B  0020     MOVLB 0x0
027C  00A2     MOVWF 0x22
027D  0871     MOVF data, W
027E  00A3     MOVWF 0x23
06C6  3050     MOVLW 0x50
06C7  0021     MOVLB 0x1
06C8  00A0     MOVWF BDT
06C9  01A1     CLRF 0x21
06CA  0020     MOVLB 0x0
06CB  00A2     MOVWF 0x22
06CC  0021     MOVLB 0x1
06CD  0821     MOVF 0x21, W
06CE  0020     MOVLB 0x0
06CF  00A3     MOVWF 0x23
544:               BDT[EP0_OUT_EVEN].CNT = USB_EP0_BUFF_SIZE;
027F  3008     MOVLW 0x8
0280  00A1     MOVWF 0x21
06D0  3008     MOVLW 0x8
06D1  00A1     MOVWF 0x21
545:               BDT[EP0_OUT_EVEN].STAT.Val = _USIE|_DAT0|_BSTALL;
0281  3084     MOVLW 0x84
0282  00A0     MOVWF BDT
06D2  3084     MOVLW 0x84
06D3  00A0     MOVWF BDT
546:           
547:               // Clear active configuration
548:               USBActiveConfiguration = 0;     
0283  0022     MOVLB 0x2
0284  01E3     CLRF 0x63
06D4  0022     MOVLB 0x2
06D5  01E3     CLRF 0x63
549:           
550:               //Indicate that we are now in the detached state        
551:               USBDeviceState = DETACHED_STATE;
0285  01CD     CLRF 0x4D
06D6  01CD     CLRF 0x4D
552:           }
0286  0008     RETURN
06D7  0008     RETURN
553:           
554:           /**************************************************************************
555:             Function:
556:                   void USBDeviceTasks(void)
557:               
558:             Summary:
559:               This function is the main state machine/transaction handler of the USB 
560:               device side stack.  When the USB stack is operated in "USB_POLLING" mode 
561:               (usb_config.h user option) the USBDeviceTasks() function should be called 
562:               periodically to receive and transmit packets through the stack. This 
563:               function also takes care of control transfers associated with the USB 
564:               enumeration process, and detecting various USB events (such as suspend).  
565:               This function should be called at least once every 1.8ms during the USB 
566:               enumeration process. After the enumeration process is complete (which can 
567:               be determined when USBGetDeviceState() returns CONFIGURED_STATE), the 
568:               USBDeviceTasks() handler may be called the faster of: either once 
569:               every 9.8ms, or as often as needed to make sure that the hardware USTAT 
570:               FIFO never gets full.  A good rule of thumb is to call USBDeviceTasks() at
571:               a minimum rate of either the frequency that USBTransferOnePacket() gets 
572:               called, or, once/1.8ms, whichever is faster.  See the inline code comments 
573:               near the top of usb_device.c for more details about minimum timing 
574:               requirements when calling USBDeviceTasks().
575:               
576:               When the USB stack is operated in "USB_INTERRUPT" mode, it is not necessary
577:               to call USBDeviceTasks() from the main loop context.  In the USB_INTERRUPT
578:               mode, the USBDeviceTasks() handler only needs to execute when a USB 
579:               interrupt occurs, and therefore only needs to be called from the interrupt 
580:               context.
581:           
582:             Description:
583:               This function is the main state machine/transaction handler of the USB 
584:               device side stack.  When the USB stack is operated in "USB_POLLING" mode 
585:               (usb_config.h user option) the USBDeviceTasks() function should be called 
586:               periodically to receive and transmit packets through the stack. This 
587:               function also takes care of control transfers associated with the USB 
588:               enumeration process, and detecting various USB events (such as suspend).  
589:               This function should be called at least once every 1.8ms during the USB 
590:               enumeration process. After the enumeration process is complete (which can 
591:               be determined when USBGetDeviceState() returns CONFIGURED_STATE), the 
592:               USBDeviceTasks() handler may be called the faster of: either once 
593:               every 9.8ms, or as often as needed to make sure that the hardware USTAT 
594:               FIFO never gets full.  A good rule of thumb is to call USBDeviceTasks() at
595:               a minimum rate of either the frequency that USBTransferOnePacket() gets 
596:               called, or, once/1.8ms, whichever is faster.  See the inline code comments 
597:               near the top of usb_device.c for more details about minimum timing 
598:               requirements when calling USBDeviceTasks().
599:               
600:               When the USB stack is operated in "USB_INTERRUPT" mode, it is not necessary
601:               to call USBDeviceTasks() from the main loop context.  In the USB_INTERRUPT
602:               mode, the USBDeviceTasks() handler only needs to execute when a USB 
603:               interrupt occurs, and therefore only needs to be called from the interrupt 
604:               context.
605:           
606:               Typical usage:
607:               <code>
608:               void main(void)
609:               {
610:                   USBDeviceInit();
611:                   while(1)
612:                   {
613:                       USBDeviceTasks(); //Takes care of enumeration and other USB events
614:                       if((USBGetDeviceState() \< CONFIGURED_STATE) ||
615:                          (USBIsDeviceSuspended() == TRUE))
616:                       {
617:                           //Either the device is not configured or we are suspended,
618:                           // so we don't want to execute any USB related application code
619:                           continue;   //go back to the top of the while loop
620:                       }
621:                       else
622:                       {
623:                           //Otherwise we are free to run USB and non-USB related user 
624:                           //application code.
625:                           UserApplication();
626:                       }
627:                   }
628:               }
629:               </code>
630:           
631:             Precondition:
632:               Make sure the USBDeviceInit() function has been called prior to calling
633:               USBDeviceTasks() for the first time.
634:             Remarks:
635:               USBDeviceTasks() does not need to be called while in the USB suspend mode, 
636:               if the user application firmware in the USBCBSuspend() callback function
637:               enables the ACTVIF USB interrupt source and put the microcontroller into 
638:               sleep mode.  If the application firmware decides not to sleep the 
639:               microcontroller core during USB suspend (ex: continues running at full 
640:               frequency, or clock switches to a lower frequency), then the USBDeviceTasks()
641:               function must still be called periodically, at a rate frequent enough to 
642:               ensure the 10ms resume recovery interval USB specification is met.  Assuming
643:               a worst case primary oscillator and PLL start up time of <5ms, then 
644:               USBDeviceTasks() should be called once every 5ms in this scenario.
645:              
646:               When the USB cable is detached, or the USB host is not actively powering 
647:               the VBUS line to +5V nominal, the application firmware does not always have 
648:               to call USBDeviceTasks() frequently, as no USB activity will be taking 
649:               place.  However, if USBDeviceTasks() is not called regularly, some 
650:               alternative means of promptly detecting when VBUS is powered (indicating 
651:               host attachment), or not powered (host powered down or USB cable unplugged)
652:               is still needed.  For self or dual self/bus powered USB applications, see 
653:               the USBDeviceAttach() and USBDeviceDetach() API documentation for additional 
654:               considerations.
655:                                
656:             **************************************************************************/
657:           
658:           #if defined(USB_INTERRUPT) 
659:           #if defined(__18CXX) || defined (_PIC14E)
660:               void USBDeviceTasks(void)
661:             #elif defined(__C30__) || defined __XC16__
662:               void __attribute__((interrupt,auto_psv)) _USB1Interrupt()
663:             #elif defined(__PIC32MX__)
664:               void __attribute__((interrupt(),vector(_USB_1_VECTOR))) _USB1Interrupt( void ) 
665:             #endif
666:           #else
667:           void USBDeviceTasks(void)
668:           #endif
669:           {
670:               BYTE i;
671:           
672:           #ifdef USB_SUPPORT_OTG
673:               //SRP Time Out Check
674:               if (USBOTGSRPIsReady())
675:               {
676:                   if (USBT1MSECIF && USBT1MSECIE)
677:                   {
678:                       if (USBOTGGetSRPTimeOutFlag())
679:                       {
680:                           if (USBOTGIsSRPTimeOutExpired())
681:                           {
682:                               USB_OTGEventHandler(0,OTG_EVENT_SRP_FAILED,0,0);
683:                           }       
684:                       }
685:           
686:                       //Clear Interrupt Flag
687:                       USBClearInterruptFlag(USBT1MSECIFReg,USBT1MSECIFBitNum);
688:                   }
689:               }
690:           #endif
691:           
692:               #if defined(USB_POLLING)
693:               //If the interrupt option is selected then the customer is required
694:               //  to notify the stack when the device is attached or removed from the
695:               //  bus by calling the USBDeviceAttach() and USBDeviceDetach() functions.
696:               if (USB_BUS_SENSE != 1)
697:               {
698:                    // Disable module & detach from bus
699:                    U1CON = 0;             
700:           
701:                    // Mask all USB interrupts              
702:                    U1IE = 0;          
703:           
704:                    //Move to the detached state                  
705:                    USBDeviceState = DETACHED_STATE;
706:           
707:                    #ifdef  USB_SUPPORT_OTG    
708:                        //Disable D+ Pullup
709:                        U1OTGCONbits.DPPULUP = 0;
710:           
711:                        //Disable HNP
712:                        USBOTGDisableHnp();
713:           
714:                        //Deactivate HNP
715:                        USBOTGDeactivateHnp();
716:                        
717:                        //If ID Pin Changed State
718:                        if (USBIDIF && USBIDIE)
719:                        {  
720:                            //Re-detect & Initialize
721:                             USBOTGInitialize();
722:           
723:                             //Clear ID Interrupt Flag
724:                             USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
725:                        }
726:                    #endif
727:           
728:                    #if defined __C30__ || defined __XC16__
729:                        //USBClearInterruptFlag(U1OTGIR, 3); 
730:                    #endif
731:                       //return so that we don't go through the rest of 
732:                       //the state machine
733:                    USBClearUSBInterrupt();
734:                    return;
735:               }
736:           
737:           	#ifdef USB_SUPPORT_OTG
738:               //If Session Is Started Then
739:               else
740:           	{
741:                   //If SRP Is Ready
742:                   if (USBOTGSRPIsReady())
743:                   {   
744:                       //Clear SRPReady
745:                       USBOTGClearSRPReady();
746:           
747:                       //Clear SRP Timeout Flag
748:                       USBOTGClearSRPTimeOutFlag();
749:           
750:                       //Indicate Session Started
751:                       UART2PrintString( "\r\n***** USB OTG B Event - Session Started  *****\r\n" );
752:                   }
753:               }
754:           	#endif	//#ifdef USB_SUPPORT_OTG
755:           
756:               //if we are in the detached state
757:               if(USBDeviceState == DETACHED_STATE)
758:               {
759:           	    //Initialize register to known value
760:                   U1CON = 0;                          
761:           
762:                   // Mask all USB interrupts
763:                   U1IE = 0;                                
764:           
765:                   //Enable/set things like: pull ups, full/low-speed mode, 
766:                   //set the ping pong mode, and set internal transceiver
767:                   SetConfigurationOptions();
768:           
769:                   // Enable module & attach to bus
770:                   while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
771:           
772:                   //moved to the attached state
773:                   USBDeviceState = ATTACHED_STATE;
774:           
775:                   #ifdef  USB_SUPPORT_OTG
776:                       U1OTGCON |= USB_OTG_DPLUS_ENABLE | USB_OTG_ENABLE;  
777:                   #endif
778:               }
779:           	#endif  //#if defined(USB_POLLING)
780:           
781:               if(USBDeviceState == ATTACHED_STATE)
0149  0022     MOVLB 0x2
014A  034D     DECF 0x4D, W
014B  1D03     BTFSS STATUS, 0x2
014C  2956     GOTO 0x156
782:               {
783:                   /*
784:                    * After enabling the USB module, it takes some time for the
785:                    * voltage on the D+ or D- line to rise high enough to get out
786:                    * of the SE0 condition. The USB Reset interrupt should not be
787:                    * unmasked until the SE0 condition is cleared. This helps
788:                    * prevent the firmware from misinterpreting this unique event
789:                    * as a USB bus reset from the USB host.
790:                    */
791:           
792:                   if(!USBSE0Event)
014D  003D     MOVLB 0x1D
014E  1A8E     BTFSC PORTC, 0x5
014F  2956     GOTO 0x156
793:                   {
794:                       USBClearInterruptRegister(U1IR);// Clear all USB interrupts
0150  0190     CLRF 0x10
795:                       #if defined(USB_POLLING)
796:                           U1IE=0;                        // Mask all USB interrupts
797:                       #endif
798:                       USBResetIE = 1;             // Unmask RESET interrupt
0151  1412     BSF PIR2, 0x0
799:                       USBIdleIE = 1;             // Unmask IDLE interrupt
0152  1612     BSF PIR2, 0x4
800:                       USBDeviceState = POWERED_STATE;
0153  3002     MOVLW 0x2
0154  0022     MOVLB 0x2
0155  00CD     MOVWF 0x4D
801:                   }
802:               }
803:           
804:               #ifdef  USB_SUPPORT_OTG
805:                   //If ID Pin Changed State
806:                   if (USBIDIF && USBIDIE)
807:                   {  
808:                       //Re-detect & Initialize
809:                       USBOTGInitialize();
810:           
811:                       USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
812:                   }
813:               #endif
814:           
815:               /*
816:                * Task A: Service USB Activity Interrupt
817:                */
818:               if(USBActivityIF && USBActivityIE)
0156  003D     MOVLB 0x1D
0157  1910     BTFSC 0x10, 0x2
0158  1D12     BTFSS PIR2, 0x2
0159  295D     GOTO 0x15D
819:               {
820:                   USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
015A  1110     BCF 0x10, 0x2
821:                   #if defined(USB_SUPPORT_OTG)
822:                       U1OTGIR = 0x10;        
823:                   #else
824:                       USBWakeFromSuspend();
015B  233B     CALL 0x33B
015C  3180     MOVLP 0x0
825:                   #endif
826:               }
827:           
828:               /*
829:                * Pointless to continue servicing if the device is in suspend mode.
830:                */
831:               if(USBSuspendControl==1)
015D  1C8E     BTFSS PORTC, 0x1
015E  2962     GOTO 0x162
832:               {
833:                   USBClearUSBInterrupt();
015F  0020     MOVLB 0x0
0160  1112     BCF PIR2, 0x2
834:                   return;
0161  0008     RETURN
835:               }
836:           
837:               /*
838:                * Task B: Service USB Bus Reset Interrupt.
839:                * When bus reset is received during suspend, ACTVIF will be set first,
840:                * once the UCONbits.SUSPND is clear, then the URSTIF bit will be asserted.
841:                * This is why URSTIF is checked after ACTVIF.
842:                *
843:                * The USB reset flag is masked when the USB state is in
844:                * DETACHED_STATE or ATTACHED_STATE, and therefore cannot
845:                * cause a USB reset event during these two states.
846:                */
847:               if(USBResetIF && USBResetIE)
0162  1810     BTFSC 0x10, 0x0
0163  1C12     BTFSS PIR2, 0x0
0164  296E     GOTO 0x16E
848:               {
849:                   USBDeviceInit();
0165  2215     CALL 0x215
0166  3180     MOVLP 0x0
850:           
851:                   //Re-enable the interrupts since the USBDeviceInit() function will
852:                   //  disable them.  This will do nothing in a polling setup
853:                   USBUnmaskInterrupts();
0167  0021     MOVLB 0x1
0168  1512     BSF PIR2, 0x2
854:           
855:                   USBDeviceState = DEFAULT_STATE;
0169  3004     MOVLW 0x4
016A  0022     MOVLB 0x2
016B  00CD     MOVWF 0x4D
856:           
857:                   #ifdef USB_SUPPORT_OTG
858:                        //Disable HNP
859:                        USBOTGDisableHnp();
860:           
861:                        //Deactivate HNP
862:                        USBOTGDeactivateHnp();
863:                   #endif
864:           
865:                   USBClearInterruptFlag(USBResetIFReg,USBResetIFBitNum);
016C  003D     MOVLB 0x1D
016D  1010     BCF 0x10, 0x0
866:               }
867:           
868:               /*
869:                * Task C: Service other USB interrupts
870:                */
871:               if(USBIdleIF && USBIdleIE)
016E  1A10     BTFSC 0x10, 0x4
016F  1E12     BTFSS PIR2, 0x4
0170  2975     GOTO 0x175
872:               { 
873:                   #ifdef  USB_SUPPORT_OTG 
874:                       //If Suspended, Try to switch to Host
875:                       USBOTGSelectRole(ROLE_HOST);
876:                   #else
877:                       USBSuspend();
0171  232F     CALL 0x32F
0172  3180     MOVLP 0x0
878:                   #endif
879:                   
880:                   USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
0173  003D     MOVLB 0x1D
0174  1210     BCF 0x10, 0x4
881:               }
882:           
883:               if(USBSOFIF)
0175  1F10     BTFSS 0x10, 0x6
0176  298F     GOTO 0x18F
884:               {
885:                   if(USBSOFIE)
0177  1F12     BTFSS PIR2, 0x6
0178  2984     GOTO 0x184
886:                   {
887:                       USB_SOF_HANDLER(EVENT_SOF,0,1);
0179  3073     MOVLW 0x73
017A  0020     MOVLB 0x0
017B  00E0     MOVWF event
017C  01E1     CLRF 0x61
017D  01E2     CLRF 0x62
017E  01E3     CLRF 0x63
017F  01E4     CLRF 0x64
0180  0AE4     INCF 0x64, F
0181  01E5     CLRF 0x65
0182  21E5     CALL 0x1E5
0183  3180     MOVLP 0x0
888:                   }    
889:                   USBClearInterruptFlag(USBSOFIFReg,USBSOFIFBitNum);
0184  003D     MOVLB 0x1D
0185  1310     BCF 0x10, 0x6
890:                   
891:                   #if defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)
892:                       //Supporting this feature requires a 1ms timebase for keeping track of the timeout interval.
893:                       #if(USB_SPEED_OPTION == USB_LOW_SPEED)
894:                           #warning "Double click this message.  See inline code comments."
895:                           //The "USB_ENABLE_STATUS_STAGE_TIMEOUTS" feature is optional and is
896:                           //not strictly needed in all applications (ex: those that never call 
897:                           //USBDeferStatusStage() and don't use host to device (OUT) control
898:                           //transfers with data stage).  
899:                           //However, if this feature is enabled and used, it requires a timer 
900:                           //(preferrably 1ms) to decrement the USBStatusStageTimeoutCounter.  
901:                           //In USB Full Speed applications, the host sends Start-of-Frame (SOF) 
902:                           //packets at a 1ms rate, which generates SOFIF interrupts.
903:                           //These interrupts can be used to decrement USBStatusStageTimeoutCounter as shown 
904:                           //below.  However, the host does not send SOF packets to Low Speed devices.  
905:                           //Therefore, some other method  (ex: using a general purpose microcontroller 
906:                           //timer, such as Timer0) needs to be implemented to call and execute the below code
907:                           //at a once/1ms rate, in a low speed USB application.
908:                           //Note: Pre-condition to executing the below code: USBDeviceInit() should have
909:                           //been called at least once (since the last microcontroller reset/power up), 
910:                           //prior to executing the below code.
911:                       #endif
912:                       
913:                       //Decrement our status stage counter.
914:                       if(USBStatusStageTimeoutCounter != 0u)
0186  0022     MOVLB 0x2
0187  0850     MOVF SetupPkt, W
0188  1D03     BTFSS STATUS, 0x2
915:                       {
916:                           USBStatusStageTimeoutCounter--;
0189  03D0     DECF SetupPkt, F
917:                       }
918:                       //Check if too much time has elapsed since progress was made in 
919:                       //processing the control transfer, without arming the status stage.  
920:                       //If so, auto-arm the status stage to ensure that the control 
921:                       //transfer can [eventually] complete, within the timing limits
922:                       //dictated by section 9.2.6 of the official USB 2.0 specifications.
923:                       if(USBStatusStageTimeoutCounter == 0)
018A  08D0     MOVF SetupPkt, F
018B  1D03     BTFSS STATUS, 0x2
018C  298F     GOTO 0x18F
924:                       {
925:                           USBCtrlEPAllowStatusStage();    //Does nothing if the status stage was already armed.
018D  2287     CALL 0x287
018E  3180     MOVLP 0x0
926:                       } 
927:                   #endif
928:               }
929:           
930:               if(USBStallIF && USBStallIE)
018F  003D     MOVLB 0x1D
0190  1A90     BTFSC 0x10, 0x5
0191  1E92     BTFSS PIR2, 0x5
0192  2995     GOTO 0x195
931:               {
932:                   USBStallHandler();
0193  2317     CALL 0x317
0194  3180     MOVLP 0x0
933:               }
934:           
935:               if(USBErrorIF && USBErrorIE)
0195  1890     BTFSC 0x10, 0x1
0196  1C92     BTFSS PIR2, 0x1
0197  29A6     GOTO 0x1A6
936:               {
937:                   USB_ERROR_HANDLER(EVENT_BUS_ERROR,0,1);
0198  30FF     MOVLW 0xFF
0199  0020     MOVLB 0x0
019A  00E0     MOVWF event
019B  307F     MOVLW 0x7F
019C  00E1     MOVWF 0x61
019D  01E2     CLRF 0x62
019E  01E3     CLRF 0x63
019F  01E4     CLRF 0x64
01A0  0AE4     INCF 0x64, F
01A1  01E5     CLRF 0x65
01A2  21E5     CALL 0x1E5
01A3  3180     MOVLP 0x0
938:                   USBClearInterruptRegister(U1EIR);               // This clears UERRIF
01A4  003D     MOVLB 0x1D
01A5  0193     CLRF 0x13
939:           
940:                   //On PIC18, clearing the source of the error will automatically clear
941:                   //  the interrupt flag.  On other devices the interrupt flag must be 
942:                   //  manually cleared. 
943:                   #if defined(__C32__) || defined(__C30__) || defined __XC16__
944:                       USBClearInterruptFlag( USBErrorIFReg, USBErrorIFBitNum );
945:                   #endif
946:               }
947:           
948:               /*
949:                * Pointless to continue servicing if the host has not sent a bus reset.
950:                * Once bus reset is received, the device transitions into the DEFAULT
951:                * state and is ready for communication.
952:                */
953:               if(USBDeviceState < DEFAULT_STATE)
01A6  3004     MOVLW 0x4
01A7  0022     MOVLB 0x2
01A8  024D     SUBWF 0x4D, W
01A9  1C03     BTFSS STATUS, 0x0
01AA  295F     GOTO 0x15F
954:               {
955:           	    USBClearUSBInterrupt();
956:           	    return; 
957:           	}  
958:           
959:               /*
960:                * Task D: Servicing USB Transaction Complete Interrupt
961:                */
962:               if(USBTransactionCompleteIE)
01AB  003D     MOVLB 0x1D
01AC  1D92     BTFSS PIR2, 0x3
01AD  295F     GOTO 0x15F
963:               {
964:           	    for(i = 0; i < 4u; i++)	//Drain or deplete the USAT FIFO entries.  If the USB FIFO ever gets full, USB bandwidth 
01AE  0020     MOVLB 0x0
01AF  01EE     CLRF i
01DE  0020     MOVLB 0x0
01DF  3004     MOVLW 0x4
01E0  0AEE     INCF i, F
01E1  026E     SUBWF i, W
01E2  1803     BTFSC STATUS, 0x0
01E3  295F     GOTO 0x15F
01E4  29B0     GOTO 0x1B0
965:           		{						//utilization can be compromised, and the device won't be able to receive SETUP packets.
966:           		    if(USBTransactionCompleteIF)
01B0  003D     MOVLB 0x1D
01B1  1D90     BTFSS 0x10, 0x3
01B2  295F     GOTO 0x15F
967:           		    {
968:               		    //Save and extract USTAT register info.  Will use this info later.
969:                           USTATcopy.Val = U1STAT;
01B3  080F     MOVF 0xF, W
01B4  0022     MOVLB 0x2
01B5  00E4     MOVWF 0x64
970:                           endpoint_number = USBHALGetLastEndpoint(USTATcopy);
01B6  0C64     RRF 0x64, W
01B7  0020     MOVLB 0x0
01B8  00ED     MOVWF 0x6D
01B9  0CED     RRF 0x6D, F
01BA  0C6D     RRF 0x6D, W
01BB  390F     ANDLW 0xF
01BC  0022     MOVLB 0x2
01BD  00D7     MOVWF 0x57
971:                           
972:                           USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
01BE  003D     MOVLB 0x1D
01BF  1190     BCF 0x10, 0x3
973:                           
974:                           //Keep track of the hardware ping pong state for endpoints other
975:                           //than EP0, if ping pong buffering is enabled.
976:                           #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) 
977:                               if(USBHALGetLastDirection(USTATcopy) == OUT_FROM_HOST)
01C0  0022     MOVLB 0x2
01C1  1964     BTFSC 0x64, 0x2
01C2  29C6     GOTO 0x1C6
978:                               {
979:                                   ep_data_out[endpoint_number].bits.ping_pong_state ^= 1;
01C3  0857     MOVF 0x57, W
01C4  3E3A     ADDLW 0x3A
01C5  29C8     GOTO 0x1C8
980:                               }   
981:                               else
982:                               {
983:                                   ep_data_in[endpoint_number].bits.ping_pong_state ^= 1;
01C6  0857     MOVF 0x57, W
01C7  3E37     ADDLW 0x37
01C8  0086     MOVWF FSR1L
01C9  3001     MOVLW 0x1
01CA  0087     MOVWF FSR1H
01CB  0681     XORWF INDF1, F
984:                               }         
985:                           #endif    
986:                           
987:                           //USBCtrlEPService only services transactions over EP0.
988:                           //It ignores all other EP transactions.
989:                           if(endpoint_number == 0)
01CC  08D7     MOVF 0x57, F
01CD  1D03     BTFSS STATUS, 0x2
01CE  29D2     GOTO 0x1D2
990:                           {
991:                               USBCtrlEPService();
01CF  22BF     CALL 0x2BF
01D0  3180     MOVLP 0x0
992:                           }
01D1  29DE     GOTO 0x1DE
993:                           else
994:                           {
995:                               USB_TRANSFER_COMPLETE_HANDLER(EVENT_TRANSFER, (BYTE*)&USTATcopy.Val, 0);
01D2  3072     MOVLW 0x72
01D3  0020     MOVLB 0x0
01D4  00E0     MOVWF event
01D5  3064     MOVLW 0x64
01D6  01E1     CLRF 0x61
01D7  00E2     MOVWF 0x62
01D8  3001     MOVLW 0x1
01D9  00E3     MOVWF 0x63
01DA  01E4     CLRF 0x64
01DB  01E5     CLRF 0x65
01DC  21E5     CALL 0x1E5
01DD  3180     MOVLP 0x0
996:                           }
997:           		    }//end if(USBTransactionCompleteIF)
998:           		    else
999:           		    	break;	//USTAT FIFO must be empty.
1000:          		}//end for()
1001:          	}//end if(USBTransactionCompleteIE)   
1002:          
1003:              USBClearUSBInterrupt();
1004:          }//end of USBDeviceTasks()
01E5  0861     MOVF 0x61, W
1005:          
1006:          /*******************************************************************************
1007:            Function:
1008:                  void USBEnableEndpoint(BYTE ep, BYTE options)
1009:              
1010:            Summary:
1011:              This function will enable the specified endpoint with the specified
1012:              options
1013:            Description:
1014:              This function will enable the specified endpoint with the specified
1015:              options.
1016:              
1017:              Typical Usage:
1018:              <code>
1019:              void USBCBInitEP(void)
1020:              {
1021:                  USBEnableEndpoint(MSD_DATA_IN_EP,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
1022:                  USBMSDInit();
1023:              }
1024:              </code>
1025:              
1026:              In the above example endpoint number MSD_DATA_IN_EP is being configured
1027:              for both IN and OUT traffic with handshaking enabled. Also since
1028:              MSD_DATA_IN_EP is not endpoint 0 (MSD does not allow this), then we can
1029:              explicitly disable SETUP packets on this endpoint.
1030:            Conditions:
1031:              None
1032:            Input:
1033:              BYTE ep -       the endpoint to be configured
1034:              BYTE options -  optional settings for the endpoint. The options should
1035:                              be ORed together to form a single options string. The
1036:                              available optional settings for the endpoint. The
1037:                              options should be ORed together to form a single options
1038:                              string. The available options are the following\:
1039:                              * USB_HANDSHAKE_ENABLED enables USB handshaking (ACK,
1040:                                NAK)
1041:                              * USB_HANDSHAKE_DISABLED disables USB handshaking (ACK,
1042:                                NAK)
1043:                              * USB_OUT_ENABLED enables the out direction
1044:                              * USB_OUT_DISABLED disables the out direction
1045:                              * USB_IN_ENABLED enables the in direction
1046:                              * USB_IN_DISABLED disables the in direction
1047:                              * USB_ALLOW_SETUP enables control transfers
1048:                              * USB_DISALLOW_SETUP disables control transfers
1049:                              * USB_STALL_ENDPOINT STALLs this endpoint
1050:            Return:
1051:              None
1052:            Remarks:
1053:              None                                                                                                          
1054:            *****************************************************************************/
1055:          void USBEnableEndpoint(BYTE ep, BYTE options)
1056:          {
1057:              unsigned char* p;
1058:                  
1059:              //Use USBConfigureEndpoint() to set up the pBDTEntryIn/Out[ep] pointer and 
1060:              //starting DTS state in the BDT entry.
1061:              if(options & USB_OUT_ENABLED)
036A  00F9     MOVWF 0x79
036B  1D74     BTFSS i_750, 0x2
036C  2B70     GOTO 0x370
1062:              {
1063:                  USBConfigureEndpoint(ep, OUT_FROM_HOST);
036D  01F0     CLRF dir
036E  2389     CALL 0x389
036F  3180     MOVLP 0x0
1064:              }
1065:              if(options & USB_IN_ENABLED)
0370  1CF4     BTFSS i_750, 0x1
0371  2B76     GOTO 0x376
1066:              {
1067:                  USBConfigureEndpoint(ep, IN_TO_HOST);
0372  01F0     CLRF dir
0373  0AF0     INCF dir, F
0374  0879     MOVF 0x79, W
0375  2389     CALL 0x389
1068:              }
1069:          
1070:              //Update the relevant UEPx register to actually enable the endpoint with
1071:              //the specified options (ex: handshaking enabled, control transfers allowed,
1072:              //etc.)
1073:              #if defined(__C32__)
1074:                  p = (unsigned char*)(&U1EP0+(4*ep));
1075:              #else
1076:                  p = (unsigned char*)(&U1EP0+ep);
0376  0879     MOVF 0x79, W
0377  3E98     ADDLW 0x98
0378  00F5     MOVWF i
0379  300E     MOVLW 0xE
037A  01F6     CLRF handle
037B  3DF6     ADDWFC handle, F
037C  0875     MOVF i, W
037D  00F7     MOVWF p
037E  0876     MOVF handle, W
037F  00F8     MOVWF 0x78
1077:              #endif
1078:              *p = options;
0380  0874     MOVF i_750, W
0381  00F5     MOVWF i
0382  0877     MOVF p, W
0383  0086     MOVWF FSR1L
0384  0878     MOVF 0x78, W
0385  0087     MOVWF FSR1H
0386  0875     MOVF i, W
0387  0081     MOVWF INDF1
1079:          }
0388  0008     RETURN
1080:          
1081:          
1082:          /*************************************************************************
1083:            Function:
1084:              USB_HANDLE USBTransferOnePacket(BYTE ep, BYTE dir, BYTE* data, BYTE len)
1085:              
1086:            Summary:
1087:              Transfers a single packet (one transaction) of data on the USB bus.
1088:          
1089:            Description:
1090:              The USBTransferOnePacket() function prepares a USB endpoint
1091:              so that it may send data to the host (an IN transaction), or 
1092:              receive data from the host (an OUT transaction).  The 
1093:              USBTransferOnePacket() function can be used both to receive	and 
1094:              send data to the host.  This function is the primary API function 
1095:              provided by the USB stack firmware for sending or receiving application 
1096:              data over the USB port.  
1097:          
1098:              The USBTransferOnePacket() is intended for use with all application 
1099:              endpoints.  It is not used for sending or receiving applicaiton data 
1100:              through endpoint 0 by using control transfers.  Separate API 
1101:              functions, such as USBEP0Receive(), USBEP0SendRAMPtr(), and
1102:              USBEP0SendROMPtr() are provided for this purpose.
1103:          
1104:              The	USBTransferOnePacket() writes to the Buffer Descriptor Table (BDT)
1105:              entry associated with an endpoint buffer, and sets the UOWN bit, which 
1106:              prepares the USB hardware to allow the transaction to complete.  The 
1107:              application firmware can use the USBHandleBusy() macro to check the 
1108:              status of the transaction, to see if the data has been successfully 
1109:              transmitted yet.
1110:          
1111:          
1112:              Typical Usage
1113:              <code>
1114:              //make sure that the we are in the configured state
1115:              if(USBGetDeviceState() == CONFIGURED_STATE)
1116:              {
1117:                  //make sure that the last transaction isn't busy by checking the handle
1118:                  if(!USBHandleBusy(USBInHandle))
1119:                  {
1120:          	        //Write the new data that we wish to send to the host to the INPacket[] array
1121:          	        INPacket[0] = USEFUL_APPLICATION_VALUE1;
1122:          	        INPacket[1] = USEFUL_APPLICATION_VALUE2;
1123:          	        //INPacket[2] = ... (fill in the rest of the packet data)
1124:          	      
1125:                      //Send the data contained in the INPacket[] array through endpoint "EP_NUM"
1126:                      USBInHandle = USBTransferOnePacket(EP_NUM,IN_TO_HOST,(BYTE*)&INPacket[0],sizeof(INPacket));
1127:                  }
1128:              }
1129:              </code>
1130:          
1131:            Conditions:
1132:              Before calling USBTransferOnePacket(), the following should be true.
1133:              1.  The USB stack has already been initialized (USBDeviceInit() was called).
1134:              2.  A transaction is not already pending on the specified endpoint.  This
1135:                  is done by checking the previous request using the USBHandleBusy() 
1136:                  macro (see the typical usage example).
1137:              3.  The host has already sent a set configuration request and the 
1138:                  enumeration process is complete.
1139:                  This can be checked by verifying that the USBGetDeviceState() 
1140:                  macro returns "CONFIGURED_STATE", prior to calling 
1141:                  USBTransferOnePacket().
1142:           					
1143:            Input:
1144:              BYTE ep - The endpoint number that the data will be transmitted or 
1145:          	          received on
1146:              BYTE dir - The direction of the transfer
1147:                         This value is either OUT_FROM_HOST or IN_TO_HOST
1148:              BYTE* data - For IN transactions: pointer to the RAM buffer containing 
1149:                           the data to be sent to the host.  For OUT transactions: pointer
1150:                           to the RAM buffer that the received data should get written to.
1151:             BYTE len - Length of the data needing to be sent (for IN transactions).
1152:                        For OUT transactions, the len parameter should normally be set
1153:                        to the endpoint size specified in the endpoint descriptor.    
1154:          
1155:            Return Values:
1156:              USB_HANDLE - handle to the transfer.  The handle is a pointer to 
1157:                           the BDT entry associated with this transaction.  The
1158:                           status of the transaction (ex: if it is complete or still
1159:                           pending) can be checked using the USBHandleBusy() macro
1160:                           and supplying the USB_HANDLE provided by
1161:                           USBTransferOnePacket().
1162:          
1163:            Remarks:
1164:              If calling the USBTransferOnePacket() function from within the USBCBInitEP()
1165:              callback function, the set configuration is still being processed and the
1166:              USBDeviceState may not be == CONFIGURED_STATE yet.  In this	special case, 
1167:              the USBTransferOnePacket() may still be called, but make sure that the 
1168:              endpoint has been enabled and initialized by the USBEnableEndpoint() 
1169:              function first.  
1170:              
1171:            *************************************************************************/
1172:          USB_HANDLE USBTransferOnePacket(BYTE ep,BYTE dir,BYTE* data,BYTE len)
1173:          {
1174:              volatile BDT_ENTRY* handle;
1175:          
1176:              //If the direction is IN
1177:              if(dir != 0)
03B0  00F5     MOVWF i
03B1  0870     MOVF dir, W
03B2  1903     BTFSC STATUS, 0x2
03B3  2BB7     GOTO 0x3B7
0616  00A5     MOVWF 0x25
0617  0820     MOVF BDT, W
0618  1903     BTFSC STATUS, 0x2
0619  2E1D     GOTO 0x61D
1178:              {
1179:                  //point to the IN BDT of the specified endpoint
1180:                  handle = pBDTEntryIn[ep];
03B4  0875     MOVF i, W
03B5  3E3D     ADDLW 0x3D
03B6  2BB9     GOTO 0x3B9
061A  0825     MOVF 0x25, W
061B  3E3D     ADDLW 0x3D
061C  2E1F     GOTO 0x61F
1181:              }
1182:              else
1183:              {
1184:                  //else point to the OUT BDT of the specified endpoint
1185:                  handle = pBDTEntryOut[ep];
03B7  0875     MOVF i, W
03B8  3E40     ADDLW 0x40
03B9  0086     MOVWF FSR1L
03BA  3001     MOVLW 0x1
03BB  0087     MOVWF FSR1H
03BC  0801     MOVF INDF1, W
03BD  00F6     MOVWF handle
061D  0825     MOVF 0x25, W
061E  3E40     ADDLW 0x40
061F  0086     MOVWF FSR1L
0620  3001     MOVLW 0x1
0621  0087     MOVWF FSR1H
0622  0801     MOVF INDF1, W
0623  00A6     MOVWF 0x26
1186:              }
1187:              
1188:              //Error checking code.  Make sure the handle (pBDTEntryIn[ep] or
1189:              //pBDTEntryOut[ep]) is initialized before using it.
1190:              if(handle == 0)
03BE  08F6     MOVF handle, F
03BF  1903     BTFSC STATUS, 0x2
0624  08A6     MOVF 0x26, F
0625  1903     BTFSC STATUS, 0x2
1191:              {
1192:          	    return 0;
03C0  3400     RETLW 0x0
0626  3400     RETLW 0x0
1193:          	}
1194:          
1195:              //Toggle the DTS bit if required
1196:              #if (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
1197:                  handle->STAT.Val ^= _DTSMASK;
1198:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
1199:                  if(ep != 0)
1200:                  {
1201:                      handle->STAT.Val ^= _DTSMASK;
1202:                  }
1203:              #endif
1204:          
1205:              //Set the data pointer, data length, and enable the endpoint
1206:              handle->ADR = ConvertToPhysicalAddress(data);
03C1  0871     MOVF data, W
03C2  00F3     MOVWF handle
03C3  3002     MOVLW 0x2
03C4  00F4     MOVWF i_750
03C5  0876     MOVF handle, W
03C6  3E02     ADDLW 0x2
03C7  0086     MOVWF FSR1L
03C8  0187     CLRF FSR1H
03C9  0873     MOVF handle, W
03CA  3FC0     MOVWI [0]FSR1
03CB  0874     MOVF i_750, W
03CC  3FC1     MOVWI [1]FSR1
0627  0821     MOVF 0x21, W
0628  00A3     MOVWF 0x23
0629  3002     MOVLW 0x2
062A  00A4     MOVWF 0x24
062B  0826     MOVF 0x26, W
062C  3E02     ADDLW 0x2
062D  0086     MOVWF FSR1L
062E  0187     CLRF FSR1H
062F  0823     MOVF 0x23, W
0630  3FC0     MOVWI [0]FSR1
0631  0824     MOVF 0x24, W
0632  3FC1     MOVWI [1]FSR1
1207:              handle->CNT = len;
03CD  0A76     INCF handle, W
03CE  0086     MOVWF FSR1L
03CF  0872     MOVF p, W
03D0  0081     MOVWF INDF1
0633  0A26     INCF 0x26, W
0634  0086     MOVWF FSR1L
0635  0822     MOVF 0x22, W
0636  0081     MOVWF INDF1
1208:              handle->STAT.Val &= _DTSMASK;
03D1  0876     MOVF handle, W
03D2  0086     MOVWF FSR1L
03D3  3040     MOVLW 0x40
03D4  0581     ANDWF INDF1, F
0637  0826     MOVF 0x26, W
0638  0086     MOVWF FSR1L
0639  3040     MOVLW 0x40
063A  0581     ANDWF INDF1, F
1209:              handle->STAT.Val |= _USIE | (_DTSEN & _DTS_CHECKING_ENABLED);
03D5  0876     MOVF handle, W
03D6  0086     MOVWF FSR1L
03D7  3088     MOVLW 0x88
03D8  0481     IORWF INDF1, F
063B  0826     MOVF 0x26, W
063C  0086     MOVWF FSR1L
063D  3088     MOVLW 0x88
063E  0481     IORWF INDF1, F
1210:          
1211:              //Point to the next buffer for ping pong purposes.
1212:              if(dir != OUT_FROM_HOST)
03D9  0870     MOVF dir, W
03DA  1903     BTFSC STATUS, 0x2
03DB  2BDF     GOTO 0x3DF
063F  0820     MOVF BDT, W
0640  1903     BTFSC STATUS, 0x2
0641  2E45     GOTO 0x645
1213:              {
1214:                  //toggle over the to the next buffer for an IN endpoint
1215:                  USBAdvancePingPongBuffer(&pBDTEntryIn[ep]);      
03DC  0875     MOVF i, W
03DD  3E3D     ADDLW 0x3D
03DE  2BE1     GOTO 0x3E1
0642  0825     MOVF 0x25, W
0643  3E3D     ADDLW 0x3D
0644  2E47     GOTO 0x647
1216:              }
1217:              else
1218:              {
1219:                  //toggle over the to the next buffer for an OUT endpoint
1220:                  USBAdvancePingPongBuffer(&pBDTEntryOut[ep]);     
03DF  0875     MOVF i, W
03E0  3E40     ADDLW 0x40
03E1  0086     MOVWF FSR1L
03E2  3001     MOVLW 0x1
03E3  0087     MOVWF FSR1H
03E4  3004     MOVLW 0x4
03E5  0681     XORWF INDF1, F
0645  0825     MOVF 0x25, W
0646  3E40     ADDLW 0x40
0647  0086     MOVWF FSR1L
0648  3001     MOVLW 0x1
0649  0087     MOVWF FSR1H
064A  3004     MOVLW 0x4
064B  0681     XORWF INDF1, F
1221:              }
1222:              return (USB_HANDLE)handle;
03E6  0876     MOVF handle, W
064C  0826     MOVF 0x26, W
1223:          }
03E7  0008     RETURN
064D  0008     RETURN
1224:          
1225:          
1226:          /********************************************************************
1227:              Function:
1228:                  void USBStallEndpoint(BYTE ep, BYTE dir)
1229:                  
1230:              Summary:
1231:                   Configures the specified endpoint to send STALL to the host, the next
1232:                   time the host tries to access the endpoint.
1233:              
1234:              PreCondition:
1235:                  None
1236:                  
1237:              Parameters:
1238:                  BYTE ep - The endpoint number that should be configured to send STALL.
1239:                  BYTE dir - The direction of the endpoint to STALL, either 
1240:                             IN_TO_HOST or OUT_FROM_HOST.
1241:                  
1242:              Return Values:
1243:                  None
1244:                  
1245:              Remarks:
1246:                  None
1247:          
1248:           *******************************************************************/
1249:          void USBStallEndpoint(BYTE ep, BYTE dir)
1250:          {
1251:              BDT_ENTRY *p;
1252:          
1253:              if(ep == 0)
1254:              {
1255:                  //For control endpoints (ex: EP0), we need to STALL both IN and OUT
1256:                  //endpoints.  EP0 OUT must also be prepared to receive the next SETUP 
1257:                  //packet that will arrrive.
1258:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
1259:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
1260:                  pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
1261:                  pBDTEntryIn[0]->STAT.Val = _USIE|_BSTALL; 
1262:                         
1263:              }
1264:              else
1265:              {
1266:                  p = (BDT_ENTRY*)(&BDT[EP(ep,dir,0)]);
1267:                  p->STAT.Val |= _BSTALL | _USIE;
1268:              
1269:                  //If the device is in FULL or ALL_BUT_EP0 ping pong modes
1270:                  //then stall that entry as well
1271:                  #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
1272:              
1273:                  p = (BDT_ENTRY*)(&BDT[EP(ep,dir,1)]);
1274:                  p->STAT.Val |= _BSTALL | _USIE;
1275:                  #endif
1276:              }
1277:          }
1278:          
1279:          /**************************************************************************
1280:              Function:
1281:                  void USBCancelIO(BYTE endpoint)
1282:              
1283:              Description:
1284:                  This function cancels the transfers pending on the specified endpoint.
1285:                  This function can only be used after a SETUP packet is received and 
1286:                  before that setup packet is handled.  This is the time period in which
1287:                  the EVENT_EP0_REQUEST is thrown, before the event handler function
1288:                  returns to the stack.
1289:          
1290:              Precondition:
1291:            
1292:              Parameters:
1293:                  BYTE endpoint - the endpoint number you wish to cancel the transfers for
1294:               
1295:              Return Values:
1296:                  None
1297:                  
1298:              Remarks:
1299:                  None
1300:                                                                    
1301:            **************************************************************************/
1302:          void USBCancelIO(BYTE endpoint)
1303:          {
1304:              if(USBPacketDisable == 1)
1305:              {
1306:              	//The PKTDIS bit is currently set right now.  It is therefore "safe"
1307:              	//to mess with the BDT right now.
1308:              	pBDTEntryIn[endpoint]->Val &= _DTSMASK;	//Makes UOWN = 0 (_UCPU mode).  Deactivates endpoint.  Only sends NAKs.
1309:              	pBDTEntryIn[endpoint]->Val ^= _DTSMASK;	//Toggle the DTS bit.  This packet didn't get sent yet, and the next call to USBTransferOnePacket() will re-toggle the DTS bit back to the original (correct) value.
1310:              	
1311:              	//Need to do additional handling if ping-pong buffering is being used
1312:                  #if ((USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0))
1313:                  //Point to the next buffer for ping pong purposes.  UOWN getting cleared
1314:                  //(either due to SIE clearing it after a transaction, or the firmware
1315:                  //clearing it) makes hardware ping pong pointer advance.
1316:                  USBAdvancePingPongBuffer(&pBDTEntryIn[endpoint]);       
1317:              
1318:              	pBDTEntryIn[endpoint]->STAT.Val &= _DTSMASK;
1319:              	pBDTEntryIn[endpoint]->STAT.Val ^= _DTSMASK;
1320:                  #endif
1321:              }
1322:          }
1323:          
1324:          /**************************************************************************
1325:              Function:
1326:                  void USBDeviceDetach(void)
1327:             
1328:              Summary:
1329:                  This function configures the USB module to "soft detach" itself from
1330:                  the USB host.
1331:                  
1332:              Description:
1333:                  This function configures the USB module to perform a "soft detach"
1334:                  operation, by disabling the D+ (or D-) ~1.5k pull up resistor, which
1335:                  lets the host know the device is present and attached.  This will make
1336:                  the host think that the device has been unplugged.  This is potentially
1337:                  useful, as it allows the USB device to force the host to re-enumerate
1338:                  the device (on the firmware has re-enabled the USB module/pull up, by
1339:                  calling USBDeviceAttach(), to "soft re-attach" to the host).
1340:                  
1341:              Precondition:
1342:                  Should only be called when USB_INTERRUPT is defined.  See remarks
1343:                  section if USB_POLLING mode option is being used (usb_config.h option).
1344:          
1345:                  Additionally, this function should only be called from the main() loop 
1346:                  context.  Do not call this function from within an interrupt handler, as 
1347:                  this function may modify global interrupt enable bits and settings.
1348:                  
1349:              Parameters:
1350:                  None
1351:               
1352:              Return Values:
1353:                  None
1354:                  
1355:              Remarks:
1356:                  If the application firmware calls USBDeviceDetach(), it is strongly
1357:                  recommended that the firmware wait at least >= 80ms before calling
1358:                  USBDeviceAttach().  If the firmeware performs a soft detach, and then
1359:                  re-attaches too soon (ex: after a few micro seconds for instance), some
1360:                  hosts may interpret this as an unexpected "glitch" rather than as a
1361:                  physical removal/re-attachment of the USB device.  In this case the host
1362:                  may simply ignore the event without re-enumerating the device.  To 
1363:                  ensure that the host properly detects and processes the device soft
1364:                  detach/re-attach, it is recommended to make sure the device remains 
1365:                  detached long enough to mimic a real human controlled USB 
1366:                  unplug/re-attach event (ex: after calling USBDeviceDetach(), do not
1367:                  call USBDeviceAttach() for at least 80+ms, preferrably longer.
1368:                  
1369:                  Neither the USBDeviceDetach() or USBDeviceAttach() functions are blocking
1370:                  or take long to execute.  It is the application firmware's 
1371:                  responsibility for adding the 80+ms delay, when using these API 
1372:                  functions.
1373:                  
1374:                  Note: The Windows plug and play event handler processing is fairly 
1375:                  slow, especially in certain versions of Windows, and for certain USB
1376:                  device classes.  It has been observed that some device classes need to
1377:                  provide even more USB detach dwell interval (before calling 
1378:                  USBDeviceAttach()), in order to work correctly after re-enumeration.
1379:                  If the USB device is a CDC class device, it is recommended to wait
1380:                  at least 1.5 seconds or longer, before soft re-attaching to the host,
1381:                  to provide the plug and play event handler enough time to finish 
1382:                  processing the removal event, before the re-attach occurs.
1383:                  
1384:                  If the application is using the USB_POLLING mode option, then the 
1385:                  USBDeviceDetach() and USBDeviceAttach() functions are not available.  
1386:                  In this mode, the USB stack relies on the "#define USE_USB_BUS_SENSE_IO" 
1387:                  and "#define USB_BUS_SENSE" options in the 
1388:                  HardwareProfile  [platform name].h file. 
1389:          
1390:                  When using the USB_POLLING mode option, and the 
1391:                  "#define USE_USB_BUS_SENSE_IO" definition has been commented out, then 
1392:                  the USB stack assumes that it should always enable the USB module at 
1393:                  pretty much all times.  Basically, anytime the application firmware 
1394:                  calls USBDeviceTasks(), the firmware will automatically enable the USB 
1395:                  module.  This mode would typically be selected if the application was 
1396:                  designed to be a purely bus powered device.  In this case, the 
1397:                  application is powered from the +5V VBUS supply from the USB port, so 
1398:                  it is correct and sensible in this type of application to power up and 
1399:                  turn on the USB module, at anytime that the microcontroller is 
1400:                  powered (which implies the USB cable is attached and the host is also 
1401:                  powered).
1402:          
1403:                  In a self powered application, the USB stack is designed with the 
1404:                  intention that the user will enable the "#define USE_USB_BUS_SENSE_IO" 
1405:                  option in the HardwareProfile  [platform name].h file.  When this 
1406:                  option is defined, then the USBDeviceTasks() function will automatically 
1407:                  check the I/O pin port value of the designated pin (based on the 
1408:                  #define USB_BUS_SENSE option in the HardwareProfile  [platform name].h 
1409:                  file), every time the application calls USBDeviceTasks().  If the 
1410:                  USBDeviceTasks() function is executed and finds that the pin defined by 
1411:                  the #define USB_BUS_SENSE is in a logic low state, then it will 
1412:                  automatically disable the USB module and tri-state the D+ and D- pins.  
1413:                  If however the USBDeviceTasks() function is executed and finds the pin 
1414:                  defined by the #define USB_BUS_SENSE is in a logic high state, then it 
1415:                  will automatically enable the USB module, if it has not already been 
1416:                  enabled.        
1417:                                                                    
1418:            **************************************************************************/
1419:          #if defined(USB_INTERRUPT)
1420:          void USBDeviceDetach(void)
1421:          {
1422:              //If the interrupt option is selected then the customer is required
1423:              //  to notify the stack when the device is attached or removed from the
1424:              //  bus by calling the USBDeviceAttach() and USBDeviceDetach() functions.
1425:          #ifdef USB_SUPPORT_OTG
1426:              if (USB_BUS_SENSE != 1)
1427:          #endif
1428:              {
1429:                   // Disable module & detach from bus
1430:                   U1CON = 0;             
1431:          
1432:                   // Mask all USB interrupts              
1433:                   U1IE = 0;          
1434:          
1435:                   //Move to the detached state                  
1436:                   USBDeviceState = DETACHED_STATE;
1437:          
1438:                   #ifdef  USB_SUPPORT_OTG    
1439:                       //Disable D+ Pullup
1440:                       U1OTGCONbits.DPPULUP = 0;
1441:          
1442:                       //Disable HNP
1443:                       USBOTGDisableHnp();
1444:          
1445:                       //Deactivate HNP
1446:                       USBOTGDeactivateHnp();
1447:                       
1448:                       //If ID Pin Changed State
1449:                       if (USBIDIF && USBIDIE)
1450:                       {  
1451:                           //Re-detect & Initialize
1452:                            USBOTGInitialize();
1453:          
1454:                            //Clear ID Interrupt Flag
1455:                            USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
1456:                       }
1457:                   #endif
1458:          
1459:                   #if defined __C30__ || defined __XC16__
1460:                       //USBClearInterruptFlag(U1OTGIR, 3); 
1461:                   #endif
1462:                      //return so that we don't go through the rest of 
1463:                      //the state machine
1464:                    return;
1465:              }
1466:          
1467:          #ifdef USB_SUPPORT_OTG
1468:              //If Session Is Started Then
1469:             else
1470:             {
1471:                  //If SRP Is Ready
1472:                  if (USBOTGSRPIsReady())
1473:                  {   
1474:                      //Clear SRPReady
1475:                      USBOTGClearSRPReady();
1476:          
1477:                      //Clear SRP Timeout Flag
1478:                      USBOTGClearSRPTimeOutFlag();
1479:          
1480:                      //Indicate Session Started
1481:                      UART2PrintString( "\r\n***** USB OTG B Event - Session Started  *****\r\n" );
1482:                  }
1483:              }
1484:          #endif
1485:          }
1486:          #endif  //#if defined(USB_INTERRUPT)
1487:          /**************************************************************************
1488:              Function:
1489:                  void USBDeviceAttach(void)
1490:              
1491:              Summary:
1492:                  Checks if VBUS is present, and that the USB module is not already 
1493:                  initalized, and if so, enables the USB module so as to signal device 
1494:                  attachment to the USB host.   
1495:          
1496:              Description:
1497:                  This function indicates to the USB host that the USB device has been
1498:                  attached to the bus.  This function needs to be called in order for the
1499:                  device to start to enumerate on the bus.
1500:                          
1501:              Precondition:
1502:                  Should only be called when USB_INTERRUPT is defined.  Also, should only 
1503:                  be called from the main() loop context.  Do not call USBDeviceAttach()
1504:                  from within an interrupt handler, as the USBDeviceAttach() function
1505:                  may modify global interrupt enable bits and settings.
1506:          
1507:                  For normal USB devices:
1508:                  Make sure that if the module was previously on, that it has been turned off 
1509:                  for a long time (ex: 100ms+) before calling this function to re-enable the module.
1510:                  If the device turns off the D+ (for full speed) or D- (for low speed) ~1.5k ohm
1511:                  pull up resistor, and then turns it back on very quickly, common hosts will sometimes 
1512:                  reject this event, since no human could ever unplug and reattach a USB device in a 
1513:                  microseconds (or nanoseconds) timescale.  The host could simply treat this as some kind 
1514:                  of glitch and ignore the event altogether.  
1515:              Parameters:
1516:                  None
1517:               
1518:              Return Values:
1519:                  None       
1520:              
1521:              Remarks: 
1522:          		See also the USBDeviceDetach() API function documentation.                                                 
1523:          ****************************************************************************/
1524:          #if defined(USB_INTERRUPT)
1525:          void USBDeviceAttach(void)
1526:          {
1527:              //if we are in the detached state
1528:              if(USBDeviceState == DETACHED_STATE)
08E4  08CD     MOVF 0x4D, F
08E5  1D03     BTFSS STATUS, 0x2
08E6  0008     RETURN
1529:              {
1530:                  if(USB_BUS_SENSE == 1)
1531:                  {
1532:              	    //Initialize registers to known states.
1533:                      U1CON = 0;          
08E7  003D     MOVLB 0x1D
08E8  018E     CLRF PORTC
1534:              
1535:                      // Mask all USB interrupts
1536:                      U1IE = 0;                                
08E9  0192     CLRF PIR2
1537:              
1538:                      //Configure things like: pull ups, full/low-speed mode, 
1539:                      //set the ping pong mode, and set internal transceiver
1540:                      SetConfigurationOptions();
08EA  3016     MOVLW 0x16
08EB  0091     MOVWF PIR1
08EC  309F     MOVLW 0x9F
08ED  0097     MOVWF TMR1H
08EE  307B     MOVLW 0x7B
08EF  0092     MOVWF PIR2
1541:              
1542:                      USBEnableInterrupts();  //Modifies global interrupt settings
08F0  0021     MOVLB 0x1
08F1  1512     BSF PIR2, 0x2
08F2  170B     BSF INTCON, 0x6
08F3  178B     BSF INTCON, 0x7
1543:              
1544:                      // Enable module & attach to bus
1545:                      while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
08F4  003D     MOVLB 0x1D
08F5  198E     BTFSC PORTC, 0x3
08F6  28F9     GOTO 0xF9
08F7  158E     BSF PORTC, 0x3
08F8  28F4     GOTO 0xF4
1546:              
1547:                      //moved to the attached state
1548:                      USBDeviceState = ATTACHED_STATE;
08F9  3001     MOVLW 0x1
08FA  0022     MOVLB 0x2
08FB  00CD     MOVWF 0x4D
1549:              
1550:                      #ifdef  USB_SUPPORT_OTG
1551:                          U1OTGCON = USB_OTG_DPLUS_ENABLE | USB_OTG_ENABLE;  
1552:                      #endif
1553:                  }
1554:              }
1555:          }
08FC  0008     RETURN
1556:          #endif  //#if defined(USB_INTERRUPT)
1557:          
1558:          
1559:          /*******************************************************************************
1560:            Function: void USBCtrlEPAllowStatusStage(void);
1561:              
1562:            Summary: This function prepares the proper endpoint 0 IN or endpoint 0 OUT 
1563:                      (based on the controlTransferState) to allow the status stage packet
1564:                      of a control transfer to complete.  This function gets used 
1565:                      internally by the USB stack itself, but it may also be called from
1566:                      the application firmware, IF the application firmware called
1567:                      the USBDeferStatusStage() function during the initial processing
1568:                      of the control transfer request.  In this case, the application
1569:                      must call the USBCtrlEPAllowStatusStage() once, after it has fully
1570:                      completed processing and handling the data stage portion of the
1571:                      request.  
1572:                      
1573:                      If the application firmware has no need for delaying control 
1574:                      transfers, and therefore never calls USBDeferStatusStage(), then the
1575:                      application firmware should not call USBCtrlEPAllowStatusStage().
1576:                      
1577:            Description:
1578:              
1579:            Conditions:
1580:              None
1581:          
1582:            Input:
1583:          
1584:            Return:
1585:          
1586:            Remarks:
1587:              None                                                                                                          
1588:            *****************************************************************************/
1589:          void USBCtrlEPAllowStatusStage(void)
1590:          {
1591:              //Check and set two flags, prior to actually modifying any BDT entries.
1592:              //This double checking is necessary to make certain that 
1593:              //USBCtrlEPAllowStatusStage() can be called twice simultaneously (ex: once 
1594:              //in main loop context, while simultaneously getting an interrupt which 
1595:              //tries to call USBCtrlEPAllowStatusStage() again, at the same time).
1596:              if(USBStatusStageEnabledFlag1 == FALSE)
0287  0022     MOVLB 0x2
0288  08CE     MOVF 0x4E, F
0289  1D03     BTFSS STATUS, 0x2
028A  0008     RETURN
1597:              {
1598:                  USBStatusStageEnabledFlag1 = TRUE;  
028B  3001     MOVLW 0x1
028C  00CE     MOVWF 0x4E
1599:                  if(USBStatusStageEnabledFlag2 == FALSE)
028D  08CF     MOVF 0x4F, F
028E  1D03     BTFSS STATUS, 0x2
028F  0008     RETURN
1600:                  {
1601:                      USBStatusStageEnabledFlag2 = TRUE;
0290  00CF     MOVWF 0x4F
1602:                  
1603:                      //Determine which endpoints (EP0 IN or OUT needs arming for the status
1604:                      //stage), based on the type of control transfer currently pending.
1605:                      if(controlTransferState == CTRL_TRF_RX)
0291  0856     MOVF 0x56, W
0292  3A02     XORLW 0x2
0293  1D03     BTFSS STATUS, 0x2
0294  2A9C     GOTO 0x29C
1606:                      {
1607:                          pBDTEntryIn[0]->CNT = 0;
0295  0A3D     INCF 0x3D, W
0296  0086     MOVWF FSR1L
0297  0187     CLRF FSR1H
0298  0181     CLRF INDF1
1608:                          pBDTEntryIn[0]->STAT.Val = _USIE|_DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);        
0299  083D     MOVF 0x3D, W
029A  3185     MOVLP 0x5
029B  2DA0     GOTO 0x5A0
1609:                      }
1610:                      else if(controlTransferState == CTRL_TRF_TX)
029C  0B56     DECFSZ 0x56, W
029D  0008     RETURN
1611:                      {
1612:                  		BothEP0OutUOWNsSet = FALSE;	//Indicator flag used in USBCtrlTrfOutHandler()
029E  01C5     CLRF 0x45
1613:                  
1614:                          //This buffer (when ping pong buffering is enabled on EP0 OUT) receives the
1615:                          //next SETUP packet.
1616:                  		#if((USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG))
1617:                  		pBDTEntryEP0OutCurrent->CNT = USB_EP0_BUFF_SIZE;
029F  0A5A     INCF 0x5A, W
02A0  0086     MOVWF FSR1L
02A1  3008     MOVLW 0x8
02A2  0187     CLRF FSR1H
02A3  0081     MOVWF INDF1
1618:                  		pBDTEntryEP0OutCurrent->ADR = ConvertToPhysicalAddress(&SetupPkt);
02A4  3050     MOVLW 0x50
02A5  00F0     MOVWF dir
02A6  01F1     CLRF data
02A7  085A     MOVF 0x5A, W
02A8  23EF     CALL 0x3EF
02A9  3180     MOVLP 0x0
1619:                  		pBDTEntryEP0OutCurrent->STAT.Val = _USIE|_BSTALL; //Prepare endpoint to accept a SETUP transaction
02AA  085A     MOVF 0x5A, W
02AB  0086     MOVWF FSR1L
02AC  3084     MOVLW 0x84
02AD  0081     MOVWF INDF1
1620:                  		BothEP0OutUOWNsSet = TRUE;	//Indicator flag used in USBCtrlTrfOutHandler()
02AE  3001     MOVLW 0x1
02AF  00C5     MOVWF 0x45
1621:                  		#endif
1622:                  
1623:                          //This EP0 OUT buffer receives the 0-byte OUT status stage packet.
1624:                  		pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
02B0  0020     MOVLB 0x0
02B1  0A6F     INCF pBDTEntryEP0OutNext, W
02B2  0086     MOVWF FSR1L
02B3  3008     MOVLW 0x8
02B4  0081     MOVWF INDF1
1625:                  		pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
02B5  3050     MOVLW 0x50
02B6  00F0     MOVWF dir
02B7  01F1     CLRF data
02B8  086F     MOVF pBDTEntryEP0OutNext, W
02B9  23EF     CALL 0x3EF
1626:                  		pBDTEntryEP0OutNext->STAT.Val = _USIE;           // Note: DTSEN is 0
02BA  086F     MOVF pBDTEntryEP0OutNext, W
02BB  0086     MOVWF FSR1L
02BC  3080     MOVLW 0x80
02BD  0081     MOVWF INDF1
02BE  0008     RETURN
1627:                      }
1628:                  }    
1629:              }
1630:          }   
02BF  302D     MOVLW 0x2D
1631:          
1632:          
1633:          /*******************************************************************************
1634:            Function: void USBCtrlEPAllowDataStage(void);
1635:              
1636:            Summary: This function allows the data stage of either a host-to-device or
1637:                      device-to-host control transfer (with data stage) to complete.
1638:                      This function is meant to be used in conjunction with either the
1639:                      USBDeferOUTDataStage() or USBDeferINDataStage().  If the firmware
1640:                      does not call either USBDeferOUTDataStage() or USBDeferINDataStage(),
1641:                      then the firmware does not need to manually call 
1642:                      USBCtrlEPAllowDataStage(), as the USB stack will call this function
1643:                      instead.
1644:               
1645:            Description:
1646:              
1647:            Conditions: A control transfer (with data stage) should already be pending, 
1648:                          if the firmware calls this function.  Additionally, the firmware
1649:                          should have called either USBDeferOUTDataStage() or 
1650:                          USBDeferINDataStage() at the start of the control transfer, if
1651:                          the firmware will be calling this function manually.
1652:          
1653:            Input:
1654:          
1655:            Return:
1656:          
1657:            Remarks: 
1658:            *****************************************************************************/
1659:          void USBCtrlEPAllowDataStage(void)
1660:          {
1661:              USBDeferINDataStagePackets = FALSE;
047F  01CA     CLRF 0x4A
1662:              USBDeferOUTDataStagePackets = FALSE;
0480  01CB     CLRF 0x4B
1663:          
1664:              if(controlTransferState == CTRL_TRF_RX) //(<setup><out><out>...<out><in>)
0481  0856     MOVF 0x56, W
0482  3A02     XORLW 0x2
0483  1D03     BTFSS STATUS, 0x2
0484  2C94     GOTO 0x494
1665:              {
1666:                  //Prepare EP0 OUT to receive the first OUT data packet in the data stage sequence.
1667:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0485  0020     MOVLB 0x0
0486  2590     CALL 0x590
0487  3183     MOVLP 0x3
1668:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
0488  3058     MOVLW 0x58
0489  00F3     MOVWF handle
048A  01F4     CLRF i_750
048B  086F     MOVF pBDTEntryEP0OutNext, W
048C  3E02     ADDLW 0x2
048D  0086     MOVWF FSR1L
048E  0873     MOVF handle, W
048F  3FC0     MOVWI [0]FSR1
0490  0874     MOVF i_750, W
0491  3FC1     MOVWI [1]FSR1
1669:                  pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
0492  086F     MOVF pBDTEntryEP0OutNext, W
0493  2DA0     GOTO 0x5A0
1670:              }   
1671:              else    //else must be controlTransferState == CTRL_TRF_TX (<setup><in><in>...<in><out>)
1672:              {
1673:                  //Error check the data stage byte count.  Make sure the user specified
1674:                  //value was no greater than the number of bytes the host requested.
1675:          		if(SetupPkt.wLength < inPipes[0].wCount.Val)
0494  0862     MOVF 0x62, W
0495  0020     MOVLB 0x0
0496  0257     SUBWF 0x57, W
0497  1D03     BTFSS STATUS, 0x2
0498  2C9D     GOTO 0x49D
0499  0022     MOVLB 0x2
049A  0861     MOVF 0x61, W
049B  0020     MOVLB 0x0
049C  0256     SUBWF 0x56, W
049D  1803     BTFSC STATUS, 0x0
049E  2CA6     GOTO 0x4A6
1676:          		{
1677:          			inPipes[0].wCount.Val = SetupPkt.wLength;
049F  0857     MOVF 0x57, W
04A0  0022     MOVLB 0x2
04A1  00E2     MOVWF 0x62
04A2  0020     MOVLB 0x0
04A3  0856     MOVF 0x56, W
04A4  0022     MOVLB 0x2
04A5  00E1     MOVWF 0x61
1678:          		}
1679:          		USBCtrlTrfTxService();  //Copies one IN data packet worth of data from application buffer
04A6  24B5     CALL 0x4B5
04A7  3183     MOVLP 0x3
1680:          		                        //to CtrlTrfData buffer.  Also keeps track of how many bytes remaining.
1681:          
1682:          	    //Cnt should have been initialized by responsible request owner (ex: by
1683:          	    //using the USBEP0SendRAMPtr() or USBEP0SendROMPtr() API function).
1684:          		pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
04A8  3058     MOVLW 0x58
04A9  00F3     MOVWF handle
04AA  01F4     CLRF i_750
04AB  083D     MOVF 0x3D, W
04AC  3E02     ADDLW 0x2
04AD  0086     MOVWF FSR1L
04AE  0187     CLRF FSR1H
04AF  0873     MOVF handle, W
04B0  3FC0     MOVWI [0]FSR1
04B1  0874     MOVF i_750, W
04B2  3FC1     MOVWI [1]FSR1
1685:          		pBDTEntryIn[0]->STAT.Val = _USIE|_DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
04B3  083D     MOVF 0x3D, W
04B4  2DA0     GOTO 0x5A0
1686:              }     
1687:          }    
04B5  3008     MOVLW 0x8
1688:          
1689:          
1690:          /******************************************************************************/
1691:          /** Internal Functions *********************************************************/
1692:          /******************************************************************************/
1693:          
1694:          /********************************************************************
1695:           * Function:        void USBConfigureEndpoint(BYTE EPNum, BYTE direction)
1696:           *
1697:           * PreCondition:    None
1698:           *
1699:           * Input:           BYTE EPNum - the endpoint to be configured
1700:           *                  BYTE direction - the direction to be configured
1701:           *                                   (either OUT_FROM_HOST or IN_TO_HOST)
1702:           *
1703:           * Output:          None
1704:           *
1705:           * Side Effects:    None
1706:           *
1707:           * Overview:        This function will configure the specified 
1708:           *                  endpoint
1709:           *
1710:           * Note:            None
1711:           *******************************************************************/
1712:          static void USBConfigureEndpoint(BYTE EPNum, BYTE direction)
1713:          {
1714:              volatile BDT_ENTRY* handle;
1715:          
1716:              //Compute a pointer to the even BDT entry corresponding to the
1717:              //EPNum and direction values passed to this function.
1718:              handle = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN]; //Get address of start of BDT
0389  00F2     MOVWF p
038A  3020     MOVLW 0x20
038B  00F3     MOVWF handle
1719:              handle += EP(EPNum,direction,0u);     //Add in offset to the BDT of interest
038C  0870     MOVF dir, W
038D  00F1     MOVWF data
038E  35F1     LSLF data, F
038F  0872     MOVF p, W
0390  0709     ADDWF WREG, W
0391  0709     ADDWF WREG, W
0392  0771     ADDWF data, W
0393  0709     ADDWF WREG, W
0394  0709     ADDWF WREG, W
0395  07F3     ADDWF handle, F
1720:              
1721:              handle->STAT.UOWN = 0;  //mostly redundant, since USBStdSetCfgHandler() 
0396  0873     MOVF handle, W
0397  0086     MOVWF FSR1L
0398  0187     CLRF FSR1H
0399  1381     BCF INDF1, 0x7
1722:              //already cleared the entire BDT table
1723:          
1724:              //Make sure our pBDTEntryIn/Out[] pointer is initialized.  Needed later
1725:              //for USBTransferOnePacket() API calls.
1726:              if(direction == OUT_FROM_HOST)
039A  08F0     MOVF dir, F
039B  1D03     BTFSS STATUS, 0x2
039C  2BA0     GOTO 0x3A0
1727:              {
1728:                  pBDTEntryOut[EPNum] = handle;
039D  0872     MOVF p, W
039E  3E40     ADDLW 0x40
039F  2BA2     GOTO 0x3A2
1729:              }
1730:              else
1731:              {
1732:                  pBDTEntryIn[EPNum] = handle;
03A0  0872     MOVF p, W
03A1  3E3D     ADDLW 0x3D
03A2  0086     MOVWF FSR1L
03A3  3001     MOVLW 0x1
03A4  0087     MOVWF FSR1H
03A5  0873     MOVF handle, W
03A6  0081     MOVWF INDF1
1733:              }
1734:          
1735:              #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
1736:                  handle->STAT.DTS = 0;
03A7  0873     MOVF handle, W
03A8  0086     MOVWF FSR1L
03A9  0187     CLRF FSR1H
03AA  1301     BCF INDF1, 0x6
1737:                  (handle+1)->STAT.DTS = 1;
03AB  0873     MOVF handle, W
03AC  3E04     ADDLW 0x4
03AD  0086     MOVWF FSR1L
03AE  1701     BSF INDF1, 0x6
1738:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
1739:                  //Set DTS to one because the first thing we will do
1740:                  //when transmitting is toggle the bit
1741:                  handle->STAT.DTS = 1;
1742:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
1743:                  if(EPNum != 0)
1744:                  {
1745:                      handle->STAT.DTS = 1;
1746:                  }
1747:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)    
1748:                  if(EPNum != 0)
1749:                  {
1750:                      handle->STAT.DTS = 0;
1751:                      (handle+1)->STAT.DTS = 1;
1752:                  }
1753:              #endif
1754:          }
03AF  0008     RETURN
1755:          
1756:          
1757:          /******************************************************************************
1758:           * Function:        void USBCtrlEPServiceComplete(void)
1759:           *
1760:           * PreCondition:    None
1761:           *
1762:           * Input:           None
1763:           *
1764:           * Output:          None
1765:           *
1766:           * Side Effects:    None
1767:           *
1768:           * Overview:        This routine wrap up the remaining tasks in servicing
1769:           *                  a Setup Request. Its main task is to set the endpoint
1770:           *                  controls appropriately for a given situation. See code
1771:           *                  below.
1772:           *                  There are three main scenarios:
1773:           *                  a) There was no handler for the Request, in this case
1774:           *                     a STALL should be sent out.
1775:           *                  b) The host has requested a read control transfer,
1776:           *                     endpoints are required to be setup in a specific way.
1777:           *                  c) The host has requested a write control transfer, or
1778:           *                     a control data stage is not required, endpoints are
1779:           *                     required to be setup in a specific way.
1780:           *
1781:           *                  Packet processing is resumed by clearing PKTDIS bit.
1782:           *
1783:           * Note:            None
1784:           *****************************************************************************/
1785:          static void USBCtrlEPServiceComplete(void)
1786:          {
1787:              /*
1788:               * PKTDIS bit is set when a Setup Transaction is received.
1789:               * Clear to resume packet processing.
1790:               */
1791:              USBPacketDisable = 0;
044A  003D     MOVLB 0x1D
044B  120E     BCF PORTC, 0x4
1792:          
1793:          	//Check the busy bits and the SetupPtk.DataDir variables to determine what type of
1794:          	//control transfer is currently in progress.  We need to know the type of control
1795:          	//transfer that is currently pending, in order to know how to properly arm the 
1796:          	//EP0 IN and EP0 OUT endpoints.
1797:              if(inPipes[0].info.bits.busy == 0)
044C  0022     MOVLB 0x2
044D  1BE0     BTFSC event, 0x7
044E  2C64     GOTO 0x464
1798:              {
1799:                  if(outPipes[0].info.bits.busy == 1)
044F  1FB3     BTFSS 0x33, 0x7
0450  2C5B     GOTO 0x45B
1800:                  {
1801:                      controlTransferState = CTRL_TRF_RX;
0451  3002     MOVLW 0x2
0452  00D6     MOVWF 0x56
1802:                      /*
1803:                       * Control Write:
1804:                       * <SETUP[0]><OUT[1]><OUT[0]>...<IN[1]> | <SETUP[0]>
1805:                       */
1806:          
1807:                      //1. Prepare OUT EP to receive data, unless a USB class request handler
1808:                      //   function decided to defer the data stage (ex: because the intended
1809:                      //   RAM buffer wasn't available yet) by calling USBDeferDataStage().
1810:                      //   If it did so, it is then responsible for calling USBCtrlEPAllowDataStage(),
1811:                      //   once it is ready to begin receiving the data.
1812:                      if(USBDeferOUTDataStagePackets == FALSE)
0453  08CB     MOVF 0x4B, F
0454  1D03     BTFSS STATUS, 0x2
0455  2C57     GOTO 0x457
1813:                      {
1814:                          USBCtrlEPAllowDataStage();
0456  247F     CALL 0x47F
1815:                      }
1816:                      
1817:                      //2.  IN endpoint 0 status stage will be armed by USBCtrlEPAllowStatusStage() 
1818:                      //after all of the OUT data has been received and consumed, or if a timeout occurs.
1819:                      USBStatusStageEnabledFlag2 = FALSE;
0457  0022     MOVLB 0x2
0458  01CF     CLRF 0x4F
1820:                      USBStatusStageEnabledFlag1 = FALSE;
0459  01CE     CLRF 0x4E
1821:                  }
045A  0008     RETURN
1822:                  else
1823:                  {
1824:                      /*
1825:                       * If no one knows how to service this request then stall.
1826:                       * Must also prepare EP0 to receive the next SETUP transaction.
1827:                       */
1828:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
045B  24EA     CALL 0x4EA
1829:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
1830:                      pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
045C  308C     MOVLW 0x8C
045D  0081     MOVWF INDF1
1831:                      pBDTEntryIn[0]->STAT.Val = _USIE|_BSTALL; 
045E  0022     MOVLB 0x2
045F  083D     MOVF 0x3D, W
0460  0086     MOVWF FSR1L
0461  3084     MOVLW 0x84
0462  0081     MOVWF INDF1
0463  0008     RETURN
1832:                  }
1833:              }
1834:              else    // A module has claimed ownership of the control transfer session.
1835:              {
1836:          		if(SetupPkt.DataDir == USB_SETUP_DEVICE_TO_HOST_BITFIELD)
0464  0020     MOVLB 0x0
0465  1FD0     BTFSS SetupPkt, 0x7
0466  2C77     GOTO 0x477
1837:          		{
1838:          			controlTransferState = CTRL_TRF_TX;
0467  3001     MOVLW 0x1
0468  0022     MOVLB 0x2
0469  00D6     MOVWF 0x56
1839:          			/*
1840:          			 * Control Read:
1841:          			 * <SETUP[0]><IN[1]><IN[0]>...<OUT[1]> | <SETUP[0]>
1842:          			 *
1843:          			 * 1. Prepare IN EP to transfer data to the host.  If however the data
1844:          			 *    wasn't ready yet (ex: because the firmware needs to go and read it from
1845:          			 *    some slow/currently unavailable resource, such as an external I2C EEPROM),
1846:          			 *    Then the class request handler reponsible should call the USBDeferDataStage()
1847:          			 *    macro.  In this case, the firmware may wait up to 500ms, before it is required
1848:          			 *    to transmit the first IN data packet.  Once the data is ready, and the firmware
1849:          			 *    is ready to begin sending the data, it should then call the 
1850:          			 *    USBCtrlEPAllowDataStage() function to start the data stage.
1851:          			 */
1852:          			if(USBDeferINDataStagePackets == FALSE)
046A  08CA     MOVF 0x4A, F
046B  1D03     BTFSS STATUS, 0x2
046C  2C6F     GOTO 0x46F
1853:                      {
1854:                          USBCtrlEPAllowDataStage();
046D  247F     CALL 0x47F
046E  3183     MOVLP 0x3
1855:          			}
1856:          
1857:                      // 2. (Optionally) allow the status stage now, to prepare for early termination.
1858:                      //    Note: If a class request handler decided to set USBDeferStatusStagePacket == TRUE,
1859:                      //    then it is responsible for eventually calling USBCtrlEPAllowStatusStage() once it
1860:                      //    is ready.  If the class request handler does this, it needs to be careful to
1861:                      //    be written so that it can handle the early termination scenario.
1862:                      //    Ex: It should call USBCtrlEPAllowStatusStage() when any of the following occurs:
1863:                      //    1.  The desired total number of bytes were sent to the host.
1864:                      //    2.  The number of bytes that the host originally requested (in the SETUP packet that 
1865:                      //        started the control transfer) has been reached.
1866:                      //    3.  Or, if a timeout occurs (ex: <50ms since the last successful EP0 IN transaction), regardless 
1867:                      //        of how many bytes have actually been sent.  This is necessary to prevent a deadlock situation
1868:                      //        (where the control transfer can't complete, due to continuous NAK on status stage) if the
1869:                      //        host performs early termination.  If enabled, the USB_ENABLE_STATUS_STAGE_TIMEOUTS usb_config.h
1870:                      //        option can take care of this for you.
1871:                      //    Note: For this type of control transfer, there is normally no harm in simply arming the
1872:                      //    status stage packet right now, even if the IN data is not ready yet.  This allows for
1873:                      //    immediate early termination, without adding unecessary delay.  Therefore, it is generally not
1874:                      //    recommended for the USB class handler firmware to call USBDeferStatusStage(), for this 
1875:                      //    type of control transfer.  If the USB class handler firmware needs more time to fetch the IN
1876:                      //    data that needs to be sent to the host, it should instead use the USBDeferDataStage() function.
1877:                      USBStatusStageEnabledFlag2 = FALSE;
046F  0022     MOVLB 0x2
0470  01CF     CLRF 0x4F
1878:                      USBStatusStageEnabledFlag1 = FALSE;
0471  01CE     CLRF 0x4E
1879:                      if(USBDeferStatusStagePacket == FALSE)
0472  08CC     MOVF 0x4C, F
0473  1D03     BTFSS STATUS, 0x2
0474  0008     RETURN
1880:                      {
1881:                          USBCtrlEPAllowStatusStage();
0475  3182     MOVLP 0x2
0476  2A87     GOTO 0x287
1882:                      } 
1883:          		}
1884:          		else   // (SetupPkt.DataDir == USB_SETUP_DIRECTION_HOST_TO_DEVICE)
1885:          		{
1886:          			//This situation occurs for special types of control transfers,
1887:          			//such as that which occurs when the host sends a SET_ADDRESS
1888:          			//control transfer.  Ex:
1889:          			//
1890:          			//<SETUP[0]><IN[1]> | <SETUP[0]>
1891:          				
1892:          			//Although the data direction is HOST_TO_DEVICE, there is no data stage
1893:          			//(hence: outPipes[0].info.bits.busy == 0).  There is however still
1894:          			//an IN status stage.
1895:          
1896:          			controlTransferState = CTRL_TRF_RX;     //Since this is a HOST_TO_DEVICE control transfer
0477  3002     MOVLW 0x2
0478  0022     MOVLB 0x2
0479  00D6     MOVWF 0x56
047A  24EA     CALL 0x4EA
047B  3183     MOVLP 0x3
1897:          			
1898:          			//1. Prepare OUT EP to receive the next SETUP packet.
1899:          			pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
1900:          			pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
1901:          			pBDTEntryEP0OutNext->STAT.Val = _USIE|_BSTALL;
047C  3084     MOVLW 0x84
047D  0081     MOVWF INDF1
047E  2C6F     GOTO 0x46F
1902:          				
1903:          			//2. Prepare for IN status stage of the control transfer
1904:                      USBStatusStageEnabledFlag2 = FALSE;
1905:                      USBStatusStageEnabledFlag1 = FALSE;
1906:          			if(USBDeferStatusStagePacket == FALSE)
1907:                      {
1908:                          USBCtrlEPAllowStatusStage();
1909:                      } 
1910:          		}
1911:          
1912:              }//end if(ctrl_trf_session_owner == MUID_NULL)
1913:          
1914:          }//end USBCtrlEPServiceComplete
047F  01CA     CLRF 0x4A
1915:          
1916:          
1917:          /******************************************************************************
1918:           * Function:        void USBCtrlTrfTxService(void)
1919:           *
1920:           * PreCondition:    pSrc, wCount, and usb_stat.ctrl_trf_mem are setup properly.
1921:           *
1922:           * Input:           None
1923:           *
1924:           * Output:          None
1925:           *
1926:           * Side Effects:    None
1927:           *
1928:           * Overview:        This routine is used for device to host control transfers 
1929:           *					(IN transactions).  This function takes care of managing a
1930:           *                  transfer over multiple USB transactions.
1931:           *					This routine should be called from only two places.
1932:           *                  One from USBCtrlEPServiceComplete() and one from
1933:           *                  USBCtrlTrfInHandler().
1934:           *
1935:           * Note:            
1936:           *****************************************************************************/
1937:          static void USBCtrlTrfTxService(void)
1938:          {
1939:              BYTE byteToSend;
1940:          
1941:              //Figure out how many bytes of data to send in the next IN transaction.
1942:              //Assume a full size packet, unless otherwise determined below.
1943:              byteToSend = USB_EP0_BUFF_SIZE;         
04B5  3008     MOVLW 0x8
04B6  00F2     MOVWF p
1944:              if(inPipes[0].wCount.Val < (BYTE)USB_EP0_BUFF_SIZE)
04B7  3000     MOVLW 0x0
04B8  0022     MOVLB 0x2
04B9  0262     SUBWF 0x62, W
04BA  3008     MOVLW 0x8
04BB  1903     BTFSC STATUS, 0x2
04BC  0261     SUBWF 0x61, W
04BD  1803     BTFSC STATUS, 0x0
04BE  2CCA     GOTO 0x4CA
1945:              {
1946:                  byteToSend = inPipes[0].wCount.Val;
04BF  0861     MOVF 0x61, W
04C0  00F2     MOVWF p
1947:          
1948:                  //Keep track of whether or not we have sent a "short packet" yet.
1949:                  //This is useful so that later on, we can configure EP0 IN to STALL,
1950:                  //after we have sent all of the intended data.  This makes sure the
1951:                  //hardware STALLs if the host erroneously tries to send more IN token 
1952:                  //packets, requesting more data than intended in the control transfer.
1953:                  if(shortPacketStatus == SHORT_PKT_NOT_USED)
04C1  08DD     MOVF 0x5D, F
04C2  1D03     BTFSS STATUS, 0x2
04C3  2CC6     GOTO 0x4C6
1954:                  {
1955:                      shortPacketStatus = SHORT_PKT_PENDING;
04C4  3001     MOVLW 0x1
04C5  2CC9     GOTO 0x4C9
1956:                  }
1957:                  else if(shortPacketStatus == SHORT_PKT_PENDING)
04C6  0B5D     DECFSZ 0x5D, W
04C7  2CCA     GOTO 0x4CA
1958:                  {
1959:                      shortPacketStatus = SHORT_PKT_SENT;
04C8  3002     MOVLW 0x2
04C9  00DD     MOVWF 0x5D
1960:                  }
1961:              }
1962:          
1963:              //Keep track of how many bytes remain to be sent in the transfer, by
1964:              //subtracting the number of bytes about to be sent from the total.
1965:              inPipes[0].wCount.Val = inPipes[0].wCount.Val - byteToSend;
04CA  0862     MOVF 0x62, W
04CB  00F1     MOVWF data
04CC  0872     MOVF p, W
04CD  0261     SUBWF 0x61, W
04CE  00F0     MOVWF dir
04CF  1C03     BTFSS STATUS, 0x0
04D0  03F1     DECF data, F
04D1  00E1     MOVWF 0x61
04D2  0871     MOVF data, W
04D3  00E2     MOVWF 0x62
1966:              
1967:              //Next, load the number of bytes to send to BC7..0 in buffer descriptor.
1968:              //Note: Control endpoints may never have a max packet size of > 64 bytes.
1969:              //Therefore, the BC8 and BC9 bits should always be maintained clear.
1970:              pBDTEntryIn[0]->CNT = byteToSend;
04D4  0A3D     INCF 0x3D, W
04D5  0086     MOVWF FSR1L
04D6  0187     CLRF FSR1H
04D7  0872     MOVF p, W
04D8  0081     MOVWF INDF1
1971:          
1972:              //Now copy the data from the source location, to the CtrlTrfData[] buffer,
1973:              //which we will send to the host.
1974:              pDst = (USB_VOLATILE BYTE*)CtrlTrfData;                // Set destination pointer
04D9  3058     MOVLW 0x58
04DA  00DB     MOVWF 0x5B
1975:              if(inPipes[0].info.bits.ctrl_trf_mem == USB_EP0_ROM)   // Determine type of memory source
04DB  1C60     BTFSS event, 0x0
04DC  2CE0     GOTO 0x4E0
04DD  2CE6     GOTO 0x4E6
1976:              {
1977:                  while(byteToSend)
04E0  08F2     MOVF p, F
04E1  1903     BTFSC STATUS, 0x2
04E2  0008     RETURN
04E3  2CDE     GOTO 0x4DE
04E4  24FD     CALL 0x4FD
04E5  3183     MOVLP 0x3
1978:                  {
1979:                      *pDst++ = *inPipes[0].pSrc.bRom++;
04DE  24FD     CALL 0x4FD
04DF  3183     MOVLP 0x3
1980:                      byteToSend--;
1981:                  }//end while(byte_to_send.Val)
1982:              }
1983:              else  // RAM
1984:              {
1985:                  while(byteToSend)
04E6  08F2     MOVF p, F
04E7  1903     BTFSC STATUS, 0x2
04E8  0008     RETURN
04E9  2CE4     GOTO 0x4E4
1986:                  {
1987:                      *pDst++ = *inPipes[0].pSrc.bRam++;
1988:                      byteToSend--;
1989:                  }//end while(byte_to_send.Val)
1990:              }//end if(usb_stat.ctrl_trf_mem == _ROM)
1991:          }//end USBCtrlTrfTxService
04EA  0020     MOVLB 0x0
1992:          
1993:          /******************************************************************************
1994:           * Function:        void USBCtrlTrfRxService(void)
1995:           *
1996:           * PreCondition:    pDst and wCount are setup properly.
1997:           *                  pSrc is always &CtrlTrfData
1998:           *                  usb_stat.ctrl_trf_mem is always USB_EP0_RAM.
1999:           *                  wCount should be set to 0 at the start of each control
2000:           *                  transfer.
2001:           *
2002:           * Input:           None
2003:           *
2004:           * Output:          None
2005:           *
2006:           * Side Effects:    None
2007:           *
2008:           * Overview:        This routine is used for host to device control transfers
2009:           *					(uses OUT transactions).  This function receives the data that arrives
2010:           *					on EP0 OUT, and copies it into the appropriate outPipes[0].pDst.bRam
2011:           *					buffer.  Once the host has sent all the data it was intending
2012:           *					to send, this function will call the appropriate outPipes[0].pFunc()
2013:           *					handler (unless it is NULL), so that it can be used by the
2014:           *					intended target firmware.
2015:           *
2016:           * Note:            None
2017:           *****************************************************************************/
2018:          static void USBCtrlTrfRxService(void)
2019:          {
2020:              BYTE byteToRead;
2021:              BYTE i;
2022:          
2023:              //Load byteToRead with the number of bytes the host just sent us in the 
2024:              //last OUT transaction.
2025:              byteToRead = pBDTEntryEP0OutCurrent->CNT;   
0529  085A     MOVF 0x5A, W
052A  0086     MOVWF FSR1L
052B  0187     CLRF FSR1H
052C  3F41     MOVIW [1]FSR1
052D  00F5     MOVWF i
2026:          
2027:              //Update the "outPipes[0].wCount.Val", which keeps track of the total number
2028:              //of remaining bytes expected to be received from the host, in the control
2029:              //transfer.  First check to see if the host sent us more bytes than the
2030:              //application firmware was expecting to receive.
2031:              if(byteToRead > outPipes[0].wCount.Val)
052E  00F2     MOVWF p
052F  01F3     CLRF handle
0530  0873     MOVF handle, W
0531  0235     SUBWF 0x35, W
0532  1D03     BTFSS STATUS, 0x2
0533  2D36     GOTO 0x536
0534  0872     MOVF p, W
0535  0234     SUBWF 0x34, W
0536  1803     BTFSC STATUS, 0x0
0537  2D3A     GOTO 0x53A
2032:              {
2033:                  byteToRead = outPipes[0].wCount.Val;
0538  0834     MOVF 0x34, W
0539  00F5     MOVWF i
2034:              }	
2035:              //Reduce the number of remaining bytes by the number we just received.
2036:          	outPipes[0].wCount.Val = outPipes[0].wCount.Val - byteToRead;   
053A  0835     MOVF 0x35, W
053B  00F3     MOVWF handle
053C  0875     MOVF i, W
053D  0234     SUBWF 0x34, W
053E  00F2     MOVWF p
053F  1C03     BTFSS STATUS, 0x0
0540  03F3     DECF handle, F
0541  00B4     MOVWF 0x34
0542  0873     MOVF handle, W
0543  00B5     MOVWF 0x35
2037:          
2038:              //Copy the OUT DATAx packet bytes that we just received from the host,
2039:              //into the user application buffer space.
2040:              for(i=0;i<byteToRead;i++)
0544  01F4     CLRF i_750
0545  0875     MOVF i, W
0546  0274     SUBWF i_750, W
0547  1803     BTFSC STATUS, 0x0
0548  2D5A     GOTO 0x55A
0558  0AF4     INCF i_750, F
0559  2D45     GOTO 0x545
2041:              {
2042:                  *outPipes[0].pDst.bRam++ = CtrlTrfData[i];
0549  0874     MOVF i_750, W
054A  3E58     ADDLW 0x58
054B  0086     MOVWF FSR1L
054C  0187     CLRF FSR1H
054D  0801     MOVF INDF1, W
054E  00F2     MOVWF p
054F  0831     MOVF 0x31, W
0550  0086     MOVWF FSR1L
0551  0832     MOVF 0x32, W
0552  0087     MOVWF FSR1H
0553  0872     MOVF p, W
0554  0081     MOVWF INDF1
0555  0AB1     INCF 0x31, F
0556  1903     BTFSC STATUS, 0x2
0557  0AB2     INCF 0x32, F
2043:              }//end while(byteToRead.Val)
2044:          
2045:              //If there is more data to receive, prepare EP0 OUT so that it can receive 
2046:          	//the next packet in the sequence.
2047:              if(outPipes[0].wCount.Val > 0)
055A  3003     MOVLW 0x3
055B  3E31     ADDLW 0x31
055C  0086     MOVWF FSR1L
055D  3001     MOVLW 0x1
055E  0087     MOVWF FSR1H
055F  0016     MOVIW FSR1++
0560  0401     IORWF INDF1, W
0561  1903     BTFSC STATUS, 0x2
0562  2D78     GOTO 0x578
2048:              {
2049:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0563  0020     MOVLB 0x0
0564  2590     CALL 0x590
0565  3183     MOVLP 0x3
2050:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
0566  3058     MOVLW 0x58
0567  2596     CALL 0x596
0568  3183     MOVLP 0x3
2051:                  if(pBDTEntryEP0OutCurrent->STAT.DTS == 0)
0569  0022     MOVLB 0x2
056A  085A     MOVF 0x5A, W
056B  0086     MOVWF FSR1L
056C  1B01     BTFSC INDF1, 0x6
056D  2D71     GOTO 0x571
2052:                  {
2053:                      pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
056E  0020     MOVLB 0x0
056F  086F     MOVF pBDTEntryEP0OutNext, W
0570  2DA0     GOTO 0x5A0
2054:                  }
2055:                  else
2056:                  {
2057:                      pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT0|(_DTSEN & _DTS_CHECKING_ENABLED);
0571  0020     MOVLB 0x0
0572  086F     MOVF pBDTEntryEP0OutNext, W
0573  0086     MOVWF FSR1L
0574  3088     MOVLW 0x88
0575  0187     CLRF FSR1H
0576  0081     MOVWF INDF1
0577  0008     RETURN
2058:                  }
2059:              }
2060:              else
2061:              {
2062:          	    //We have received all OUT packets that we were expecting to
2063:          	    //receive for the control transfer.  Prepare EP0 OUT to receive
2064:          		//the next SETUP transaction that may arrive.
2065:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0578  0020     MOVLB 0x0
0579  2590     CALL 0x590
057A  3183     MOVLP 0x3
2066:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
057B  3050     MOVLW 0x50
057C  2596     CALL 0x596
057D  3183     MOVLP 0x3
2067:                  //Configure EP0 OUT to receive the next SETUP transaction for any future
2068:                  //control transfers.  However, set BSTALL in case the host tries to send
2069:                  //more data than it claims it was going to send.
2070:                  pBDTEntryEP0OutNext->STAT.Val = _USIE|_BSTALL;
057E  086F     MOVF pBDTEntryEP0OutNext, W
057F  0086     MOVWF FSR1L
0580  3084     MOVLW 0x84
0581  0081     MOVWF INDF1
2071:          
2072:          		//All data bytes for the host to device control write (OUT) have now been
2073:          		//received successfully.
2074:          		//Go ahead and call the user specified callback function, to use/consume
2075:          		//the control transfer data (ex: if the "void (*function)" parameter 
2076:          		//was non-NULL when USBEP0Receive() was called).
2077:                  if(outPipes[0].pFunc != NULL)
0582  0022     MOVLB 0x2
0583  0836     MOVF 0x36, W
0584  1903     BTFSC STATUS, 0x2
0585  2D89     GOTO 0x589
2078:                  {
2079:                      #if defined(__XC8)
2080:                          //Special pragmas to suppress an expected/harmless warning
2081:                          //message when building with the XC8 compiler
2082:                          #pragma warning push
2083:                          #pragma warning disable 1088
2084:                          outPipes[0].pFunc();    //Call the user's callback function
0586  0836     MOVF 0x36, W
0587  3185     MOVLP 0x5
0588  2D88     GOTO 0x588
2085:                          #pragma warning pop
2086:                      #else
2087:                          outPipes[0].pFunc();    //Call the user's callback function
2088:                      #endif
2089:                  }
2090:                  outPipes[0].info.bits.busy = 0;    
0589  0022     MOVLB 0x2
058A  13B3     BCF 0x33, 0x7
2091:          
2092:                  //Ready to arm status stage IN transaction now, if the application
2093:                  //firmware has completed processing the request.  If it is still busy
2094:                  //and needs more time to finish handling the request, then the user
2095:                  //callback (the one called by the outPipes[0].pFunc();) should set the
2096:                  //USBDeferStatusStagePacket to TRUE (by calling USBDeferStatusStage()).  In 
2097:                  //this case, it is the application's firmware responsibility to call 
2098:                  //the USBCtrlEPAllowStatusStage() function, once it is fully done handling the request.
2099:                  //Note: The application firmware must process the request and call
2100:                  //USBCtrlEPAllowStatusStage() in a semi-timely fashion.  "Semi-timely"
2101:                  //means either 50ms, 500ms, or 5 seconds, depending on the type of
2102:                  //control transfer.  See the USB 2.0 specification section 9.2.6 for
2103:                  //more details.
2104:                  if(USBDeferStatusStagePacket == FALSE)
058B  08CC     MOVF 0x4C, F
058C  1D03     BTFSS STATUS, 0x2
058D  0008     RETURN
2105:                  {
2106:                      USBCtrlEPAllowStatusStage();
058E  3182     MOVLP 0x2
058F  2A87     GOTO 0x287
2107:                  }            
2108:              }    
2109:          
2110:          }//end USBCtrlTrfRxService
0590  0A6F     INCF pBDTEntryEP0OutNext, W
2111:          
2112:          
2113:          /********************************************************************
2114:           * Function:        void USBStdSetCfgHandler(void)
2115:           *
2116:           * PreCondition:    None
2117:           *
2118:           * Input:           None
2119:           *
2120:           * Output:          None
2121:           *
2122:           * Side Effects:    None
2123:           *
2124:           * Overview:        This routine first disables all endpoints by
2125:           *                  clearing UEP registers. It then configures
2126:           *                  (initializes) endpoints by calling the callback
2127:           *                  function USBCBInitEP().
2128:           *
2129:           * Note:            None
2130:           *******************************************************************/
2131:          static void USBStdSetCfgHandler(void)
2132:          {
2133:              BYTE i;
2134:          
2135:              // This will generate a zero length packet
2136:              inPipes[0].info.bits.busy = 1;            
06D8  0022     MOVLB 0x2
06D9  17E0     BSF event, 0x7
2137:          
2138:              //Clear all of the endpoint control registers
2139:              DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
06DA  300E     MOVLW 0xE
06DB  00FB     MOVWF 0x7B
06DC  3099     MOVLW 0x99
06DD  00FA     MOVWF p
06DE  01FC     CLRF i_1132
06DF  087A     MOVF p, W
06E0  0086     MOVWF FSR1L
06E1  087B     MOVF 0x7B, W
06E2  0087     MOVWF FSR1H
06E3  0181     CLRF INDF1
06E4  0AFA     INCF p, F
06E5  1903     BTFSC STATUS, 0x2
06E6  0AFB     INCF 0x7B, F
06E7  3002     MOVLW 0x2
06E8  0AFC     INCF i_1132, F
06E9  027C     SUBWF i_1132, W
06EA  1C03     BTFSS STATUS, 0x0
06EB  2EDF     GOTO 0x6DF
2140:          
2141:              //Clear all of the BDT entries
2142:              memset((void*)&BDT[0], 0x00, sizeof(BDT));
06EC  3020     MOVLW 0x20
06ED  00F0     MOVWF dir
06EE  3030     MOVLW 0x30
06EF  01F1     CLRF data
06F0  01F2     CLRF p
06F1  01F3     CLRF handle
06F2  00F4     MOVWF i_750
06F3  01F5     CLRF i
06F4  2736     CALL 0x736
06F5  3186     MOVLP 0x6
2143:          
2144:              // Assert reset request to all of the Ping Pong buffer pointers
2145:              USBPingPongBufferReset = 1;                                   
06F6  003D     MOVLB 0x1D
06F7  170E     BSF PORTC, 0x6
2146:          
2147:          	//Re-Initialize all ping pong software state bits to 0 (which corresponds to
2148:          	//the EVEN buffer being the next one that will be used), since we are also 
2149:          	//doing a hardware ping pong pointer reset above.
2150:          	for(i = 0; i < (BYTE)(USB_MAX_EP_NUMBER+1u); i++)
06F8  01FD     CLRF i
0702  3003     MOVLW 0x3
0704  0AFD     INCF i, F
0705  027D     SUBWF i, W
0706  1C03     BTFSS STATUS, 0x0
0707  2EF9     GOTO 0x6F9
2151:          	{
2152:          		ep_data_in[i].Val = 0u;
06F9  087D     MOVF i, W
06FA  3E37     ADDLW 0x37
06FB  0086     MOVWF FSR1L
06FC  3001     MOVLW 0x1
06FD  0087     MOVWF FSR1H
06FE  0181     CLRF INDF1
2153:                  ep_data_out[i].Val = 0u;
06FF  087D     MOVF i, W
0700  3E3A     ADDLW 0x3A
0701  0086     MOVWF FSR1L
0703  0181     CLRF INDF1
2154:          	}
2155:          
2156:              //clear the alternate interface settings
2157:              memset((void*)&USBAlternateInterface,0x00,USB_MAX_NUM_INT);
0708  30CD     MOVLW 0xCD
0709  00F0     MOVWF dir
070A  3001     MOVLW 0x1
070B  00F1     MOVWF data
070C  3002     MOVLW 0x2
070D  01F2     CLRF p
070E  01F3     CLRF handle
070F  00F4     MOVWF i_750
0710  01F5     CLRF i
0711  2736     CALL 0x736
0712  3186     MOVLP 0x6
2158:          
2159:              //Stop trying to reset ping pong buffer pointers
2160:              USBPingPongBufferReset = 0;
0713  003D     MOVLB 0x1D
0714  130E     BCF PORTC, 0x6
2161:          
2162:              pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
0715  3028     MOVLW 0x28
0716  0022     MOVLB 0x2
0717  00BD     MOVWF 0x3D
2163:          
2164:          	//Set the next out to the current out packet
2165:              pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN];
0718  3020     MOVLW 0x20
0719  00DA     MOVWF 0x5A
2166:              pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
071A  0020     MOVLB 0x0
071B  00EF     MOVWF pBDTEntryEP0OutNext
2167:          
2168:              //set the current configuration
2169:              USBActiveConfiguration = SetupPkt.bConfigurationValue;
071C  0852     MOVF 0x52, W
071D  0022     MOVLB 0x2
071E  00E3     MOVWF 0x63
2170:          
2171:              //if the configuration value == 0
2172:              if(USBActiveConfiguration == 0)
071F  08E3     MOVF 0x63, F
0720  1D03     BTFSS STATUS, 0x2
0721  2F25     GOTO 0x725
2173:              {
2174:                  //Go back to the addressed state
2175:                  USBDeviceState = ADDRESS_STATE;
0722  3010     MOVLW 0x10
0723  00CD     MOVWF 0x4D
2176:              }
0724  0008     RETURN
2177:              else
2178:              {
2179:                  //initialize the required endpoints
2180:                  USB_SET_CONFIGURATION_HANDLER(EVENT_CONFIGURED,(void*)&USBActiveConfiguration,1);
0725  0020     MOVLB 0x0
0726  3063     MOVLW 0x63
0727  01E0     CLRF event
0728  0AE0     INCF event, F
0729  01E1     CLRF 0x61
072A  00E2     MOVWF 0x62
072B  3001     MOVLW 0x1
072C  00E3     MOVWF 0x63
072D  01E4     CLRF 0x64
072E  0AE4     INCF 0x64, F
072F  01E5     CLRF 0x65
0730  3181     MOVLP 0x1
0731  21E5     CALL 0x1E5
2181:          
2182:                  //Otherwise go to the configured state.  Update the state variable last,
2183:                  //after performing all of the set configuration related initialization
2184:                  //tasks.
2185:                  USBDeviceState = CONFIGURED_STATE;		
0732  3020     MOVLW 0x20
0733  0022     MOVLB 0x2
0734  00CD     MOVWF 0x4D
2186:              }//end if(SetupPkt.bConfigurationValue == 0)
2187:          }//end USBStdSetCfgHandler
0735  0008     RETURN
2188:          
2189:          
2190:          /********************************************************************
2191:           * Function:        void USBStdGetDscHandler(void)
2192:           *
2193:           * PreCondition:    None
2194:           *
2195:           * Input:           None
2196:           *
2197:           * Output:          None
2198:           *
2199:           * Side Effects:    None
2200:           *
2201:           * Overview:        This routine handles the standard GET_DESCRIPTOR
2202:           *                  request.
2203:           *
2204:           * Note:            None
2205:           *******************************************************************/
2206:          static void USBStdGetDscHandler(void)
2207:          {
2208:              if(SetupPkt.bmRequestType == 0x80)
074F  0020     MOVLB 0x0
0750  0850     MOVF SetupPkt, W
0751  3A80     XORLW 0x80
0752  1D03     BTFSS STATUS, 0x2
0753  0008     RETURN
2209:              {
2210:                  inPipes[0].info.Val = USB_EP0_ROM | USB_EP0_BUSY | USB_EP0_INCLUDE_ZERO;
0754  30C0     MOVLW 0xC0
0755  0022     MOVLB 0x2
0756  00E0     MOVWF event
2211:          
2212:                  switch(SetupPkt.bDescriptorType)
0757  2F8F     GOTO 0x78F
078F  0020     MOVLB 0x0
0790  0853     MOVF 0x53, W
0791  3A01     XORLW 0x1
0792  1903     BTFSC STATUS, 0x2
0793  2F58     GOTO 0x758
0794  3A03     XORLW 0x3
0795  1903     BTFSC STATUS, 0x2
0796  2F61     GOTO 0x761
0797  3A01     XORLW 0x1
0798  1903     BTFSC STATUS, 0x2
0799  2F79     GOTO 0x779
079A  2F8C     GOTO 0x78C
2213:                  {
2214:                      case USB_DESCRIPTOR_DEVICE:
2215:                          #if !defined(USB_USER_DEVICE_DESCRIPTOR)
2216:                              inPipes[0].pSrc.bRom = (ROM BYTE*)&device_dsc;
2217:                          #else
2218:                              inPipes[0].pSrc.bRom = (ROM BYTE*)USB_USER_DEVICE_DESCRIPTOR;
0758  3043     MOVLW 0x43
0759  0022     MOVLB 0x2
075A  00DE     MOVWF 0x5E
075B  3091     MOVLW 0x91
075C  00DF     MOVWF 0x5F
2219:                          #endif
2220:                          inPipes[0].wCount.Val = sizeof(device_dsc);
075D  3012     MOVLW 0x12
075E  00E1     MOVWF 0x61
075F  01E2     CLRF 0x62
2221:                          break;
0760  0008     RETURN
2222:                      case USB_DESCRIPTOR_CONFIGURATION:
2223:                          #if !defined(USB_USER_CONFIG_DESCRIPTOR)
2224:                              inPipes[0].pSrc.bRom = *(USB_CD_Ptr+SetupPkt.bDscIndex);
2225:                          #else
2226:                              inPipes[0].pSrc.bRom = *(USB_USER_CONFIG_DESCRIPTOR+SetupPkt.bDscIndex);
0761  0852     MOVF 0x52, W
0762  00F0     MOVWF dir
0763  3035     MOVLW 0x35
0764  27AB     CALL 0x7AB
0765  3187     MOVLP 0x7
0766  3090     MOVLW 0x90
0767  279C     CALL 0x79C
0768  3187     MOVLP 0x7
2227:                          #endif
2228:          
2229:                          //This must be loaded using byte addressing.  The source pointer
2230:                          //  may not be word aligned for the 16 or 32 bit machines resulting
2231:                          //  in an address error on the dereference.
2232:                          inPipes[0].wCount.byte.LB = *(inPipes[0].pSrc.bRom+2);
0769  085F     MOVF 0x5F, W
076A  00F1     MOVWF data
076B  085E     MOVF 0x5E, W
076C  00F0     MOVWF dir
076D  3E02     ADDLW 0x2
076E  27A4     CALL 0x7A4
076F  3187     MOVLP 0x7
0770  00E1     MOVWF 0x61
2233:                          inPipes[0].wCount.byte.HB = *(inPipes[0].pSrc.bRom+3);
0771  085F     MOVF 0x5F, W
0772  00F1     MOVWF data
0773  085E     MOVF 0x5E, W
0774  00F0     MOVWF dir
0775  3E03     ADDLW 0x3
0776  27A4     CALL 0x7A4
0777  00E2     MOVWF 0x62
2234:                          break;
0778  0008     RETURN
2235:                      case USB_DESCRIPTOR_STRING:
2236:                          //USB_NUM_STRING_DESCRIPTORS was introduced as optional in release v2.3.  In v2.4 and
2237:                          //  later it is now manditory.  This should be defined in usb_config.h and should
2238:                          //  indicate the number of string descriptors.
2239:                          if(SetupPkt.bDscIndex<USB_NUM_STRING_DESCRIPTORS)
0779  3004     MOVLW 0x4
077A  0252     SUBWF 0x52, W
077B  1803     BTFSC STATUS, 0x0
077C  2F8C     GOTO 0x78C
2240:                          {
2241:                              //Get a pointer to the String descriptor requested
2242:                              inPipes[0].pSrc.bRom = *(USB_SD_Ptr+SetupPkt.bDscIndex);
077D  0852     MOVF 0x52, W
077E  00F0     MOVWF dir
077F  302D     MOVLW 0x2D
0780  27AB     CALL 0x7AB
0781  3187     MOVLP 0x7
0782  3090     MOVLW 0x90
0783  279C     CALL 0x79C
2243:                              // Set data count
2244:                              inPipes[0].wCount.Val = *inPipes[0].pSrc.bRom;                    
0784  085E     MOVF 0x5E, W
0785  0084     MOVWF FSR0L
0786  085F     MOVF 0x5F, W
0787  0085     MOVWF FSR0H
0788  0800     MOVF INDF0, W
0789  00E1     MOVWF 0x61
078A  01E2     CLRF 0x62
2245:                          }
078B  0008     RETURN
2246:                          #if defined(IMPLEMENT_MICROSOFT_OS_DESCRIPTOR)
2247:                          else if(SetupPkt.bDscIndex == MICROSOFT_OS_DESCRIPTOR_INDEX)
2248:                          {
2249:                              //Get a pointer to the special MS OS string descriptor requested
2250:                              inPipes[0].pSrc.bRom = (ROM BYTE*)&MSOSDescriptor;
2251:                              // Set data count
2252:                              inPipes[0].wCount.Val = *inPipes[0].pSrc.bRom;                    
2253:                          }    
2254:                          #endif
2255:                          else
2256:                          {
2257:                              inPipes[0].info.Val = 0;
078C  0022     MOVLB 0x2
078D  01E0     CLRF event
078E  0008     RETURN
2258:                          }
2259:                          break;
2260:                      default:
2261:                          inPipes[0].info.Val = 0;
2262:                          break;
2263:                  }//end switch
2264:              }//end if
2265:          }//end USBStdGetDscHandler
079B  0008     RETURN
2266:          
2267:          /********************************************************************
2268:           * Function:        void USBStdGetStatusHandler(void)
2269:           *
2270:           * PreCondition:    None
2271:           *
2272:           * Input:           None
2273:           *
2274:           * Output:          None
2275:           *
2276:           * Side Effects:    None
2277:           *
2278:           * Overview:        This routine handles the standard GET_STATUS request
2279:           *
2280:           * Note:            None
2281:           *******************************************************************/
2282:          static void USBStdGetStatusHandler(void)
2283:          {
2284:              CtrlTrfData[0] = 0;                 // Initialize content
176E  0020     MOVLB 0x0
176F  01D8     CLRF CtrlTrfData
2285:              CtrlTrfData[1] = 0;
1770  01D9     CLRF 0x59
2286:          
2287:              switch(SetupPkt.Recipient)
1771  2F9B     GOTO 0x79B
179B  0850     MOVF SetupPkt, W
179C  391F     ANDLW 0x1F
179D  1903     BTFSC STATUS, 0x2
179E  2F72     GOTO 0x772
179F  3A01     XORLW 0x1
17A0  1903     BTFSC STATUS, 0x2
17A1  2F7C     GOTO 0x77C
17A2  3A03     XORLW 0x3
17A3  1903     BTFSC STATUS, 0x2
17A4  2F7F     GOTO 0x77F
17A5  2FA6     GOTO 0x7A6
2288:              {
2289:                  case USB_SETUP_RECIPIENT_DEVICE_BITFIELD:
2290:                      inPipes[0].info.bits.busy = 1;
1772  0022     MOVLB 0x2
1773  17E0     BSF event, 0x7
2291:                      /*
2292:                       * [0]: bit0: Self-Powered Status [0] Bus-Powered [1] Self-Powered
2293:                       *      bit1: RemoteWakeup        [0] Disabled    [1] Enabled
2294:                       */
2295:                      if(self_power == 1) // self_power is defined in HardwareProfile.h
2296:                      {
2297:                          CtrlTrfData[0]|=0x01;
1774  0020     MOVLB 0x0
1775  1458     BSF CtrlTrfData, 0x0
2298:                      }
2299:          
2300:                      if(RemoteWakeup == TRUE)
1776  0022     MOVLB 0x2
1777  0B48     DECFSZ 0x48, W
1778  2FA6     GOTO 0x7A6
2301:                      {
2302:                          CtrlTrfData[0]|=0x02;
1779  0020     MOVLB 0x0
177A  14D8     BSF CtrlTrfData, 0x1
177B  2FA6     GOTO 0x7A6
2303:                      }
2304:                      break;
2305:                  case USB_SETUP_RECIPIENT_INTERFACE_BITFIELD:
2306:                      inPipes[0].info.bits.busy = 1;     // No data to update
177C  0022     MOVLB 0x2
177D  17E0     BSF event, 0x7
2307:                      break;
177E  2FA6     GOTO 0x7A6
2308:                  case USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD:
2309:                      inPipes[0].info.bits.busy = 1;
177F  0022     MOVLB 0x2
1780  17E0     BSF event, 0x7
2310:                      /*
2311:                       * [0]: bit0: Halt Status [0] Not Halted [1] Halted
2312:                       */
2313:                      {
2314:                          BDT_ENTRY *p;
2315:          
2316:                          if(SetupPkt.EPDir == 0)
1781  0020     MOVLB 0x0
1782  1BD4     BTFSC 0x54, 0x7
1783  2F88     GOTO 0x788
2317:                          {
2318:                              p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
1784  0854     MOVF 0x54, W
1785  390F     ANDLW 0xF
1786  3E40     ADDLW 0x40
1787  2F8B     GOTO 0x78B
2319:                          }
2320:                          else
2321:                          {
2322:                              p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
1788  0854     MOVF 0x54, W
1789  390F     ANDLW 0xF
178A  3E3D     ADDLW 0x3D
178B  0086     MOVWF FSR1L
178C  3001     MOVLW 0x1
178D  0087     MOVWF FSR1H
178E  0801     MOVF INDF1, W
178F  00F0     MOVWF dir
2323:                          }
2324:          
2325:                          if((p->STAT.UOWN == 1) && (p->STAT.BSTALL == 1))
1790  0086     MOVWF FSR1L
1791  0187     CLRF FSR1H
1792  1F81     BTFSS INDF1, 0x7
1793  2FA6     GOTO 0x7A6
1794  0870     MOVF dir, W
1795  0086     MOVWF FSR1L
1796  1D01     BTFSS INDF1, 0x2
1797  2FA6     GOTO 0x7A6
2326:                              CtrlTrfData[0]=0x01;    // Set bit0
1798  3001     MOVLW 0x1
1799  00D8     MOVWF CtrlTrfData
179A  2FA6     GOTO 0x7A6
2327:                          break;
2328:                      }
2329:              }//end switch
2330:          
2331:              if(inPipes[0].info.bits.busy == 1)
17A6  0022     MOVLB 0x2
17A7  1FE0     BTFSS event, 0x7
17A8  0008     RETURN
2332:              {
2333:                  inPipes[0].pSrc.bRam = (BYTE*)&CtrlTrfData;            // Set Source
17A9  3058     MOVLW 0x58
17AA  00DE     MOVWF 0x5E
17AB  01DF     CLRF 0x5F
2334:                  inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
17AC  1460     BSF event, 0x0
2335:                  inPipes[0].wCount.v[0] = 2;                         // Set data count
17AD  3002     MOVLW 0x2
17AE  00E1     MOVWF 0x61
2336:              }//end if(...)
2337:          }//end USBStdGetStatusHandler
17AF  0008     RETURN
2338:          
2339:          /********************************************************************
2340:           * Function:        void USBStallHandler(void)
2341:           *
2342:           * PreCondition:    None
2343:           *
2344:           * Input:           None
2345:           *
2346:           * Output:          None
2347:           *
2348:           * Side Effects:    
2349:           *
2350:           * Overview:        This function handles the event of a STALL 
2351:           *                  occuring on the bus
2352:           *
2353:           * Note:            None
2354:           *******************************************************************/
2355:          static void USBStallHandler(void)
2356:          {
2357:              /*
2358:               * Does not really have to do anything here,
2359:               * even for the control endpoint.
2360:               * All BDs of Endpoint 0 are owned by SIE right now,
2361:               * but once a Setup Transaction is received, the ownership
2362:               * for EP0_OUT will be returned to CPU.
2363:               * When the Setup Transaction is serviced, the ownership
2364:               * for EP0_IN will then be forced back to CPU by firmware.
2365:               */
2366:          
2367:              /* v2b fix */
2368:              if(U1EP0bits.EPSTALL == 1)
0317  1C18     BTFSS T1CON, 0x0
2369:              {
2370:                  // UOWN - if 0, owned by CPU, if 1, owned by SIE
2371:                  if((pBDTEntryEP0OutCurrent->STAT.Val == _USIE) && (pBDTEntryIn[0]->STAT.Val == (_USIE|_BSTALL)))
0319  0022     MOVLB 0x2
031A  085A     MOVF 0x5A, W
031B  0086     MOVWF FSR1L
031C  0187     CLRF FSR1H
031D  0801     MOVF INDF1, W
031E  3A80     XORLW 0x80
031F  1D03     BTFSS STATUS, 0x2
0320  2B2B     GOTO 0x32B
0321  083D     MOVF 0x3D, W
0322  0086     MOVWF FSR1L
0323  0801     MOVF INDF1, W
0324  3A84     XORLW 0x84
0325  1D03     BTFSS STATUS, 0x2
0326  2B2B     GOTO 0x32B
2372:                  {
2373:                      // Set ep0Bo to stall also
2374:                      pBDTEntryEP0OutCurrent->STAT.Val = _USIE|_DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
0327  085A     MOVF 0x5A, W
0328  0086     MOVWF FSR1L
0329  308C     MOVLW 0x8C
032A  0081     MOVWF INDF1
2375:                  }//end if
2376:                  U1EP0bits.EPSTALL = 0;               // Clear stall status
032B  003D     MOVLB 0x1D
032C  1018     BCF T1CON, 0x0
2377:              }//end if
2378:          
2379:              USBClearInterruptFlag(USBStallIFReg,USBStallIFBitNum);
032D  1290     BCF 0x10, 0x5
2380:          }
032E  0008     RETURN
2381:          
2382:          /********************************************************************
2383:           * Function:        void USBSuspend(void)
2384:           *
2385:           * PreCondition:    None
2386:           *
2387:           * Input:           None
2388:           *
2389:           * Output:          None
2390:           *
2391:           * Side Effects:    
2392:           *
2393:           * Overview:        This function handles if the host tries to 
2394:           *                  suspend the device
2395:           *
2396:           * Note:            None
2397:           *******************************************************************/
2398:          static void USBSuspend(void)
2399:          {
2400:              /*
2401:               * NOTE: Do not clear UIRbits.ACTVIF here!
2402:               * Reason:
2403:               * ACTVIF is only generated once an IDLEIF has been generated.
2404:               * This is a 1:1 ratio interrupt generation.
2405:               * For every IDLEIF, there will be only one ACTVIF regardless of
2406:               * the number of subsequent bus transitions.
2407:               *
2408:               * If the ACTIF is cleared here, a problem could occur when:
2409:               * [       IDLE       ][bus activity ->
2410:               * <--- 3 ms ----->     ^
2411:               *                ^     ACTVIF=1
2412:               *                IDLEIF=1
2413:               *  #           #           #           #   (#=Program polling flags)
2414:               *                          ^
2415:               *                          This polling loop will see both
2416:               *                          IDLEIF=1 and ACTVIF=1.
2417:               *                          However, the program services IDLEIF first
2418:               *                          because ACTIVIE=0.
2419:               *                          If this routine clears the only ACTIVIF,
2420:               *                          then it can never get out of the suspend
2421:               *                          mode.
2422:               */
2423:              USBActivityIE = 1;                     // Enable bus activity interrupt
032F  1512     BSF PIR2, 0x2
2424:              USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
0330  1210     BCF 0x10, 0x4
2425:          
2426:              #if defined(__18CXX) || defined(_PIC14E)
2427:                  U1CONbits.SUSPND = 1;                   // Put USB module in power conserve
0331  148E     BSF PORTC, 0x1
2428:                                                          // mode, SIE clock inactive
2429:              #endif
2430:              USBBusIsSuspended = TRUE;
0332  3001     MOVLW 0x1
0333  0023     MOVLB 0x3
0334  00AC     MOVWF 0x2C
2431:           
2432:              /*
2433:               * At this point the PIC can go into sleep,idle, or
2434:               * switch to a slower clock, etc.  This should be done in the
2435:               * USBCBSuspend() if necessary.
2436:               */
2437:              USB_SUSPEND_HANDLER(EVENT_SUSPEND,0,0);
0335  3075     MOVLW 0x75
0336  0020     MOVLB 0x0
0337  00E0     MOVWF event
0338  23F6     CALL 0x3F6
0339  3180     MOVLP 0x0
033A  29E5     GOTO 0x1E5
2438:          }
2439:          
2440:          /********************************************************************
2441:           * Function:        void USBWakeFromSuspend(void)
2442:           *
2443:           * PreCondition:    None
2444:           *
2445:           * Input:           None
2446:           *
2447:           * Output:          None
2448:           *
2449:           * Side Effects:    None
2450:           *
2451:           * Overview:
2452:           *
2453:           * Note:            None
2454:           *******************************************************************/
2455:          static void USBWakeFromSuspend(void)
2456:          {
2457:              USBBusIsSuspended = FALSE;
033B  0023     MOVLB 0x3
033C  01AC     CLRF 0x2C
2458:          
2459:              /*
2460:               * If using clock switching, the place to restore the original
2461:               * microcontroller core clock frequency is in the USBCBWakeFromSuspend() callback
2462:               */
2463:              USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0);
033D  3074     MOVLW 0x74
033E  0020     MOVLB 0x0
033F  00E0     MOVWF event
0340  3000     MOVLW 0x0
0341  23F6     CALL 0x3F6
0342  3180     MOVLP 0x0
0343  21E5     CALL 0x1E5
2464:          
2465:              #if defined(__18CXX) || defined(_PIC14E)
2466:                  //To avoid improperly clocking the USB module, make sure the oscillator
2467:                  //settings are consistant with USB operation before clearing the SUSPND bit.
2468:                  //Make sure the correct oscillator settings are selected in the 
2469:                  //"USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0)" handler.
2470:                  U1CONbits.SUSPND = 0;   // Bring USB module out of power conserve
0344  003D     MOVLB 0x1D
0345  108E     BCF PORTC, 0x1
2471:                                          // mode.
2472:              #endif
2473:          
2474:          
2475:              USBActivityIE = 0;
0346  1112     BCF PIR2, 0x2
2476:          
2477:              /********************************************************************
2478:              Bug Fix: Feb 26, 2007 v2.1
2479:              *********************************************************************
2480:              The ACTVIF bit cannot be cleared immediately after the USB module wakes
2481:              up from Suspend or while the USB module is suspended. A few clock cycles
2482:              are required to synchronize the internal hardware state machine before
2483:              the ACTIVIF bit can be cleared by firmware. Clearing the ACTVIF bit
2484:              before the internal hardware is synchronized may not have an effect on
2485:              the value of ACTVIF. Additonally, if the USB module uses the clock from
2486:              the 96 MHz PLL source, then after clearing the SUSPND bit, the USB
2487:              module may not be immediately operational while waiting for the 96 MHz
2488:              PLL to lock.
2489:              ********************************************************************/
2490:          
2491:              // UIRbits.ACTVIF = 0;                      // Removed
2492:              #if defined(__18CXX)
2493:              while(USBActivityIF)
2494:              #endif
2495:              {
2496:                  USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
0347  1110     BCF 0x10, 0x2
2497:              }  // Added
2498:          
2499:          }//end USBWakeFromSuspend
0348  0008     RETURN
2500:          
2501:          /********************************************************************
2502:           * Function:        void USBCtrlEPService(void)
2503:           *
2504:           * PreCondition:    USTAT is loaded with a valid endpoint address.
2505:           *
2506:           * Input:           None
2507:           *
2508:           * Output:          None
2509:           *
2510:           * Side Effects:    None
2511:           *
2512:           * Overview:        USBCtrlEPService checks for three transaction
2513:           *                  types that it knows how to service and services
2514:           *                  them:
2515:           *                  1. EP0 SETUP
2516:           *                  2. EP0 OUT
2517:           *                  3. EP0 IN
2518:           *                  It ignores all other types (i.e. EP1, EP2, etc.)
2519:           *
2520:           * Note:            None
2521:           *******************************************************************/
2522:          static void USBCtrlEPService(void)
2523:          {
2524:              //If we get to here, that means a successful transaction has just occurred 
2525:              //on EP0.  This means "progress" has occurred in the currently pending 
2526:              //control transfer, so we should re-initialize our timeout counter.
2527:              #if defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)
2528:                  USBStatusStageTimeoutCounter = USB_STATUS_STAGE_TIMEOUT;
02BF  302D     MOVLW 0x2D
02C0  00D0     MOVWF SetupPkt
2529:              #endif
2530:          	
2531:          	//Check if the last transaction was on EP0 OUT endpoint (of any kind, to either the even or odd buffer if ping pong buffers used)
2532:              if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_OUT_EVEN)
02C1  0864     MOVF 0x64, W
02C2  39FD     ANDLW 0xFD
02C3  1D03     BTFSS STATUS, 0x2
02C4  2B0E     GOTO 0x30E
2533:              {
2534:          		//Point to the EP0 OUT buffer of the buffer that arrived
2535:                  #if defined (_PIC14E) || defined(__18CXX)
2536:                      pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK)>>1];
02C5  3664     LSRF 0x64, W
02C6  393F     ANDLW 0x3F
02C7  0709     ADDWF WREG, W
02C8  0709     ADDWF WREG, W
02C9  3E20     ADDLW 0x20
02CA  00DA     MOVWF 0x5A
2537:                  #elif defined(__C30__) || defined(__C32__) || defined __XC16__
2538:                      pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK)>>2];
2539:                  #else
2540:                      #error "unimplemented"
2541:                  #endif
2542:          
2543:          		//Set the next out to the current out packet
2544:                  pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
02CB  0020     MOVLB 0x0
02CC  00EF     MOVWF pBDTEntryEP0OutNext
2545:          		//Toggle it to the next ping pong buffer (if applicable)
2546:                  ((BYTE_VAL*)&pBDTEntryEP0OutNext)->Val ^= USB_NEXT_EP0_OUT_PING_PONG;
02CD  3004     MOVLW 0x4
02CE  06EF     XORWF pBDTEntryEP0OutNext, F
2547:          
2548:          		//If the current EP0 OUT buffer has a SETUP packet
2549:                  if(pBDTEntryEP0OutCurrent->STAT.PID == PID_SETUP)
02CF  0022     MOVLB 0x2
02D0  085A     MOVF 0x5A, W
02D1  0086     MOVWF FSR1L
02D2  0187     CLRF FSR1H
02D3  0C01     RRF INDF1, W
02D4  0C89     RRF WREG, F
02D5  390F     ANDLW 0xF
02D6  3A0D     XORLW 0xD
02D7  1D03     BTFSS STATUS, 0x2
02D8  2B0C     GOTO 0x30C
2550:                  {
2551:                      unsigned char setup_cnt;
2552:          
2553:          	        //The SETUP transaction data may have gone into the the CtrlTrfData 
2554:          	        //buffer, or elsewhere, depending upon how the BDT was prepared
2555:          	        //before the transaction.  Therefore, we should copy the data to the 
2556:          	        //SetupPkt buffer so it can be processed correctly by USBCtrlTrfSetupHandler().		    
2557:                      for(setup_cnt = 0; setup_cnt < 8u; setup_cnt++) //SETUP data packets always contain exactly 8 bytes.
02D9  0020     MOVLB 0x0
02DA  01EC     CLRF setup_cnt
02F8  0020     MOVLB 0x0
02F9  3008     MOVLW 0x8
02FA  0AEC     INCF setup_cnt, F
02FB  026C     SUBWF setup_cnt, W
02FC  1C03     BTFSS STATUS, 0x0
02FD  2ADB     GOTO 0x2DB
2558:                      {
2559:                          *(BYTE*)((BYTE*)&SetupPkt + setup_cnt) = *(BYTE*)ConvertToVirtualAddress(pBDTEntryEP0OutCurrent->ADR);
02DB  086C     MOVF setup_cnt, W
02DC  3E50     ADDLW 0x50
02DD  0086     MOVWF FSR1L
02DE  0187     CLRF FSR1H
02DF  0022     MOVLB 0x2
02E0  085A     MOVF 0x5A, W
02E1  3E02     ADDLW 0x2
02E2  0084     MOVWF FSR0L
02E3  0185     CLRF FSR0H
02E4  3F00     MOVIW [0]FSR0
02E5  0020     MOVLB 0x0
02E6  00EA     MOVWF 0x6A
02E7  3F01     MOVIW [1]FSR0
02E8  00EB     MOVWF 0x6B
02E9  086A     MOVF 0x6A, W
02EA  0084     MOVWF FSR0L
02EB  086B     MOVF 0x6B, W
02EC  0085     MOVWF FSR0H
02ED  0800     MOVF INDF0, W
02EE  0081     MOVWF INDF1
2560:                          pBDTEntryEP0OutCurrent->ADR++;
02EF  0022     MOVLB 0x2
02F0  085A     MOVF 0x5A, W
02F1  3E02     ADDLW 0x2
02F2  0086     MOVWF FSR1L
02F3  3001     MOVLW 0x1
02F4  0781     ADDWF INDF1, F
02F5  3141     ADDFSR 1, 1
02F6  1803     BTFSC STATUS, 0x0
02F7  0A81     INCF INDF1, F
2561:                      }    
2562:                      pBDTEntryEP0OutCurrent->ADR = ConvertToPhysicalAddress(&SetupPkt);
02FE  3050     MOVLW 0x50
02FF  00EA     MOVWF 0x6A
0300  01EB     CLRF 0x6B
0301  0022     MOVLB 0x2
0302  085A     MOVF 0x5A, W
0303  3E02     ADDLW 0x2
0304  0086     MOVWF FSR1L
0305  0187     CLRF FSR1H
0306  0020     MOVLB 0x0
0307  086A     MOVF 0x6A, W
0308  3FC0     MOVWI [0]FSR1
0309  086B     MOVF 0x6B, W
030A  3FC1     MOVWI [1]FSR1
2563:          
2564:          			//Handle the control transfer (parse the 8-byte SETUP command and figure out what to do)
2565:                      USBCtrlTrfSetupHandler();
030B  280F     GOTO 0xF
2566:                  }
2567:                  else
2568:                  {
2569:          			//Handle the DATA transfer
2570:                      USBCtrlTrfOutHandler();
030C  3185     MOVLP 0x5
030D  2D0C     GOTO 0x50C
2571:                  }
2572:              }
2573:              else if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_IN)
030E  30FD     MOVLW 0xFD
030F  0564     ANDWF 0x64, W
0310  0020     MOVLB 0x0
0311  00EA     MOVWF 0x6A
0312  3A04     XORLW 0x4
0313  1D03     BTFSS STATUS, 0x2
0314  0008     RETURN
2574:              {
2575:          		//Otherwise the transmission was and EP0 IN
2576:          		//  so take care of the IN transfer
2577:                  USBCtrlTrfInHandler();
0315  3183     MOVLP 0x3
0316  2BFC     GOTO 0x3FC
2578:              }
2579:          
2580:          }//end USBCtrlEPService
0317  1C18     BTFSS T1CON, 0x0
2581:          
2582:          /********************************************************************
2583:           * Function:        void USBCtrlTrfSetupHandler(void)
2584:           *
2585:           * PreCondition:    SetupPkt buffer is loaded with valid USB Setup Data
2586:           *
2587:           * Input:           None
2588:           *
2589:           * Output:          None
2590:           *
2591:           * Side Effects:    None
2592:           *
2593:           * Overview:        This routine is a task dispatcher and has 3 stages.
2594:           *                  1. It initializes the control transfer state machine.
2595:           *                  2. It calls on each of the module that may know how to
2596:           *                     service the Setup Request from the host.
2597:           *                     Module Example: USBD, HID, CDC, MSD, ...
2598:           *                     A callback function, USBCBCheckOtherReq(),
2599:           *                     is required to call other module handlers.
2600:           *                  3. Once each of the modules has had a chance to check if
2601:           *                     it is responsible for servicing the request, stage 3
2602:           *                     then checks direction of the transfer to determine how
2603:           *                     to prepare EP0 for the control transfer.
2604:           *                     Refer to USBCtrlEPServiceComplete() for more details.
2605:           *
2606:           * Note:            Microchip USB Firmware has three different states for
2607:           *                  the control transfer state machine:
2608:           *                  1. WAIT_SETUP
2609:           *                  2. CTRL_TRF_TX (device sends data to host through IN transactions)
2610:           *                  3. CTRL_TRF_RX (device receives data from host through OUT transactions)
2611:           *                  Refer to firmware manual to find out how one state
2612:           *                  is transitioned to another.
2613:           *
2614:           *                  A Control Transfer is composed of many USB transactions.
2615:           *                  When transferring data over multiple transactions,
2616:           *                  it is important to keep track of data source, data
2617:           *                  destination, and data count. These three parameters are
2618:           *                  stored in pSrc,pDst, and wCount. A flag is used to
2619:           *                  note if the data source is from ROM or RAM.
2620:           *
2621:           *******************************************************************/
2622:          static void USBCtrlTrfSetupHandler(void)
2623:          {
2624:              //--------------------------------------------------------------------------
2625:              //1. Re-initialize state tracking variables related to control transfers.
2626:              //--------------------------------------------------------------------------
2627:              shortPacketStatus = SHORT_PKT_NOT_USED;  
000F  0022     MOVLB 0x2
0010  01DD     CLRF 0x5D
2628:              USBDeferStatusStagePacket = FALSE;
0011  01CC     CLRF 0x4C
2629:              USBDeferINDataStagePackets = FALSE;
0012  01CA     CLRF 0x4A
2630:              USBDeferOUTDataStagePackets = FALSE;
0013  01CB     CLRF 0x4B
2631:              BothEP0OutUOWNsSet = FALSE;    
0014  01C5     CLRF 0x45
2632:              controlTransferState = WAIT_SETUP;
0015  01D6     CLRF 0x56
2633:          
2634:              //Abandon any previous control transfers that might have been using EP0.
2635:              //Ordinarily, nothing actually needs abandoning, since the previous control
2636:              //transfer would have completed successfully prior to the host sending the next
2637:              //SETUP packet.  However, in a timeout error case, or after an EP0 STALL event,
2638:              //one or more UOWN bits might still be set.  If so, we should clear the UOWN bits,
2639:              //so the EP0 IN/OUT endpoints are in a known inactive state, ready for re-arming
2640:              //by the class request handler that will be called next.
2641:              pBDTEntryIn[0]->STAT.Val &= ~(_USIE);     
0016  083D     MOVF 0x3D, W
0017  0086     MOVWF FSR1L
0019  0187     CLRF FSR1H
001A  1381     BCF INDF1, 0x7
2642:              ((BYTE_VAL*)&pBDTEntryIn[0])->Val ^= USB_NEXT_EP0_IN_PING_PONG;
0018  3004     MOVLW 0x4
001B  06BD     XORWF 0x3D, F
2643:              pBDTEntryIn[0]->STAT.Val &= ~(_USIE);      
001C  083D     MOVF 0x3D, W
001D  0086     MOVWF FSR1L
001F  1381     BCF INDF1, 0x7
2644:              ((BYTE_VAL*)&pBDTEntryIn[0])->Val ^= USB_NEXT_EP0_IN_PING_PONG;
001E  3004     MOVLW 0x4
0020  06BD     XORWF 0x3D, F
2645:              pBDTEntryEP0OutNext->STAT.Val &= ~(_USIE);         
0021  0020     MOVLB 0x0
0022  086F     MOVF pBDTEntryEP0OutNext, W
0023  0086     MOVWF FSR1L
0024  1381     BCF INDF1, 0x7
2646:          
2647:              inPipes[0].info.Val = 0;
0025  0022     MOVLB 0x2
0026  01E0     CLRF event
2648:              inPipes[0].wCount.Val = 0;
0027  01E1     CLRF 0x61
0028  01E2     CLRF 0x62
2649:              outPipes[0].info.Val = 0;
0029  01B3     CLRF 0x33
2650:              outPipes[0].wCount.Val = 0;
002A  01B4     CLRF 0x34
002B  01B5     CLRF 0x35
2651:              
2652:          
2653:              //--------------------------------------------------------------------------
2654:              //2. Now find out what was in the SETUP packet, and begin handling the request.
2655:              //--------------------------------------------------------------------------
2656:              USBCheckStdRequest();                                               //Check for standard USB "Chapter 9" requests.
002C  2039     CALL 0x39
002D  3180     MOVLP 0x0
2657:              USB_NONSTANDARD_EP0_REQUEST_HANDLER(EVENT_EP0_REQUEST,0,0); //Check for USB device class specific requests
002E  3003     MOVLW 0x3
002F  0020     MOVLB 0x0
0030  00E0     MOVWF event
0031  01E1     CLRF 0x61
0032  01E2     CLRF 0x62
0033  01E3     CLRF 0x63
0034  01E4     CLRF 0x64
0035  01E5     CLRF 0x65
0036  21E5     CALL 0x1E5
2658:          
2659:          
2660:              //--------------------------------------------------------------------------
2661:              //3. Re-arm EP0 IN and EP0 OUT endpoints, based on the control transfer in 
2662:              //   progress.  If one of the above handlers (in step 2) knew how to process
2663:              //   the request, it will have set one of the inPipes[0].info.bits.busy or
2664:              //   outPipes[0].info.bits.busy flags = 1.  This lets the
2665:              //   USBCtrlEPServiceComplete() function know how and which endpoints to 
2666:              //   arm.  If both info.bits.busy flags are = 0, then no one knew how to
2667:              //   process the request.  In this case, the default behavior will be to
2668:              //   perform protocol STALL on EP0.
2669:              //-------------------------------------------------------------------------- 
2670:              USBCtrlEPServiceComplete();
0037  3184     MOVLP 0x4
0038  2C4A     GOTO 0x44A
2671:          }//end USBCtrlTrfSetupHandler
0039  0020     MOVLB 0x0
2672:          
2673:          
2674:          /******************************************************************************
2675:           * Function:        void USBCtrlTrfOutHandler(void)
2676:           *
2677:           * PreCondition:    None
2678:           *
2679:           * Input:           None
2680:           *
2681:           * Output:          None
2682:           *
2683:           * Side Effects:    None
2684:           *
2685:           * Overview:        This routine handles an OUT transaction according to
2686:           *                  which control transfer state is currently active.
2687:           *
2688:           * Note:            Note that if the the control transfer was from
2689:           *                  host to device, the session owner should be notified
2690:           *                  at the end of each OUT transaction to service the
2691:           *                  received data.
2692:           *
2693:           *****************************************************************************/
2694:          static void USBCtrlTrfOutHandler(void)
2695:          {
2696:              if(controlTransferState == CTRL_TRF_RX)
050C  0856     MOVF 0x56, W
050D  3A02     XORLW 0x2
050E  1D03     BTFSS STATUS, 0x2
050F  2D11     GOTO 0x511
2697:              {
2698:                  USBCtrlTrfRxService();	//Copies the newly received data into the appropriate buffer and configures EP0 OUT for next transaction.
0510  2D29     GOTO 0x529
2699:              }
2700:              else //In this case the last OUT transaction must have been a status stage of a CTRL_TRF_TX (<setup><in><in>...<OUT>  <-- this last OUT just occurred as the status stage)
2701:              {
2702:                  //If the status stage is complete, this means we are done with the 
2703:                  //control transfer.  Go back to the idle "WAIT_SETUP" state.
2704:                  controlTransferState = WAIT_SETUP;
0511  01D6     CLRF 0x56
2705:          
2706:          	    //Prepare EP0 OUT for the next SETUP transaction, however, it may have
2707:          	    //already been prepared if ping-pong buffering was enabled on EP0 OUT,
2708:          	    //and the last control transfer was of direction: device to host, see
2709:          	    //USBCtrlEPServiceComplete().  If it was already prepared, do not want
2710:          	    //to do anything to the BDT.
2711:          		if(BothEP0OutUOWNsSet == FALSE)
0512  08C5     MOVF 0x45, F
0513  1D03     BTFSS STATUS, 0x2
0514  2D27     GOTO 0x527
2712:          		{
2713:          	        pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0515  0020     MOVLB 0x0
0516  2590     CALL 0x590
0517  3183     MOVLP 0x3
2714:          	        pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
0518  3050     MOVLW 0x50
0519  00F6     MOVWF handle
051A  01F7     CLRF p
051B  086F     MOVF pBDTEntryEP0OutNext, W
051C  3E02     ADDLW 0x2
051D  0086     MOVWF FSR1L
051E  0876     MOVF handle, W
051F  3FC0     MOVWI [0]FSR1
0520  0877     MOVF p, W
0521  3FC1     MOVWI [1]FSR1
2715:          	        pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;			
0522  086F     MOVF pBDTEntryEP0OutNext, W
0523  0086     MOVWF FSR1L
0524  308C     MOVLW 0x8C
0525  0081     MOVWF INDF1
2716:          		}
0526  0008     RETURN
2717:          		else
2718:          		{
2719:          			BothEP0OutUOWNsSet = FALSE;
0527  01C5     CLRF 0x45
2720:          		}
2721:              }
2722:          }
0528  0008     RETURN
2723:          
2724:          /******************************************************************************
2725:           * Function:        void USBCtrlTrfInHandler(void)
2726:           *
2727:           * PreCondition:    None
2728:           *
2729:           * Input:           None
2730:           *
2731:           * Output:          None
2732:           *
2733:           * Side Effects:    None
2734:           *
2735:           * Overview:        This routine handles an IN transaction according to
2736:           *                  which control transfer state is currently active.
2737:           *
2738:           * Note:            A Set Address Request must not change the acutal address
2739:           *                  of the device until the completion of the control
2740:           *                  transfer. The end of the control transfer for Set Address
2741:           *                  Request is an IN transaction. Therefore it is necessary
2742:           *                  to service this unique situation when the condition is
2743:           *                  right. Macro mUSBCheckAdrPendingState is defined in
2744:           *                  usb9.h and its function is to specifically service this
2745:           *                  event.
2746:           *****************************************************************************/
2747:          static void USBCtrlTrfInHandler(void)
2748:          {
2749:              BYTE lastDTS;
2750:          
2751:              lastDTS = pBDTEntryIn[0]->STAT.DTS;
03FC  0022     MOVLB 0x2
03FD  083D     MOVF 0x3D, W
03FE  0086     MOVWF FSR1L
03FF  3000     MOVLW 0x0
0400  0187     CLRF FSR1H
0401  1B01     BTFSC INDF1, 0x6
0402  3001     MOVLW 0x1
0403  00F5     MOVWF i
2752:          
2753:              //switch to the next ping pong buffer
2754:              ((BYTE_VAL*)&pBDTEntryIn[0])->Val ^= USB_NEXT_EP0_IN_PING_PONG;
0404  3004     MOVLW 0x4
0405  06BD     XORWF 0x3D, F
2755:          
2756:              //Must check if in ADR_PENDING_STATE.  If so, we need to update the address
2757:              //now, since the IN status stage of the (set address) control transfer has 
2758:              //evidently completed successfully.
2759:              if(USBDeviceState == ADR_PENDING_STATE)
0406  084D     MOVF 0x4D, W
0407  3A08     XORLW 0x8
0408  1D03     BTFSS STATUS, 0x2
0409  2C16     GOTO 0x416
2760:              {
2761:                  U1ADDR = SetupPkt.bDevADR.Val;
040A  0020     MOVLB 0x0
040B  0852     MOVF 0x52, W
040C  003D     MOVLB 0x1D
040D  0096     MOVWF TMR1L
2762:                  if(U1ADDR != 0u)
040E  0816     MOVF TMR1L, W
040F  1903     BTFSC STATUS, 0x2
0410  2C13     GOTO 0x413
2763:                  {
2764:                      USBDeviceState=ADDRESS_STATE;
0411  3010     MOVLW 0x10
0412  2C14     GOTO 0x414
2765:                  }
2766:                  else
2767:                  {
2768:                      USBDeviceState=DEFAULT_STATE;
0413  3004     MOVLW 0x4
0414  0022     MOVLB 0x2
0415  00CD     MOVWF 0x4D
2769:                  }
2770:              }//end if
2771:          
2772:          
2773:              if(controlTransferState == CTRL_TRF_TX)
0416  0B56     DECFSZ 0x56, W
0417  2C3E     GOTO 0x43E
2774:              {
2775:                  pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(CtrlTrfData);
0418  3058     MOVLW 0x58
0419  00F3     MOVWF handle
041A  01F4     CLRF i_750
041B  083D     MOVF 0x3D, W
041C  3E02     ADDLW 0x2
041D  0086     MOVWF FSR1L
041E  0187     CLRF FSR1H
041F  0873     MOVF handle, W
0420  3FC0     MOVWI [0]FSR1
0421  0874     MOVF i_750, W
0422  3FC1     MOVWI [1]FSR1
2776:                  USBCtrlTrfTxService();
0423  24B5     CALL 0x4B5
0424  3183     MOVLP 0x3
2777:          
2778:                  //Check if we have already sent a short packet.  If so, configure
2779:                  //the endpoint to STALL in response to any further IN tokens (in the
2780:                  //case that the host erroneously tries to receive more data than it
2781:                  //should).
2782:                  if(shortPacketStatus == SHORT_PKT_SENT)
0425  085D     MOVF 0x5D, W
0426  3A02     XORLW 0x2
0427  1D03     BTFSS STATUS, 0x2
0428  2C2F     GOTO 0x42F
2783:                  {
2784:                      // If a short packet has been sent, don't want to send any more,
2785:                      // stall next time if host is still trying to read.
2786:                      pBDTEntryIn[0]->STAT.Val = _USIE|_BSTALL;
0429  083D     MOVF 0x3D, W
042A  0086     MOVWF FSR1L
042B  3084     MOVLW 0x84
042C  0187     CLRF FSR1H
042D  0081     MOVWF INDF1
2787:                  }
042E  0008     RETURN
2788:                  else
2789:                  {
2790:                      if(lastDTS == 0)
042F  08F5     MOVF i, F
0430  1D03     BTFSS STATUS, 0x2
0431  2C38     GOTO 0x438
2791:                      {
2792:                          pBDTEntryIn[0]->STAT.Val = _USIE|_DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
0432  083D     MOVF 0x3D, W
0433  0086     MOVWF FSR1L
0434  30C8     MOVLW 0xC8
0435  0187     CLRF FSR1H
0436  0081     MOVWF INDF1
2793:                      }
0437  0008     RETURN
2794:                      else
2795:                      {
2796:                          pBDTEntryIn[0]->STAT.Val = _USIE|_DAT0|(_DTSEN & _DTS_CHECKING_ENABLED);
0438  083D     MOVF 0x3D, W
0439  0086     MOVWF FSR1L
043A  3088     MOVLW 0x88
043B  0187     CLRF FSR1H
043C  0081     MOVWF INDF1
043D  0008     RETURN
2797:                      }
2798:                  }//end if(...)else
2799:              }
2800:          	else // must have been a CTRL_TRF_RX status stage IN packet (<setup><out><out>...<IN>  <-- this last IN just occurred as the status stage)
2801:          	{
2802:                  //if someone is still expecting data from the control transfer
2803:                  //  then make sure to terminate that request and let them know that
2804:                  //  they are done
2805:                  if(outPipes[0].info.bits.busy == 1)
043E  1FB3     BTFSS 0x33, 0x7
043F  2C48     GOTO 0x448
2806:                  {
2807:                      if(outPipes[0].pFunc != NULL)
0440  0836     MOVF 0x36, W
0441  1903     BTFSC STATUS, 0x2
0442  2C46     GOTO 0x446
2808:                      {
2809:                          outPipes[0].pFunc();
0443  0836     MOVF 0x36, W
0444  3184     MOVLP 0x4
0445  2C45     GOTO 0x445
2810:                      }
2811:                      outPipes[0].info.bits.busy = 0;
0446  0022     MOVLB 0x2
0447  13B3     BCF 0x33, 0x7
2812:                  }
2813:              	
2814:                  controlTransferState = WAIT_SETUP;
0448  01D6     CLRF 0x56
2815:                  //Don't need to arm EP0 OUT here.  It was already armed by the last <out> that
2816:                  //got processed by the USBCtrlTrfRxService() handler.
2817:          	}	
2818:          
2819:          }
0449  0008     RETURN
2820:          
2821:          
2822:          /********************************************************************
2823:           * Function:        void USBCheckStdRequest(void)
2824:           *
2825:           * PreCondition:    None
2826:           *
2827:           * Input:           None
2828:           *
2829:           * Output:          None
2830:           *
2831:           * Side Effects:    None
2832:           *
2833:           * Overview:        This routine checks the setup data packet to see
2834:           *                  if it knows how to handle it
2835:           *
2836:           * Note:            None
2837:           *******************************************************************/
2838:          static void USBCheckStdRequest(void)
2839:          {
2840:              if(SetupPkt.RequestType != USB_SETUP_TYPE_STANDARD_BITFIELD) return;
0039  0020     MOVLB 0x0
003A  0E50     SWAPF SetupPkt, W
003B  0C89     RRF WREG, F
003C  3903     ANDLW 0x3
003D  1D03     BTFSS STATUS, 0x2
003E  0008     RETURN
2841:          
2842:              switch(SetupPkt.bRequest)
003F  0851     MOVF 0x51, W
0040  0084     MOVWF FSR0L
0041  300D     MOVLW 0xD
0042  0204     SUBWF FSR0L, W
0043  1803     BTFSC STATUS, 0x0
0044  0008     RETURN
0045  3191     MOVLP 0x11
0046  3504     LSLF FSR0L, W
0047  3E68     ADDLW 0x68
0048  0082     MOVWF PCL
1168  3180     MOVLP 0x0
2843:              {
2844:                  case USB_REQUEST_SET_ADDRESS:
2845:                      inPipes[0].info.bits.busy = 1;            // This will generate a zero length packet
004A  0022     MOVLB 0x2
004B  17E0     BSF event, 0x7
2846:                      USBDeviceState = ADR_PENDING_STATE;       // Update state only
004C  3008     MOVLW 0x8
004D  00CD     MOVWF 0x4D
2847:                      /* See USBCtrlTrfInHandler() for the next step */
2848:                      break;
004E  0008     RETURN
2849:                  case USB_REQUEST_GET_DESCRIPTOR:
2850:                      USBStdGetDscHandler();
004F  3187     MOVLP 0x7
0050  2F4F     GOTO 0x74F
2851:                      break;
2852:                  case USB_REQUEST_SET_CONFIGURATION:
2853:                      USBStdSetCfgHandler();
0051  3186     MOVLP 0x6
0052  2ED8     GOTO 0x6D8
2854:                      break;
2855:                  case USB_REQUEST_GET_CONFIGURATION:
2856:                      inPipes[0].pSrc.bRam = (BYTE*)&USBActiveConfiguration;         // Set Source
0053  3063     MOVLW 0x63
0054  0022     MOVLB 0x2
0055  00DE     MOVWF 0x5E
0056  3001     MOVLW 0x1
0057  00DF     MOVWF 0x5F
2857:                      inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
0058  1460     BSF event, 0x0
2858:                      inPipes[0].wCount.v[0] = 1;                         // Set data count
0059  00E1     MOVWF 0x61
2859:                      inPipes[0].info.bits.busy = 1;
005A  17E0     BSF event, 0x7
2860:                      break;
005B  0008     RETURN
2861:                  case USB_REQUEST_GET_STATUS:
2862:                      USBStdGetStatusHandler();
005C  3197     MOVLP 0x17
005D  2F6E     GOTO 0x76E
2863:                      break;
2864:                  case USB_REQUEST_CLEAR_FEATURE:
2865:                  case USB_REQUEST_SET_FEATURE:
2866:                      USBStdFeatureReqHandler();
005E  2875     GOTO 0x75
2867:                      break;
2868:                  case USB_REQUEST_GET_INTERFACE:
2869:                      inPipes[0].pSrc.bRam = (BYTE*)&USBAlternateInterface[SetupPkt.bIntfID];  // Set source
005F  0854     MOVF 0x54, W
0060  3ECD     ADDLW 0xCD
0061  2854     GOTO 0x54
2870:                      inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
2871:                      inPipes[0].wCount.v[0] = 1;                         // Set data count
2872:                      inPipes[0].info.bits.busy = 1;
2873:                      break;
2874:                  case USB_REQUEST_SET_INTERFACE:
2875:                      inPipes[0].info.bits.busy = 1;
0062  0022     MOVLB 0x2
0063  17E0     BSF event, 0x7
2876:                      USBAlternateInterface[SetupPkt.bIntfID] = SetupPkt.bAltID;
0064  0020     MOVLB 0x0
0065  0854     MOVF 0x54, W
0066  3ECD     ADDLW 0xCD
0067  0086     MOVWF FSR1L
0068  3001     MOVLW 0x1
0069  0087     MOVWF FSR1H
006A  0852     MOVF 0x52, W
006B  0081     MOVWF INDF1
2877:                      break;
006C  0008     RETURN
2878:                  case USB_REQUEST_SET_DESCRIPTOR:
2879:                      USB_SET_DESCRIPTOR_HANDLER(EVENT_SET_DESCRIPTOR,0,0);
006D  3002     MOVLW 0x2
006E  00E0     MOVWF event
006F  01E1     CLRF 0x61
0070  01E2     CLRF 0x62
0071  01E3     CLRF 0x63
0072  01E4     CLRF 0x64
0073  01E5     CLRF 0x65
0074  29E5     GOTO 0x1E5
2880:                      break;
2881:                  case USB_REQUEST_SYNCH_FRAME:
2882:                  default:
2883:                      break;
2884:              }//end switch
2885:          }//end USBCheckStdRequest
0049  0008     RETURN
2886:          
2887:          /********************************************************************
2888:           * Function:        void USBStdFeatureReqHandler(void)
2889:           *
2890:           * PreCondition:    None
2891:           *
2892:           * Input:           None
2893:           *
2894:           * Output:          Can alter BDT entries.  Can also modify USB stack
2895:           *                  Maintained variables.
2896:           *
2897:           * Side Effects:    None
2898:           *
2899:           * Overview:        This routine handles the standard SET & CLEAR
2900:           *                  FEATURES requests
2901:           *
2902:           * Note:            This is a private function, intended for internal 
2903:           *                  use by the USB stack, when processing SET/CLEAR
2904:           *                  feature requests.  
2905:           *******************************************************************/
2906:          static void USBStdFeatureReqHandler(void)
2907:          {
2908:              BDT_ENTRY *p;
2909:              EP_STATUS current_ep_data;
2910:              #if defined(__C32__)
2911:                  DWORD* pUEP;
2912:              #else
2913:                  unsigned char* pUEP;             
2914:              #endif
2915:              
2916:          
2917:              #ifdef	USB_SUPPORT_OTG
2918:              //Check for USB On-The-Go (OTG) specific requests
2919:              if ((SetupPkt.bFeature == OTG_FEATURE_B_HNP_ENABLE)&&
2920:                  (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2921:              {  
2922:                  inPipes[0].info.bits.busy = 1;
2923:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2924:                      USBOTGEnableHnp();
2925:                  else
2926:                      USBOTGDisableHnp();
2927:              }
2928:          
2929:              if ((SetupPkt.bFeature == OTG_FEATURE_A_HNP_SUPPORT)&&
2930:                  (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2931:              {
2932:                  inPipes[0].info.bits.busy = 1;
2933:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2934:                      USBOTGEnableSupportHnp();
2935:                  else
2936:                      USBOTGDisableSupportHnp();
2937:              }
2938:          
2939:              if ((SetupPkt.bFeature == OTG_FEATURE_A_ALT_HNP_SUPPORT)&&
2940:                  (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2941:              {
2942:                  inPipes[0].info.bits.busy = 1;
2943:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2944:                      USBOTGEnableAltHnp();
2945:                  else
2946:                      USBOTGDisableAltHnp();
2947:              }
2948:              #endif   //#ifdef USB_SUPPORT_OTG 
2949:          
2950:              //Check if the host sent a valid SET or CLEAR feature (remote wakeup) request.
2951:              if((SetupPkt.bFeature == USB_FEATURE_DEVICE_REMOTE_WAKEUP)&&
2952:                 (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
0075  0020     MOVLB 0x0
0076  0B52     DECFSZ 0x52, W
0077  2889     GOTO 0x89
0078  0850     MOVF SetupPkt, W
0079  391F     ANDLW 0x1F
007A  1D03     BTFSS STATUS, 0x2
007B  2889     GOTO 0x89
2953:              {
2954:                  inPipes[0].info.bits.busy = 1;
007C  0022     MOVLB 0x2
007D  17E0     BSF event, 0x7
2955:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
007E  0020     MOVLB 0x0
007F  0851     MOVF 0x51, W
0080  3A03     XORLW 0x3
0081  1D03     BTFSS STATUS, 0x2
0082  2887     GOTO 0x87
2956:                      RemoteWakeup = TRUE;
0083  3001     MOVLW 0x1
0084  0022     MOVLB 0x2
0085  00C8     MOVWF 0x48
0086  2889     GOTO 0x89
2957:                  else
2958:                      RemoteWakeup = FALSE;
0087  0022     MOVLB 0x2
0088  01C8     CLRF 0x48
2959:              }//end if
2960:          
2961:              //Check if the host sent a valid SET or CLEAR endpoint halt request.
2962:              if((SetupPkt.bFeature == USB_FEATURE_ENDPOINT_HALT)&&
2963:                 (SetupPkt.Recipient == USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD)&&
2964:                 (SetupPkt.EPNum != 0) && (SetupPkt.EPNum <= USB_MAX_EP_NUMBER)&&
2965:                 (USBDeviceState == CONFIGURED_STATE))
0089  0020     MOVLB 0x0
008A  0852     MOVF 0x52, W
008B  1D03     BTFSS STATUS, 0x2
008C  0008     RETURN
008D  0850     MOVF SetupPkt, W
008E  391F     ANDLW 0x1F
008F  3A02     XORLW 0x2
0090  1D03     BTFSS STATUS, 0x2
0091  0008     RETURN
0092  0854     MOVF 0x54, W
0093  390F     ANDLW 0xF
0094  1903     BTFSC STATUS, 0x2
0095  0008     RETURN
0096  0854     MOVF 0x54, W
0097  390F     ANDLW 0xF
0098  00FA     MOVWF p
0099  3003     MOVLW 0x3
009A  027A     SUBWF p, W
009B  1803     BTFSC STATUS, 0x0
009C  0008     RETURN
009D  0022     MOVLB 0x2
009E  084D     MOVF 0x4D, W
009F  3A20     XORLW 0x20
00A0  1D03     BTFSS STATUS, 0x2
00A1  0008     RETURN
2966:              {
2967:          		//The request was valid.  Take control of the control transfer and
2968:          		//perform the host requested action.
2969:          		inPipes[0].info.bits.busy = 1;
00A2  17E0     BSF event, 0x7
2970:          
2971:                  //Fetch a pointer to the BDT that the host wants to SET/CLEAR halt on.
2972:                  if(SetupPkt.EPDir == OUT_FROM_HOST)
00A3  0020     MOVLB 0x0
00A4  1BD4     BTFSC 0x54, 0x7
00A5  28B2     GOTO 0xB2
2973:                  {
2974:                      p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
00A6  0854     MOVF 0x54, W
00A7  390F     ANDLW 0xF
00A8  3E40     ADDLW 0x40
00A9  0086     MOVWF FSR1L
00AA  3001     MOVLW 0x1
00AB  0087     MOVWF FSR1H
00AC  0801     MOVF INDF1, W
00AD  00E9     MOVWF p
2975:                      current_ep_data.Val = ep_data_out[SetupPkt.EPNum].Val;
00AE  0854     MOVF 0x54, W
00AF  390F     ANDLW 0xF
00B0  3E3A     ADDLW 0x3A
00B1  28BD     GOTO 0xBD
2976:                  }
2977:                  else
2978:                  {
2979:                      p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
00B2  0854     MOVF 0x54, W
00B3  390F     ANDLW 0xF
00B4  3E3D     ADDLW 0x3D
00B5  0086     MOVWF FSR1L
00B6  3001     MOVLW 0x1
00B7  0087     MOVWF FSR1H
00B8  0801     MOVF INDF1, W
00B9  00E9     MOVWF p
2980:                      current_ep_data.Val = ep_data_in[SetupPkt.EPNum].Val;
00BA  0854     MOVF 0x54, W
00BB  390F     ANDLW 0xF
00BC  3E37     ADDLW 0x37
00BD  0086     MOVWF FSR1L
00BE  0801     MOVF INDF1, W
00BF  00E8     MOVWF current_ep_data
2981:                  }
2982:          
2983:                  //If ping pong buffering is enabled on the requested endpoint, need 
2984:                  //to point to the one that is the active BDT entry which the SIE will 
2985:                  //use for the next attempted transaction on that EP number.
2986:                  #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
2987:                      if(current_ep_data.bits.ping_pong_state == 0) //Check if even
00C0  1868     BTFSC current_ep_data, 0x0
00C1  28C4     GOTO 0xC4
2988:                      {
2989:                          USBHALPingPongSetToEven(&p);
00C2  1169     BCF p, 0x2
2990:                      }
00C3  28C5     GOTO 0xC5
2991:                      else //else must have been odd
2992:                      {
2993:                          USBHALPingPongSetToOdd(&p);
00C4  1569     BSF p, 0x2
2994:                      }
2995:                  #endif
2996:                  
2997:                  //Update the BDT pointers with the new, next entry based on the feature
2998:                  //  request
2999:                  if(SetupPkt.EPDir == OUT_FROM_HOST)
00C5  1BD4     BTFSC 0x54, 0x7
00C6  28CB     GOTO 0xCB
3000:                  {
3001:                      pBDTEntryOut[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
00C7  0854     MOVF 0x54, W
00C8  390F     ANDLW 0xF
00C9  3E40     ADDLW 0x40
00CA  28CE     GOTO 0xCE
3002:                  }
3003:                  else
3004:                  {
3005:                      pBDTEntryIn[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
00CB  0854     MOVF 0x54, W
00CC  390F     ANDLW 0xF
00CD  3E3D     ADDLW 0x3D
00CE  0086     MOVWF FSR1L
00CF  3001     MOVLW 0x1
00D0  0087     MOVWF FSR1H
00D1  0869     MOVF p, W
00D2  0081     MOVWF INDF1
3006:                  }
3007:          
3008:          		//Check if it was a SET_FEATURE endpoint halt request
3009:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
00D3  0851     MOVF 0x51, W
00D4  3A03     XORLW 0x3
00D5  1D03     BTFSS STATUS, 0x2
00D6  28EF     GOTO 0xEF
3010:                  {
3011:                      if(p->STAT.UOWN == 1)
00D7  0869     MOVF p, W
00D8  0086     MOVWF FSR1L
00D9  0187     CLRF FSR1H
00DA  1F81     BTFSS INDF1, 0x7
00DB  28E9     GOTO 0xE9
3012:                      {
3013:                          //Mark that we are terminating this transfer and that the user
3014:                          //  needs to be notified later
3015:                          if(SetupPkt.EPDir == OUT_FROM_HOST)
00DC  1BD4     BTFSC 0x54, 0x7
00DD  28E2     GOTO 0xE2
3016:                          {
3017:                              ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 1;
00DE  0854     MOVF 0x54, W
00DF  390F     ANDLW 0xF
00E0  3E3A     ADDLW 0x3A
00E1  28E5     GOTO 0xE5
3018:                          }
3019:                          else
3020:                          {
3021:                              ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 1;
00E2  0854     MOVF 0x54, W
00E3  390F     ANDLW 0xF
00E4  3E37     ADDLW 0x37
00E5  0086     MOVWF FSR1L
00E6  3001     MOVLW 0x1
00E7  0087     MOVWF FSR1H
00E8  1481     BSF INDF1, 0x1
3022:                          }
3023:                      }
3024:          
3025:          			//Then STALL the endpoint
3026:                      p->STAT.Val |= _USIE|_BSTALL;
00E9  0869     MOVF p, W
00EA  0086     MOVWF FSR1L
00EB  3084     MOVLW 0x84
00EC  0187     CLRF FSR1H
00ED  0481     IORWF INDF1, F
3027:                  }//if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
00EE  0008     RETURN
3028:                  else
3029:                  {
3030:          			//Else the request must have been a CLEAR_FEATURE endpoint halt.
3031:                      #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
3032:                          //toggle over the to the non-active BDT
3033:                          USBAdvancePingPongBuffer(&p);  
00EF  3004     MOVLW 0x4
00F0  06E9     XORWF p, F
3034:          
3035:                          if(p->STAT.UOWN == 1)
00F1  0869     MOVF p, W
00F2  0086     MOVWF FSR1L
00F3  0187     CLRF FSR1H
00F5  1F81     BTFSS INDF1, 0x7
00F6  2907     GOTO 0x107
3036:                          {
3037:                              //Clear UOWN and set DTS state so it will be correct the next time
3038:                              //the application firmware uses USBTransferOnePacket() on the EP.
3039:                              p->STAT.Val &= (~_USIE);    //Clear UOWN bit
00F4  0869     MOVF p, W
00F7  0086     MOVWF FSR1L
00F8  1381     BCF INDF1, 0x7
3040:                              p->STAT.Val |= _DAT1;       //Set DTS to DATA1
00F9  0086     MOVWF FSR1L
00FB  1701     BSF INDF1, 0x6
3041:                              USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
00FA  3005     MOVLW 0x5
00FC  00E0     MOVWF event
00FD  01E1     CLRF 0x61
00FE  0869     MOVF p, W
00FF  00E2     MOVWF 0x62
0100  01E3     CLRF 0x63
0101  01E4     CLRF 0x64
0102  0AE4     INCF 0x64, F
0103  01E5     CLRF 0x65
0104  21E5     CALL 0x1E5
0105  3180     MOVLP 0x0
3042:                          }
0106  290A     GOTO 0x10A
3043:                          else
3044:                          {
3045:                              //UOWN already clear, but still need to set DTS to DATA1     
3046:          					p->STAT.Val |= _DAT1;
0107  0086     MOVWF FSR1L
0108  0187     CLRF FSR1H
0109  1701     BSF INDF1, 0x6
3047:                          }
3048:          
3049:                          //toggle back to the active BDT (the one the SIE is currently looking at
3050:                          //and will use for the next successful transaction to take place on the EP
3051:                          USBAdvancePingPongBuffer(&p);    
010A  3004     MOVLW 0x4
010B  0020     MOVLB 0x0
010C  06E9     XORWF p, F
3052:                          
3053:                          //Check if we are currently terminating, or have previously terminated
3054:                          //a transaction on the given endpoint.  If so, need to clear UOWN,
3055:                          //set DTS to the proper state, and call the application callback
3056:                          //function.
3057:                          if((current_ep_data.bits.transfer_terminated != 0) || (p->STAT.UOWN == 1))
010D  18E8     BTFSC current_ep_data, 0x1
010E  2914     GOTO 0x114
010F  0869     MOVF p, W
0110  0086     MOVWF FSR1L
0111  0187     CLRF FSR1H
0112  1F81     BTFSS INDF1, 0x7
0113  2932     GOTO 0x132
3058:                          {
3059:                              if(SetupPkt.EPDir == OUT_FROM_HOST)
0114  1BD4     BTFSC 0x54, 0x7
0115  291A     GOTO 0x11A
3060:                              {
3061:                                  ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
0116  0854     MOVF 0x54, W
0117  390F     ANDLW 0xF
0118  3E3A     ADDLW 0x3A
0119  291D     GOTO 0x11D
3062:                              }
3063:                              else
3064:                              {
3065:                                  ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
011A  0854     MOVF 0x54, W
011B  390F     ANDLW 0xF
011C  3E37     ADDLW 0x37
011D  0086     MOVWF FSR1L
011E  3001     MOVLW 0x1
011F  0087     MOVWF FSR1H
0120  1081     BCF INDF1, 0x1
3066:                              }
3067:                              //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition     
3068:                              p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL);  
0121  0869     MOVF p, W
0122  0086     MOVWF FSR1L
0123  303B     MOVLW 0x3B
0124  0187     CLRF FSR1H
0125  0581     ANDWF INDF1, F
3069:                              //Call the application event handler callback function, so it can 
3070:          					//decide if the endpoint should get re-armed again or not.
3071:                              USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
0126  3005     MOVLW 0x5
0127  00E0     MOVWF event
0128  01E1     CLRF 0x61
0129  0869     MOVF p, W
012A  00E2     MOVWF 0x62
012B  01E3     CLRF 0x63
012C  01E4     CLRF 0x64
012D  0AE4     INCF 0x64, F
012E  01E5     CLRF 0x65
012F  21E5     CALL 0x1E5
0130  3180     MOVLP 0x0
3072:                          }
0131  2937     GOTO 0x137
3073:                          else
3074:                          {
3075:                              //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition     
3076:                              p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL); 
0132  0869     MOVF p, W
0133  0086     MOVWF FSR1L
0134  303B     MOVLW 0x3B
0135  0187     CLRF FSR1H
0136  0581     ANDWF INDF1, F
3077:                          } 
3078:                      #else //else we must not be using ping-pong buffering on the requested endpoint
3079:                          //Check if we need to call the user transfer terminated event callback function.
3080:                          //We should call the callback, if the endpoint was previously terminated,
3081:                          //or the endpoint is currently armed, and the host is performing clear
3082:                          //endpoint halt, even though the endpoint wasn't stalled.
3083:                          if((current_ep_data.bits.transfer_terminated != 0) || (p->STAT.UOWN == 1))
3084:                          {
3085:                              //We are going to call the user transfer terminated callback.
3086:                              //Clear the flag so we know we took care of it and don't need
3087:                              //to call it again later.
3088:                              if(SetupPkt.EPDir == OUT_FROM_HOST)
3089:                              {
3090:                                  ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
3091:                              }
3092:                              else
3093:                              {
3094:                                  ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
3095:                              }
3096:           
3097:                              //Clear UOWN and remove the STALL condition.   
3098:                              //  In this case we also need to set the DTS bit to 1 so that
3099:                              //  it toggles to DATA0 the next time the application firmware
3100:                              //  calls USBTransferOnePacket() (or equivalent macro).  
3101:                              p->STAT.Val &= ~(_USIE | _BSTALL);  
3102:                              p->STAT.Val |= _DAT1;
3103:                              //Let the application firmware know a transaction just
3104:                              //got terminated by the host, and that it is now free to
3105:                              //re-arm the endpoint or do other tasks if desired.                                        
3106:                              USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
3107:                          }
3108:                          else
3109:                          {
3110:                              //Clear UOWN and remove the STALL condition.   
3111:                              //  In this case we also need to set the DTS bit to 1 so that
3112:                              //  it toggles to DATA0 the next time the application firmware
3113:                              //  calls USBTransferOnePacket() (or equivalent macro).  
3114:                              p->STAT.Val &= ~(_USIE | _BSTALL);  
3115:                              p->STAT.Val |= _DAT1;
3116:                          } 
3117:                      #endif //end of #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
3118:                      
3119:          			//Get a pointer to the appropriate UEPn register
3120:                      #if defined(__C32__)
3121:                          pUEP = (DWORD*)(&U1EP0);
3122:                          pUEP += (SetupPkt.EPNum*4);
3123:                      #else
3124:                          pUEP = (unsigned char*)(&U1EP0+SetupPkt.EPNum);
0137  0020     MOVLB 0x0
0138  0854     MOVF 0x54, W
0139  390F     ANDLW 0xF
013A  3E98     ADDLW 0x98
013B  00FA     MOVWF p
013C  300E     MOVLW 0xE
013D  01FB     CLRF 0x7B
013E  3DFB     ADDWFC 0x7B, F
013F  087A     MOVF p, W
0140  00E6     MOVWF pUEP
0141  087B     MOVF 0x7B, W
0142  00E7     MOVWF 0x67
3125:                      #endif
3126:          
3127:          			//Clear the STALL bit in the UEP register
3128:                      *pUEP &= ~UEP_STALL;            
0143  0866     MOVF pUEP, W
0144  0086     MOVWF FSR1L
0145  0867     MOVF 0x67, W
0146  0087     MOVWF FSR1H
0147  1001     BCF INDF1, 0x0
3129:                  }//end if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
3130:              }//end if (lots of checks for set/clear endpoint halt)
3131:          }//end USBStdFeatureReqHandler
0148  0008     RETURN
3132:          
3133:          
3134:          /** EOF USBDevice.c *****************************************************/
---  /home/chris/Dev/klondike/firmware/USB/CDC Device Driver/usb_function_cdc.c  ------------------------
1:             /********************************************************************************
2:               File Information:
3:                 FileName:       usb_function_cdc.c
4:                 Dependencies:   See INCLUDES section
5:                 Processor:      PIC18 or PIC24 USB Microcontrollers
6:                 Hardware:       The code is natively intended to be used on the following
7:                                 hardware platforms: PICDEM(TM) FS USB Demo Board,
8:                                 PIC18F87J50 FS USB Plug-In Module, or
9:                                 Explorer 16 + PIC24 USB PIM.  The firmware may be
10:                                modified for use on other USB platforms by editing the
11:                                HardwareProfile.h file.
12:                Complier:   Microchip C18 (for PIC18) or C30 (for PIC24)
13:                Company:        Microchip Technology, Inc.
14:            
15:                Software License Agreement:
16:            
17:                The software supplied herewith by Microchip Technology Incorporated
18:                (the "Company") for its PIC(R) Microcontroller is intended and
19:                supplied to you, the Company's customer, for use solely and
20:                exclusively on Microchip PIC Microcontroller products. The
21:                software is owned by the Company and/or its supplier, and is
22:                protected under applicable copyright laws. All rights are reserved.
23:                Any use in violation of the foregoing restrictions may subject the
24:                user to criminal sanctions under applicable laws, as well as to
25:                civil liability for the breach of the terms and conditions of this
26:                license.
27:            
28:                THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
29:                WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
30:                TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
31:                PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
32:                IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
33:                CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
34:                
35:              Summary:
36:                This file contains all of functions, macros, definitions, variables,
37:                datatypes, etc. that are required for usage with the CDC function
38:                driver. This file should be included in projects that use the CDC
39:                \function driver.
40:                
41:                
42:                
43:                This file is located in the "\<Install Directory\>\\Microchip\\USB\\CDC
44:                Device Driver" directory.
45:              Description:
46:                USB CDC Function Driver File
47:                
48:                This file contains all of functions, macros, definitions, variables,
49:                datatypes, etc. that are required for usage with the CDC function
50:                driver. This file should be included in projects that use the CDC
51:                \function driver.
52:                
53:                This file is located in the "\<Install Directory\>\\Microchip\\USB\\CDC
54:                Device Driver" directory.
55:                
56:                When including this file in a new project, this file can either be
57:                referenced from the directory in which it was installed or copied
58:                directly into the user application folder. If the first method is
59:                chosen to keep the file located in the folder in which it is installed
60:                then include paths need to be added so that the library and the
61:                application both know where to reference each others files. If the
62:                application folder is located in the same folder as the Microchip
63:                folder (like the current demo folders), then the following include
64:                paths need to be added to the application's project:
65:                
66:                ..\\Include
67:                
68:                .
69:                
70:                If a different directory structure is used, modify the paths as
71:                required. An example using absolute paths instead of relative paths
72:                would be the following:
73:                
74:                C:\\Microchip Solutions\\Microchip\\Include
75:                
76:                C:\\Microchip Solutions\\My Demo Application                                 
77:              ********************************************************************************/
78:            
79:            /********************************************************************
80:             Change History:
81:              Rev    Description
82:              ----   -----------
83:              2.3    Decricated the mUSBUSARTIsTxTrfReady() macro.  It is 
84:                     replaced by the USBUSARTIsTxTrfReady() function.
85:            
86:              2.6    Minor definition changes
87:            
88:              2.6a   No Changes
89:            
90:              2.7    Fixed error in the part support list of the variables section
91:                     where the address of the CDC variables are defined.  The 
92:                     PIC18F2553 was incorrectly named PIC18F2453 and the PIC18F4558
93:                     was incorrectly named PIC18F4458.
94:            
95:                     http://www.microchip.com/forums/fb.aspx?m=487397
96:            
97:              2.8    Minor change to CDCInitEP() to enhance ruggedness in
98:                     multithreaded usage scenarios.
99:              
100:             2.9b   Updated to implement optional support for DTS reporting.
101:           
102:           ********************************************************************/
103:           
104:           /** I N C L U D E S **********************************************************/
105:           #include "USB/usb.h"
106:           #include "USB/usb_function_cdc.h"
107:           #include "HardwareProfile.h"
108:           
109:           #ifdef USB_USE_CDC
110:           
111:           /** V A R I A B L E S ********************************************************/
112:           #if defined(__18CXX)
113:               //The cdc_data_rx[] and cdc_data_tx[] arrays and associated variables are used 
114:               //as USB packet buffers in this firmware.  Therefore, they must be located in
115:               //a USB module accessible portion of microcontroller RAM.
116:               #if defined(__18F14K50) || defined(__18F13K50) || defined(__18LF14K50) || defined(__18LF13K50) 
117:                   #pragma udata usbram2
118:               #elif defined(__18F2455) || defined(__18F2550) || defined(__18F4455) || defined(__18F4550)\
119:                   || defined(__18F2458) || defined(__18F2553) || defined(__18F4458) || defined(__18F4553)\
120:                   || defined(__18LF24K50) || defined(__18F24K50) || defined(__18LF25K50)\
121:                   || defined(__18F25K50) || defined(__18LF45K50) || defined(__18F45K50)
122:                   #pragma udata USB_VARIABLES=0x500
123:               #elif defined(__18F4450) || defined(__18F2450)
124:                   #pragma udata USB_VARIABLES=0x480
125:               #else
126:                   #pragma udata
127:               #endif
128:           #endif
129:           
130:           #if defined(__XC8)
131:               #if defined(_18F14K50) || defined(_18F13K50) || defined(_18LF14K50) || defined(_18LF13K50)
132:                   #define IN_DATA_BUFFER_ADDRESS 0x260
133:                   #define OUT_DATA_BUFFER_ADDRESS (IN_DATA_BUFFER_ADDRESS + CDC_DATA_IN_EP_SIZE)
134:                   #define LINE_CODING_ADDRESS (OUT_DATA_BUFFER_ADDRESS + CDC_DATA_OUT_EP_SIZE)
135:                   #define NOTICE_ADDRESS (LINE_CODING_ADDRESS + LINE_CODING_LENGTH)
136:           
137:                   #define IN_DATA_BUFFER_ADDRESS_TAG  @IN_DATA_BUFFER_ADDRESS
138:                   #define OUT_DATA_BUFFER_ADDRESS_TAG @OUT_DATA_BUFFER_ADDRESS
139:                   #define LINE_CODING_ADDRESS_TAG     @LINE_CODING_ADDRESS
140:                   #define NOTICE_ADDRESS_TAG          @NOTICE_ADDRESS
141:               #elif  defined(_18F2455)   || defined(_18F2550)   || defined(_18F4455)  || defined(_18F4550)\
142:                   || defined(_18F2458)   || defined(_18F2453)   || defined(_18F4558)  || defined(_18F4553)\
143:                   || defined(_18LF24K50) || defined(_18F24K50)  || defined(_18LF25K50)\
144:                   || defined(_18F25K50)  || defined(_18LF45K50) || defined(_18F45K50)
145:                   #define IN_DATA_BUFFER_ADDRESS 0x500
146:                   #define OUT_DATA_BUFFER_ADDRESS (IN_DATA_BUFFER_ADDRESS + CDC_DATA_IN_EP_SIZE)
147:                   #define LINE_CODING_ADDRESS (OUT_DATA_BUFFER_ADDRESS + CDC_DATA_OUT_EP_SIZE)
148:                   #define NOTICE_ADDRESS (LINE_CODING_ADDRESS + LINE_CODING_LENGTH)
149:           
150:                   #define IN_DATA_BUFFER_ADDRESS_TAG  @IN_DATA_BUFFER_ADDRESS
151:                   #define OUT_DATA_BUFFER_ADDRESS_TAG @OUT_DATA_BUFFER_ADDRESS
152:                   #define LINE_CODING_ADDRESS_TAG     @LINE_CODING_ADDRESS
153:                   #define NOTICE_ADDRESS_TAG          @NOTICE_ADDRESS
154:               #elif defined(_18F4450) || defined(_18F2450)
155:                   #define IN_DATA_BUFFER_ADDRESS 0x480
156:                   #define OUT_DATA_BUFFER_ADDRESS (IN_DATA_BUFFER_ADDRESS + CDC_DATA_IN_EP_SIZE)
157:                   #define LINE_CODING_ADDRESS (OUT_DATA_BUFFER_ADDRESS + CDC_DATA_OUT_EP_SIZE)
158:                   #define NOTICE_ADDRESS (LINE_CODING_ADDRESS + LINE_CODING_LENGTH)
159:           
160:                   #define IN_DATA_BUFFER_ADDRESS_TAG  @IN_DATA_BUFFER_ADDRESS
161:                   #define OUT_DATA_BUFFER_ADDRESS_TAG @OUT_DATA_BUFFER_ADDRESS
162:                   #define LINE_CODING_ADDRESS_TAG     @LINE_CODING_ADDRESS
163:                   #define NOTICE_ADDRESS_TAG          @NOTICE_ADDRESS
164:               #elif defined(_16F1459) || defined(_16LF1459) || defined(_16F1454) || defined(_16LF1454) || defined(_16F1455) || defined(_16LF1455)
165:                   #define IN_DATA_BUFFER_ADDRESS 0x2140
166:                   #define OUT_DATA_BUFFER_ADDRESS 0x2190
167:                   #define LINE_CODING_ADDRESS 0x20A0
168:                   #define NOTICE_ADDRESS (LINE_CODING_ADDRESS + LINE_CODING_LENGTH)
169:           
170:                   #define IN_DATA_BUFFER_ADDRESS_TAG  @IN_DATA_BUFFER_ADDRESS
171:                   #define OUT_DATA_BUFFER_ADDRESS_TAG @OUT_DATA_BUFFER_ADDRESS
172:                   #define LINE_CODING_ADDRESS_TAG     @LINE_CODING_ADDRESS
173:                   #define NOTICE_ADDRESS_TAG          @NOTICE_ADDRESS
174:               #else
175:                   #define IN_DATA_BUFFER_ADDRESS_TAG
176:                   #define OUT_DATA_BUFFER_ADDRESS_TAG
177:                   #define LINE_CODING_ADDRESS_TAG
178:                   #define NOTICE_ADDRESS_TAG
179:               #endif
180:           #else
181:               #define IN_DATA_BUFFER_ADDRESS_TAG
182:               #define OUT_DATA_BUFFER_ADDRESS_TAG
183:               #define LINE_CODING_ADDRESS_TAG
184:               #define NOTICE_ADDRESS_TAG
185:           #endif
186:           
187:           volatile FAR unsigned char cdc_data_tx[CDC_DATA_IN_EP_SIZE] IN_DATA_BUFFER_ADDRESS_TAG;
188:           volatile FAR unsigned char cdc_data_rx[CDC_DATA_OUT_EP_SIZE] OUT_DATA_BUFFER_ADDRESS_TAG;
189:           
190:           LINE_CODING line_coding LINE_CODING_ADDRESS_TAG;    // Buffer to store line coding information
191:           volatile FAR CDC_NOTICE cdc_notice NOTICE_ADDRESS_TAG;
192:           
193:           #if defined(USB_CDC_SUPPORT_DSR_REPORTING)
194:               SERIAL_STATE_NOTIFICATION SerialStatePacket;
195:           #endif
196:           
197:           #if defined(__18CXX)
198:               #pragma udata
199:           #endif
200:           
201:           BYTE cdc_rx_len;            // total rx length
202:           
203:           BYTE cdc_trf_state;         // States are defined cdc.h
204:           POINTER pCDCSrc;            // Dedicated source pointer
205:           POINTER pCDCDst;            // Dedicated destination pointer
206:           BYTE cdc_tx_len;            // total tx length
207:           BYTE cdc_mem_type;          // _ROM, _RAM
208:           
209:           USB_HANDLE CDCDataOutHandle;
210:           USB_HANDLE CDCDataInHandle;
211:           
212:           
213:           CONTROL_SIGNAL_BITMAP control_signal_bitmap;
214:           DWORD BaudRateGen;			// BRG value calculated from baudrate
215:           
216:           #if defined(USB_CDC_SUPPORT_DSR_REPORTING)
217:               BM_SERIAL_STATE SerialStateBitmap;
218:               BM_SERIAL_STATE OldSerialStateBitmap;
219:               USB_HANDLE CDCNotificationInHandle;
220:           #endif
221:           
222:           /**************************************************************************
223:             SEND_ENCAPSULATED_COMMAND and GET_ENCAPSULATED_RESPONSE are required
224:             requests according to the CDC specification.
225:             However, it is not really being used here, therefore a dummy buffer is
226:             used for conformance.
227:            **************************************************************************/
228:           #define dummy_length    0x08
229:           BYTE_VAL dummy_encapsulated_cmd_response[dummy_length];
230:           
231:           #if defined(USB_CDC_SET_LINE_CODING_HANDLER)
232:           CTRL_TRF_RETURN USB_CDC_SET_LINE_CODING_HANDLER(CTRL_TRF_PARAMS);
233:           #endif
234:           
235:           /** P R I V A T E  P R O T O T Y P E S ***************************************/
236:           void USBCDCSetLineCoding(void);
237:           
238:           /** D E C L A R A T I O N S **************************************************/
239:           //#pragma code
240:           
241:           /** C L A S S  S P E C I F I C  R E Q ****************************************/
242:           /******************************************************************************
243:            	Function:
244:            		void USBCheckCDCRequest(void)
245:            
246:            	Description:
247:            		This routine checks the most recently received SETUP data packet to 
248:            		see if the request is specific to the CDC class.  If the request was
249:            		a CDC specific request, this function will take care of handling the
250:            		request and responding appropriately.
251:            		
252:            	PreCondition:
253:            		This function should only be called after a control transfer SETUP
254:            		packet has arrived from the host.
255:           
256:           	Parameters:
257:           		None
258:           		
259:           	Return Values:
260:           		None
261:           		
262:           	Remarks:
263:           		This function does not change status or do anything if the SETUP packet
264:           		did not contain a CDC class specific request.		 
265:             *****************************************************************************/
266:           void USBCheckCDCRequest(void)
267:           {
268:               /*
269:                * If request recipient is not an interface then return
270:                */
271:               if(SetupPkt.Recipient != USB_SETUP_RECIPIENT_INTERFACE_BITFIELD) return;
17B0  0850     MOVF SetupPkt, W
17B1  391F     ANDLW 0x1F
17B2  3A01     XORLW 0x1
17B3  1D03     BTFSS STATUS, 0x2
17B4  0008     RETURN
272:           
273:               /*
274:                * If request type is not class-specific then return
275:                */
276:               if(SetupPkt.RequestType != USB_SETUP_TYPE_CLASS_BITFIELD) return;
17B5  0E50     SWAPF SetupPkt, W
17B6  0C89     RRF WREG, F
17B7  3903     ANDLW 0x3
17B8  3A01     XORLW 0x1
17B9  1D03     BTFSS STATUS, 0x2
17BA  0008     RETURN
277:           
278:               /*
279:                * Interface ID must match interface numbers associated with
280:                * CDC class, else return
281:                */
282:               if((SetupPkt.bIntfID != CDC_COMM_INTF_ID)&&
283:                  (SetupPkt.bIntfID != CDC_DATA_INTF_ID)) return;
17BB  0854     MOVF 0x54, W
17BC  1903     BTFSC STATUS, 0x2
17BD  2FE8     GOTO 0x7E8
17BE  0354     DECF 0x54, W
17BF  1D03     BTFSS STATUS, 0x2
17C0  0008     RETURN
17C1  2FE8     GOTO 0x7E8
284:               
285:               switch(SetupPkt.bRequest)
17E8  0851     MOVF 0x51, W
17E9  3A00     XORLW 0x0
17EA  1903     BTFSC STATUS, 0x2
17EB  2FC2     GOTO 0x7C2
17EC  3A01     XORLW 0x1
17ED  1903     BTFSC STATUS, 0x2
17EE  2FCA     GOTO 0x7CA
17EF  3A21     XORLW 0x21
17F0  1903     BTFSC STATUS, 0x2
17F1  2FCD     GOTO 0x7CD
17F2  3A01     XORLW 0x1
17F3  1903     BTFSC STATUS, 0x2
17F4  2FDB     GOTO 0x7DB
17F5  3A03     XORLW 0x3
17F6  1903     BTFSC STATUS, 0x2
17F7  2FE6     GOTO 0x7E6
17F8  2FF9     GOTO 0x7F9
286:               {
287:                   //****** These commands are required ******//
288:                   case SEND_ENCAPSULATED_COMMAND:
289:                    //send the packet
290:                       inPipes[0].pSrc.bRam = (BYTE*)&dummy_encapsulated_cmd_response;
17C2  27FA     CALL 0x7FA
291:                       inPipes[0].wCount.Val = dummy_length;
17C3  3008     MOVLW 0x8
17C4  00E1     MOVWF 0x61
17C5  01E2     CLRF 0x62
292:                       inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;
17C6  1460     BSF event, 0x0
293:                       inPipes[0].info.bits.busy = 1;
17C7  0022     MOVLB 0x2
17C8  17E0     BSF event, 0x7
294:                       break;
17C9  0008     RETURN
17CA  27FA     CALL 0x7FA
17CB  3197     MOVLP 0x17
295:                   case GET_ENCAPSULATED_RESPONSE:
296:                       // Populate dummy_encapsulated_cmd_response first.
297:                       inPipes[0].pSrc.bRam = (BYTE*)&dummy_encapsulated_cmd_response;
17CC  2FC7     GOTO 0x7C7
298:                       inPipes[0].info.bits.busy = 1;
299:                       break;
300:                   //****** End of required commands ******//
301:           
302:                   #if defined(USB_CDC_SUPPORT_ABSTRACT_CONTROL_MANAGEMENT_CAPABILITIES_D1)
303:                   case SET_LINE_CODING:
304:                       outPipes[0].wCount.Val = SetupPkt.wLength;
17CD  0857     MOVF 0x57, W
17CE  0022     MOVLB 0x2
17CF  00B5     MOVWF 0x35
17D0  0020     MOVLB 0x0
17D1  0856     MOVF 0x56, W
17D2  0022     MOVLB 0x2
17D3  00B4     MOVWF 0x34
305:                       outPipes[0].pDst.bRam = (BYTE*)LINE_CODING_TARGET;
17D4  3020     MOVLW 0x20
17D5  00B1     MOVWF 0x31
17D6  3001     MOVLW 0x1
17D7  00B2     MOVWF 0x32
306:                       outPipes[0].pFunc = LINE_CODING_PFUNC;
17D8  01B6     CLRF 0x36
307:                       outPipes[0].info.bits.busy = 1;
17D9  17B3     BSF 0x33, 0x7
308:                       break;
17DA  0008     RETURN
309:                       
310:                   case GET_LINE_CODING:
311:                       USBEP0SendRAMPtr(
17DB  3020     MOVLW 0x20
17DC  0022     MOVLB 0x2
17DD  00DE     MOVWF 0x5E
17DE  3001     MOVLW 0x1
17DF  00DF     MOVWF 0x5F
17E0  3007     MOVLW 0x7
17E1  00E1     MOVWF 0x61
17E2  01E2     CLRF 0x62
17E3  30C1     MOVLW 0xC1
17E4  00E0     MOVWF event
312:                           (BYTE*)&line_coding,
313:                           LINE_CODING_LENGTH,
314:                           USB_EP0_INCLUDE_ZERO);
315:                       break;
17E5  0008     RETURN
316:           
317:                   case SET_CONTROL_LINE_STATE:
318:                       control_signal_bitmap._byte = (BYTE)SetupPkt.W_Value.v[0];
17E6  0852     MOVF 0x52, W
17E7  2FC7     GOTO 0x7C7
319:                       //------------------------------------------------------------------            
320:                       //One way to control the RTS pin is to allow the USB host to decide the value
321:                       //that should be output on the RTS pin.  Although RTS and CTS pin functions
322:                       //are technically intended for UART hardware based flow control, some legacy
323:                       //UART devices use the RTS pin like a "general purpose" output pin 
324:                       //from the PC host.  In this usage model, the RTS pin is not related
325:                       //to flow control for RX/TX.
326:                       //In this scenario, the USB host would want to be able to control the RTS
327:                       //pin, and the below line of code should be uncommented.
328:                       //However, if the intention is to implement true RTS/CTS flow control
329:                       //for the RX/TX pair, then this application firmware should override
330:                       //the USB host's setting for RTS, and instead generate a real RTS signal,
331:                       //based on the amount of remaining buffer space available for the 
332:                       //actual hardware UART of this microcontroller.  In this case, the 
333:                       //below code should be left commented out, but instead RTS should be 
334:                       //controlled in the application firmware reponsible for operating the 
335:                       //hardware UART of this microcontroller.
336:                       //---------            
337:                       //CONFIGURE_RTS(control_signal_bitmap.CARRIER_CONTROL);  
338:                       //------------------------------------------------------------------            
339:                       
340:                       #if defined(USB_CDC_SUPPORT_DTR_SIGNALING)
341:                           if(control_signal_bitmap.DTE_PRESENT == 1)
342:                           {
343:                               UART_DTR = USB_CDC_DTR_ACTIVE_LEVEL;
344:                           }
345:                           else
346:                           {
347:                               UART_DTR = (USB_CDC_DTR_ACTIVE_LEVEL ^ 1);
348:                           }        
349:                       #endif
350:                       inPipes[0].info.bits.busy = 1;
351:                       break;
352:                   #endif
353:           
354:                   #if defined(USB_CDC_SUPPORT_ABSTRACT_CONTROL_MANAGEMENT_CAPABILITIES_D2)
355:                   case SEND_BREAK:                        // Optional
356:                       inPipes[0].info.bits.busy = 1;
357:           			if (SetupPkt.wValue == 0xFFFF)  //0xFFFF means send break indefinitely until a new SEND_BREAK command is received
358:           			{
359:           				UART_Tx = 0;       // Prepare to drive TX low (for break signalling)
360:           				UART_TRISTx = 0;   // Make sure TX pin configured as an output
361:           				UART_ENABLE = 0;   // Turn off USART (to relinquish TX pin control)
362:           			}
363:           			else if (SetupPkt.wValue == 0x0000) //0x0000 means stop sending indefinite break 
364:           			{
365:               			UART_ENABLE = 1;   // turn on USART
366:           				UART_TRISTx = 1;   // Make TX pin an input
367:           			}
368:           			else
369:           			{
370:                           //Send break signalling on the pin for (SetupPkt.wValue) milliseconds
371:                           UART_SEND_BREAK();
372:           			}
373:                       break;
374:                   #endif
375:                   default:
376:                       break;
377:               }//end switch(SetupPkt.bRequest)
378:           
379:           }//end USBCheckCDCRequest
17F9  0008     RETURN
380:           
381:           /** U S E R  A P I ***********************************************************/
382:           
383:           /**************************************************************************
384:             Function:
385:                   void CDCInitEP(void)
386:               
387:             Summary:
388:               This function initializes the CDC function driver. This function should
389:               be called after the SET_CONFIGURATION command (ex: within the context of
390:               the USBCBInitEP() function).
391:             Description:
392:               This function initializes the CDC function driver. This function sets
393:               the default line coding (baud rate, bit parity, number of data bits,
394:               and format). This function also enables the endpoints and prepares for
395:               the first transfer from the host.
396:               
397:               This function should be called after the SET_CONFIGURATION command.
398:               This is most simply done by calling this function from the
399:               USBCBInitEP() function.
400:               
401:               Typical Usage:
402:               <code>
403:                   void USBCBInitEP(void)
404:                   {
405:                       CDCInitEP();
406:                   }
407:               </code>
408:             Conditions:
409:               None
410:             Remarks:
411:               None                                                                   
412:             **************************************************************************/
413:           void CDCInitEP(void)
414:           {
415:              	//Abstract line coding information
416:              	line_coding.dwDTERate.Val = 19200;      // baud rate
034A  0022     MOVLB 0x2
034B  304B     MOVLW 0x4B
034C  01A3     CLRF 0x23
034D  01A2     CLRF 0x22
034E  00A1     MOVWF 0x21
0350  01A0     CLRF BDT
417:              	line_coding.bCharFormat = 0x00;             // 1 stop bit
0351  01A4     CLRF 0x24
418:              	line_coding.bParityType = 0x00;             // None
0352  01A5     CLRF 0x25
419:              	line_coding.bDataBits = 0x08;               // 5,6,7,8, or 16
034F  3008     MOVLW 0x8
0353  00A6     MOVWF 0x26
420:           
421:               cdc_rx_len = 0;
0355  01D3     CLRF 0x53
422:               
423:               /*
424:                * Do not have to init Cnt of IN pipes here.
425:                * Reason:  Number of BYTEs to send to the host
426:                *          varies from one transaction to
427:                *          another. Cnt should equal the exact
428:                *          number of BYTEs to transmit for
429:                *          a given IN transaction.
430:                *          This number of BYTEs will only
431:                *          be known right before the data is
432:                *          sent.
433:                */
434:               USBEnableEndpoint(CDC_COMM_EP,USB_IN_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
0354  301A     MOVLW 0x1A
0356  00F4     MOVWF i_750
0357  3001     MOVLW 0x1
0358  236A     CALL 0x36A
0359  3180     MOVLP 0x0
435:               USBEnableEndpoint(CDC_DATA_EP,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
035A  301E     MOVLW 0x1E
035B  00F4     MOVWF i_750
035C  3002     MOVLW 0x2
035D  236A     CALL 0x36A
035E  3180     MOVLP 0x0
436:           
437:               CDCDataOutHandle = USBRxOnePacket(CDC_DATA_EP,(BYTE*)&cdc_data_rx,sizeof(cdc_data_rx));
035F  30A0     MOVLW 0xA0
0360  01F0     CLRF dir
0361  00F1     MOVWF data
0362  3040     MOVLW 0x40
0363  00F2     MOVWF p
0364  3002     MOVLW 0x2
0365  23B0     CALL 0x3B0
0366  00C7     MOVWF 0x47
438:               CDCDataInHandle = NULL;
0367  01C6     CLRF 0x46
439:           
440:               #if defined(USB_CDC_SUPPORT_DSR_REPORTING)
441:                 	CDCNotificationInHandle = NULL;
442:                   mInitDTSPin();  //Configure DTS as a digital input
443:                 	SerialStateBitmap.byte = 0x00;
444:                 	OldSerialStateBitmap.byte = !SerialStateBitmap.byte;    //To force firmware to send an initial serial state packet to the host.
445:                   //Prepare a SerialState notification element packet (contains info like DSR state)
446:                   SerialStatePacket.bmRequestType = 0xA1; //Always 0xA1 for this type of packet.
447:                   SerialStatePacket.bNotification = SERIAL_STATE;
448:                   SerialStatePacket.wValue = 0x0000;  //Always 0x0000 for this type of packet
449:                   SerialStatePacket.wIndex = CDC_COMM_INTF_ID;  //Interface number  
450:                   SerialStatePacket.SerialState.byte = 0x00;
451:                   SerialStatePacket.Reserved = 0x00;
452:                   SerialStatePacket.wLength = 0x02;   //Always 2 bytes for this type of packet    
453:                   CDCNotificationHandler();
454:             	#endif
455:             	
456:             	#if defined(USB_CDC_SUPPORT_DTR_SIGNALING)
457:             	    mInitDTRPin();
458:             	#endif
459:             	
460:             	#if defined(USB_CDC_SUPPORT_HARDWARE_FLOW_CONTROL)
461:             	    mInitRTSPin();
462:             	    mInitCTSPin();
463:             	#endif
464:               
465:               cdc_trf_state = CDC_TX_READY;
0368  01D4     CLRF 0x54
466:           }//end CDCInitEP
0369  0008     RETURN
467:           
468:           
469:           /**************************************************************************
470:             Function: void CDCNotificationHandler(void)
471:             Summary: Checks for changes in DSR status and reports them to the USB host.
472:             Description: Checks for changes in DSR pin state and reports any changes
473:                          to the USB host. 
474:             Conditions: CDCInitEP() must have been called previously, prior to calling
475:                         CDCNotificationHandler() for the first time.
476:             Remarks:
477:               This function is only implemented and needed when the 
478:               USB_CDC_SUPPORT_DSR_REPORTING option has been enabled.  If the function is
479:               enabled, it should be called periodically to sample the DSR pin and feed
480:               the information to the USB host.  This can be done by calling 
481:               CDCNotificationHandler() by itself, or, by calling CDCTxService() which
482:               also calls CDCNotificationHandler() internally, when appropriate.
483:             **************************************************************************/
484:           #if defined(USB_CDC_SUPPORT_DSR_REPORTING)
485:           void CDCNotificationHandler(void)
486:           {
487:               //Check the DTS I/O pin and if a state change is detected, notify the 
488:               //USB host by sending a serial state notification element packet.
489:               if(UART_DTS == USB_CDC_DSR_ACTIVE_LEVEL) //UART_DTS must be defined to be an I/O pin in the hardware profile to use the DTS feature (ex: "PORTXbits.RXY")
490:               {
491:                   SerialStateBitmap.bits.DSR = 1;
492:               }  
493:               else
494:               {
495:                   SerialStateBitmap.bits.DSR = 0;
496:               }        
497:               
498:               //If the state has changed, and the endpoint is available, send a packet to
499:               //notify the hUSB host of the change.
500:               if((SerialStateBitmap.byte != OldSerialStateBitmap.byte) && (!USBHandleBusy(CDCNotificationInHandle)))
501:               {
502:                   //Copy the updated value into the USB packet buffer to send.
503:                   SerialStatePacket.SerialState.byte = SerialStateBitmap.byte;
504:                   //We don't need to write to the other bytes in the SerialStatePacket USB
505:                   //buffer, since they don't change and will always be the same as our
506:                   //initialized value.
507:           
508:                   //Send the packet over USB to the host.
509:                   CDCNotificationInHandle = USBTransferOnePacket(CDC_COMM_EP, IN_TO_HOST, (BYTE*)&SerialStatePacket, sizeof(SERIAL_STATE_NOTIFICATION));
510:                   
511:                   //Save the old value, so we can detect changes later.
512:                   OldSerialStateBitmap.byte = SerialStateBitmap.byte;
513:               }    
514:           }//void CDCNotificationHandler(void)    
515:           #else
516:               #define CDCNotificationHandler() {}
517:           #endif
518:           
519:           
520:           /**********************************************************************************
521:             Function:
522:               BOOL USBCDCEventHandler(USB_EVENT event, void *pdata, WORD size)
523:               
524:             Summary:
525:               Handles events from the USB stack, which may have an effect on the CDC 
526:               endpoint(s).
527:           
528:             Description:
529:               Handles events from the USB stack.  This function should be called when 
530:               there is a USB event that needs to be processed by the CDC driver.
531:               
532:             Conditions:
533:               Value of input argument 'len' should be smaller than the maximum
534:               endpoint size responsible for receiving bulk data from USB host for CDC
535:               class. Input argument 'buffer' should point to a buffer area that is
536:               bigger or equal to the size specified by 'len'.
537:             Input:
538:               event - the type of event that occured
539:               pdata - pointer to the data that caused the event
540:               size - the size of the data that is pointed to by pdata
541:                                                                                              
542:             **********************************************************************************/
543:           BOOL USBCDCEventHandler(USB_EVENT event, void *pdata, WORD size)
544:           {
545:               switch( (INT)event )
546:               {  
547:                   case EVENT_TRANSFER_TERMINATED:
548:                       if(pdata == CDCDataOutHandle)
549:                       {
550:                           CDCDataOutHandle = USBRxOnePacket(CDC_DATA_EP,(BYTE*)&cdc_data_rx,sizeof(cdc_data_rx));  
551:                       }
552:                       if(pdata == CDCDataInHandle)
553:                       {
554:                           //flush all of the data in the CDC buffer
555:                           cdc_trf_state = CDC_TX_READY;
556:                           cdc_tx_len = 0;
557:                       }
558:                       break;
559:                   default:
560:                       return FALSE;
561:               }      
562:               return TRUE; 
563:           }
564:           
565:           /**********************************************************************************
566:             Function:
567:                   BYTE getsUSBUSART(char *buffer, BYTE len)
568:               
569:             Summary:
570:               getsUSBUSART copies a string of BYTEs received through USB CDC Bulk OUT
571:               endpoint to a user's specified location. It is a non-blocking function.
572:               It does not wait for data if there is no data available. Instead it
573:               returns '0' to notify the caller that there is no data available.
574:           
575:             Description:
576:               getsUSBUSART copies a string of BYTEs received through USB CDC Bulk OUT
577:               endpoint to a user's specified location. It is a non-blocking function.
578:               It does not wait for data if there is no data available. Instead it
579:               returns '0' to notify the caller that there is no data available.
580:               
581:               Typical Usage:
582:               <code>
583:                   BYTE numBytes;
584:                   BYTE buffer[64]
585:               
586:                   numBytes = getsUSBUSART(buffer,sizeof(buffer)); //until the buffer is free.
587:                   if(numBytes \> 0)
588:                   {
589:                       //we received numBytes bytes of data and they are copied into
590:                       //  the "buffer" variable.  We can do something with the data
591:                       //  here.
592:                   }
593:               </code>
594:             Conditions:
595:               Value of input argument 'len' should be smaller than the maximum
596:               endpoint size responsible for receiving bulk data from USB host for CDC
597:               class. Input argument 'buffer' should point to a buffer area that is
598:               bigger or equal to the size specified by 'len'.
599:             Input:
600:               buffer -  Pointer to where received BYTEs are to be stored
601:               len -     The number of BYTEs expected.
602:                                                                                              
603:             **********************************************************************************/
604:           BYTE getsUSBUSART(char *buffer, BYTE len)
605:           {
0888  00A9     MOVWF 0x29
606:               cdc_rx_len = 0;
0889  0022     MOVLB 0x2
088A  01D3     CLRF 0x53
607:               
608:               if(!USBHandleBusy(CDCDataOutHandle))
088B  0847     MOVF 0x47, W
088C  1903     BTFSC STATUS, 0x2
088D  2897     GOTO 0x97
088E  0847     MOVF 0x47, W
088F  0086     MOVWF FSR1L
0890  0187     CLRF FSR1H
0891  0D01     RLF INDF1, W
0892  0D01     RLF INDF1, W
0893  3901     ANDLW 0x1
0894  0021     MOVLB 0x1
0895  00AA     MOVWF 0x2A
0896  2899     GOTO 0x99
0897  0021     MOVLB 0x1
0898  01AA     CLRF 0x2A
0899  01AB     CLRF 0x2B
089A  082B     MOVF 0x2B, W
089B  042A     IORWF 0x2A, W
089C  1D03     BTFSS STATUS, 0x2
089D  28D1     GOTO 0xD1
609:               {
610:                   /*
611:                    * Adjust the expected number of BYTEs to equal
612:                    * the actual number of BYTEs received.
613:                    */
614:                   if(len > USBHandleGetLength(CDCDataOutHandle))
089E  0022     MOVLB 0x2
089F  0A47     INCF 0x47, W
08A0  0086     MOVWF FSR1L
08A1  0187     CLRF FSR1H
08A2  0021     MOVLB 0x1
08A3  0827     MOVF 0x27, W
08A4  0201     SUBWF INDF1, W
08A5  1803     BTFSC STATUS, 0x0
08A6  28AD     GOTO 0xAD
615:                       len = USBHandleGetLength(CDCDataOutHandle);
08A7  0022     MOVLB 0x2
08A8  0847     MOVF 0x47, W
08A9  0086     MOVWF FSR1L
08AA  3F41     MOVIW [1]FSR1
08AB  0021     MOVLB 0x1
08AC  00A7     MOVWF 0x27
616:                   
617:                   /*
618:                    * Copy data from dual-ram buffer to user's buffer
619:                    */
620:                   for(cdc_rx_len = 0; cdc_rx_len < len; cdc_rx_len++)
08AD  0022     MOVLB 0x2
08AE  01D3     CLRF 0x53
08AF  0021     MOVLB 0x1
08B0  0827     MOVF 0x27, W
08B1  0022     MOVLB 0x2
08B2  0253     SUBWF 0x53, W
08B3  1803     BTFSC STATUS, 0x0
08B4  28C6     GOTO 0xC6
08C4  0AD3     INCF 0x53, F
08C5  28AF     GOTO 0xAF
621:                       buffer[cdc_rx_len] = cdc_data_rx[cdc_rx_len];
08B5  0853     MOVF 0x53, W
08B6  0021     MOVLB 0x1
08B7  0729     ADDWF 0x29, W
08B8  00A8     MOVWF 0x28
08B9  0086     MOVWF FSR1L
08BA  3003     MOVLW 0x3
08BB  0087     MOVWF FSR1H
08BC  0022     MOVLB 0x2
08BD  0853     MOVF 0x53, W
08BE  3EA0     ADDLW 0xA0
08BF  0084     MOVWF FSR0L
08C0  3002     MOVLW 0x2
08C1  0085     MOVWF FSR0H
08C2  0800     MOVF INDF0, W
08C3  0081     MOVWF INDF1
622:           
623:                   /*
624:                    * Prepare dual-ram buffer for next OUT transaction
625:                    */
626:           
627:                   CDCDataOutHandle = USBRxOnePacket(CDC_DATA_EP,(BYTE*)&cdc_data_rx,sizeof(cdc_data_rx));
08C6  0021     MOVLB 0x1
08C7  30A0     MOVLW 0xA0
08C8  01A0     CLRF BDT
08C9  00A1     MOVWF 0x21
08CA  3040     MOVLW 0x40
08CB  00A2     MOVWF 0x22
08CC  3002     MOVLW 0x2
08CD  3186     MOVLP 0x6
08CE  2616     CALL 0x616
08CF  0022     MOVLB 0x2
08D0  00C7     MOVWF 0x47
628:           
629:               }//end if
630:               
631:               return cdc_rx_len;
08D1  0022     MOVLB 0x2
08D2  0853     MOVF 0x53, W
632:               
633:           }//end getsUSBUSART
08D3  0008     RETURN
634:           
635:           /******************************************************************************
636:             Function:
637:           	void putUSBUSART(char *data, BYTE length)
638:           		
639:             Summary:
640:               putUSBUSART writes an array of data to the USB. Use this version, is
641:               capable of transfering 0x00 (what is typically a NULL character in any of
642:               the string transfer functions).
643:           
644:             Description:
645:               putUSBUSART writes an array of data to the USB. Use this version, is
646:               capable of transfering 0x00 (what is typically a NULL character in any of
647:               the string transfer functions).
648:               
649:               Typical Usage:
650:               <code>
651:                   if(USBUSARTIsTxTrfReady())
652:                   {
653:                       char data[] = {0x00, 0x01, 0x02, 0x03, 0x04};
654:                       putUSBUSART(data,5);
655:                   }
656:               </code>
657:               
658:               The transfer mechanism for device-to-host(put) is more flexible than
659:               host-to-device(get). It can handle a string of data larger than the
660:               maximum size of bulk IN endpoint. A state machine is used to transfer a
661:               \long string of data over multiple USB transactions. CDCTxService()
662:               must be called periodically to keep sending blocks of data to the host.
663:           
664:             Conditions:
665:               USBUSARTIsTxTrfReady() must return TRUE. This indicates that the last
666:               transfer is complete and is ready to receive a new block of data. The
667:               string of characters pointed to by 'data' must equal to or smaller than
668:               255 BYTEs.
669:           
670:             Input:
671:               char *data - pointer to a RAM array of data to be transfered to the host
672:               BYTE length - the number of bytes to be transfered (must be less than 255).
673:           		
674:            *****************************************************************************/
675:           void putUSBUSART(char *data, BYTE  length)
676:           {
677:               /*
678:                * User should have checked that cdc_trf_state is in CDC_TX_READY state
679:                * before calling this function.
680:                * As a safety precaution, this fuction checks the state one more time
681:                * to make sure it does not override any pending transactions.
682:                *
683:                * Currently it just quits the routine without reporting any errors back
684:                * to the user.
685:                *
686:                * Bottomline: User MUST make sure that USBUSARTIsTxTrfReady()==1
687:                *             before calling this function!
688:                * Example:
689:                * if(USBUSARTIsTxTrfReady())
690:                *     putUSBUSART(pData, Length);
691:                *
692:                * IMPORTANT: Never use the following blocking while loop to wait:
693:                * while(!USBUSARTIsTxTrfReady())
694:                *     putUSBUSART(pData, Length);
695:                *
696:                * The whole firmware framework is written based on cooperative
697:                * multi-tasking and a blocking code is not acceptable.
698:                * Use a state machine instead.
699:                */
700:               USBMaskInterrupts();
1708  00A1     MOVWF 0x21
1709  1112     BCF PIR2, 0x2
701:               if(cdc_trf_state == CDC_TX_READY)
170A  0022     MOVLB 0x2
170B  08D4     MOVF 0x54, F
170C  1D03     BTFSS STATUS, 0x2
170D  2F1A     GOTO 0x71A
702:               {
703:                   mUSBUSARTTxRam((BYTE*)data, length);     // See cdc.h
170E  0021     MOVLB 0x1
170F  0821     MOVF 0x21, W
1710  0023     MOVLB 0x3
1711  00AA     MOVWF 0x2A
1712  0021     MOVLB 0x1
1713  0820     MOVF BDT, W
1714  0022     MOVLB 0x2
1715  00D5     MOVWF 0x55
1716  01D2     CLRF 0x52
1717  0AD2     INCF 0x52, F
1718  01D4     CLRF 0x54
1719  0AD4     INCF 0x54, F
704:               }
705:               USBUnmaskInterrupts();
171A  0021     MOVLB 0x1
171B  1512     BSF PIR2, 0x2
706:           }//end putUSBUSART
171C  0008     RETURN
707:           
708:           /******************************************************************************
709:           	Function:
710:           		void putsUSBUSART(char *data)
711:           		
712:             Summary:
713:               putsUSBUSART writes a string of data to the USB including the null
714:               character. Use this version, 'puts', to transfer data from a RAM buffer.
715:           
716:             Description:
717:               putsUSBUSART writes a string of data to the USB including the null
718:               character. Use this version, 'puts', to transfer data from a RAM buffer.
719:               
720:               Typical Usage:
721:               <code>
722:                   if(USBUSARTIsTxTrfReady())
723:                   {
724:                       char data[] = "Hello World";
725:                       putsUSBUSART(data);
726:                   }
727:               </code>
728:               
729:               The transfer mechanism for device-to-host(put) is more flexible than
730:               host-to-device(get). It can handle a string of data larger than the
731:               maximum size of bulk IN endpoint. A state machine is used to transfer a
732:               \long string of data over multiple USB transactions. CDCTxService()
733:               must be called periodically to keep sending blocks of data to the host.
734:           
735:             Conditions:
736:               USBUSARTIsTxTrfReady() must return TRUE. This indicates that the last
737:               transfer is complete and is ready to receive a new block of data. The
738:               string of characters pointed to by 'data' must equal to or smaller than
739:               255 BYTEs.
740:           
741:             Input:
742:               char *data -  null\-terminated string of constant data. If a
743:                                       null character is not found, 255 BYTEs of data
744:                                       will be transferred to the host.
745:           		
746:            *****************************************************************************/
747:            
748:           void putsUSBUSART(char *data)
749:           {
750:               BYTE len;
751:               char *pData;
752:           
753:               /*
754:                * User should have checked that cdc_trf_state is in CDC_TX_READY state
755:                * before calling this function.
756:                * As a safety precaution, this fuction checks the state one more time
757:                * to make sure it does not override any pending transactions.
758:                *
759:                * Currently it just quits the routine without reporting any errors back
760:                * to the user.
761:                *
762:                * Bottomline: User MUST make sure that USBUSARTIsTxTrfReady()==1
763:                *             before calling this function!
764:                * Example:
765:                * if(USBUSARTIsTxTrfReady())
766:                *     putsUSBUSART(pData, Length);
767:                *
768:                * IMPORTANT: Never use the following blocking while loop to wait:
769:                * while(!USBUSARTIsTxTrfReady())
770:                *     putsUSBUSART(pData);
771:                *
772:                * The whole firmware framework is written based on cooperative
773:                * multi-tasking and a blocking code is not acceptable.
774:                * Use a state machine instead.
775:                */
776:               USBMaskInterrupts();
777:               if(cdc_trf_state != CDC_TX_READY)
778:               {
779:                   USBUnmaskInterrupts();
780:                   return;
781:               }
782:               
783:               /*
784:                * While loop counts the number of BYTEs to send including the
785:                * null character.
786:                */
787:               len = 0;
788:               pData = data;
789:               do
790:               {
791:                   len++;
792:                   if(len == 255) break;       // Break loop once max len is reached.
793:               }while(*pData++);
794:               
795:               /*
796:                * Second piece of information (length of data to send) is ready.
797:                * Call mUSBUSARTTxRam to setup the transfer.
798:                * The actual transfer process will be handled by CDCTxService(),
799:                * which should be called once per Main Program loop.
800:                */
801:               mUSBUSARTTxRam((BYTE*)data, len);     // See cdc.h
802:               USBUnmaskInterrupts();
803:           }//end putsUSBUSART
804:           
805:           /**************************************************************************
806:             Function:
807:                   void putrsUSBUSART(const ROM char *data)
808:               
809:             Summary:
810:               putrsUSBUSART writes a string of data to the USB including the null
811:               character. Use this version, 'putrs', to transfer data literals and
812:               data located in program memory.
813:           
814:             Description:
815:               putrsUSBUSART writes a string of data to the USB including the null
816:               character. Use this version, 'putrs', to transfer data literals and
817:               data located in program memory.
818:               
819:               Typical Usage:
820:               <code>
821:                   if(USBUSARTIsTxTrfReady())
822:                   {
823:                       putrsUSBUSART("Hello World");
824:                   }
825:               </code>
826:               
827:               The transfer mechanism for device-to-host(put) is more flexible than
828:               host-to-device(get). It can handle a string of data larger than the
829:               maximum size of bulk IN endpoint. A state machine is used to transfer a
830:               \long string of data over multiple USB transactions. CDCTxService()
831:               must be called periodically to keep sending blocks of data to the host.
832:           
833:             Conditions:
834:               USBUSARTIsTxTrfReady() must return TRUE. This indicates that the last
835:               transfer is complete and is ready to receive a new block of data. The
836:               string of characters pointed to by 'data' must equal to or smaller than
837:               255 BYTEs.
838:           
839:             Input:
840:               const ROM char *data -  null\-terminated string of constant data. If a
841:                                       null character is not found, 255 BYTEs of data
842:                                       will be transferred to the host.
843:                                                                                      
844:             **************************************************************************/
845:           void putrsUSBUSART(const ROM char *data)
846:           {
847:               BYTE len;
848:               const ROM char *pData;
849:           
850:               /*
851:                * User should have checked that cdc_trf_state is in CDC_TX_READY state
852:                * before calling this function.
853:                * As a safety precaution, this fuction checks the state one more time
854:                * to make sure it does not override any pending transactions.
855:                *
856:                * Currently it just quits the routine without reporting any errors back
857:                * to the user.
858:                *
859:                * Bottomline: User MUST make sure that USBUSARTIsTxTrfReady()
860:                *             before calling this function!
861:                * Example:
862:                * if(USBUSARTIsTxTrfReady())
863:                *     putsUSBUSART(pData);
864:                *
865:                * IMPORTANT: Never use the following blocking while loop to wait:
866:                * while(cdc_trf_state != CDC_TX_READY)
867:                *     putsUSBUSART(pData);
868:                *
869:                * The whole firmware framework is written based on cooperative
870:                * multi-tasking and a blocking code is not acceptable.
871:                * Use a state machine instead.
872:                */
873:               USBMaskInterrupts();
874:               if(cdc_trf_state != CDC_TX_READY)
875:               {
876:                   USBUnmaskInterrupts();
877:                   return;
878:               }
879:               
880:               /*
881:                * While loop counts the number of BYTEs to send including the
882:                * null character.
883:                */
884:               len = 0;
885:               pData = data;
886:               do
887:               {
888:                   len++;
889:                   if(len == 255) break;       // Break loop once max len is reached.
890:               }while(*pData++);
891:               
892:               /*
893:                * Second piece of information (length of data to send) is ready.
894:                * Call mUSBUSARTTxRom to setup the transfer.
895:                * The actual transfer process will be handled by CDCTxService(),
896:                * which should be called once per Main Program loop.
897:                */
898:           
899:               mUSBUSARTTxRom((ROM BYTE*)data,len); // See cdc.h
900:               USBUnmaskInterrupts();
901:           
902:           }//end putrsUSBUSART
903:           
904:           /************************************************************************
905:             Function:
906:                   void CDCTxService(void)
907:               
908:             Summary:
909:               CDCTxService handles device-to-host transaction(s). This function
910:               should be called once per Main Program loop after the device reaches
911:               the configured state.
912:             Description:
913:               CDCTxService handles device-to-host transaction(s). This function
914:               should be called once per Main Program loop after the device reaches
915:               the configured state (after the CDCIniEP() function has already executed).
916:               This function is needed, in order to advance the internal software state 
917:               machine that takes care of sending multiple transactions worth of IN USB
918:               data to the host, associated with CDC serial data.  Failure to call 
919:               CDCTxService() perioidcally will prevent data from being sent to the
920:               USB host, over the CDC serial data interface.
921:               
922:               Typical Usage:
923:               <code>
924:               void main(void)
925:               {
926:                   USBDeviceInit();
927:                   while(1)
928:                   {
929:                       USBDeviceTasks();
930:                       if((USBGetDeviceState() \< CONFIGURED_STATE) ||
931:                          (USBIsDeviceSuspended() == TRUE))
932:                       {
933:                           //Either the device is not configured or we are suspended
934:                           //  so we don't want to do execute any application code
935:                           continue;   //go back to the top of the while loop
936:                       }
937:                       else
938:                       {
939:                           //Keep trying to send data to the PC as required
940:                           CDCTxService();
941:               
942:                           //Run application code.
943:                           UserApplication();
944:                       }
945:                   }
946:               }
947:               </code>
948:             Conditions:
949:               CDCIniEP() function should have already executed/the device should be
950:               in the CONFIGURED_STATE.
951:             Remarks:
952:               None                                                                 
953:             ************************************************************************/
954:            
955:           void CDCTxService(void)
956:           {
957:               BYTE byte_to_send;
958:               BYTE i;
959:               
960:               USBMaskInterrupts();
05A4  0021     MOVLB 0x1
05A5  1112     BCF PIR2, 0x2
961:               
962:               CDCNotificationHandler();
963:               
964:               if(USBHandleBusy(CDCDataInHandle)) 
05A6  0022     MOVLB 0x2
05A7  0846     MOVF 0x46, W
05A8  1903     BTFSC STATUS, 0x2
05A9  2DB3     GOTO 0x5B3
05AA  0846     MOVF 0x46, W
05AB  0086     MOVWF FSR1L
05AC  0187     CLRF FSR1H
05AD  0D01     RLF INDF1, W
05AE  0D01     RLF INDF1, W
05AF  3901     ANDLW 0x1
05B0  0021     MOVLB 0x1
05B1  00A7     MOVWF 0x27
05B2  2DB5     GOTO 0x5B5
05B3  0021     MOVLB 0x1
05B4  01A7     CLRF 0x27
05B5  01A8     CLRF 0x28
05B6  0828     MOVF 0x28, W
05B7  0427     IORWF 0x27, W
05B8  1903     BTFSC STATUS, 0x2
05B9  2DBD     GOTO 0x5BD
965:               {
966:                   USBUnmaskInterrupts();
05BA  0021     MOVLB 0x1
05BB  1512     BSF PIR2, 0x2
967:                   return;
05BC  0008     RETURN
968:               }
969:           
970:               /*
971:                * Completing stage is necessary while [ mCDCUSartTxIsBusy()==1 ].
972:                * By having this stage, user can always check cdc_trf_state,
973:                * and not having to call mCDCUsartTxIsBusy() directly.
974:                */
975:               if(cdc_trf_state == CDC_TX_COMPLETING)
05BD  0022     MOVLB 0x2
05BE  0854     MOVF 0x54, W
05BF  3A03     XORLW 0x3
05C0  1903     BTFSC STATUS, 0x2
976:                   cdc_trf_state = CDC_TX_READY;
05C1  01D4     CLRF 0x54
977:               
978:               /*
979:                * If CDC_TX_READY state, nothing to do, just return.
980:                */
981:               if(cdc_trf_state == CDC_TX_READY)
05C2  08D4     MOVF 0x54, F
05C3  1903     BTFSC STATUS, 0x2
05C4  2DBA     GOTO 0x5BA
982:               {
983:                   USBUnmaskInterrupts();
984:                   return;
985:               }
986:               
987:               /*
988:                * If CDC_TX_BUSY_ZLP state, send zero length packet
989:                */
990:               if(cdc_trf_state == CDC_TX_BUSY_ZLP)
05C5  0854     MOVF 0x54, W
05C6  3A02     XORLW 0x2
05C7  1D03     BTFSS STATUS, 0x2
05C8  2DD6     GOTO 0x5D6
991:               {
992:                   CDCDataInHandle = USBTxOnePacket(CDC_DATA_EP,NULL,0);
05C9  0021     MOVLB 0x1
05CA  3002     MOVLW 0x2
05CB  01A0     CLRF BDT
05CC  0AA0     INCF BDT, F
05CD  01A1     CLRF 0x21
05CE  01A2     CLRF 0x22
05CF  2616     CALL 0x616
05D0  3185     MOVLP 0x5
05D1  0022     MOVLB 0x2
05D2  00C6     MOVWF 0x46
993:                   //CDC_DATA_BD_IN.CNT = 0;
994:                   cdc_trf_state = CDC_TX_COMPLETING;
05D3  3003     MOVLW 0x3
05D4  00D4     MOVWF 0x54
995:               }
05D5  2DBA     GOTO 0x5BA
996:               else if(cdc_trf_state == CDC_TX_BUSY)
05D6  0B54     DECFSZ 0x54, W
05D7  2DBA     GOTO 0x5BA
997:               {
998:                   /*
999:                    * First, have to figure out how many byte of data to send.
1000:                   */
1001:              	if(cdc_tx_len > sizeof(cdc_data_tx))
05D8  3041     MOVLW 0x41
05D9  0255     SUBWF 0x55, W
05DA  1C03     BTFSS STATUS, 0x0
05DB  2DDE     GOTO 0x5DE
1002:              	    byte_to_send = sizeof(cdc_data_tx);
05DC  3040     MOVLW 0x40
05DD  2DDF     GOTO 0x5DF
1003:              	else
1004:              	    byte_to_send = cdc_tx_len;
05DE  0855     MOVF 0x55, W
05DF  0021     MOVLB 0x1
05E0  00AA     MOVWF 0x2A
1005:          
1006:                  /*
1007:                   * Subtract the number of bytes just about to be sent from the total.
1008:                   */
1009:              	cdc_tx_len = cdc_tx_len - byte_to_send;
05E1  0022     MOVLB 0x2
05E2  02D5     SUBWF 0x55, F
1010:              	  
1011:                  pCDCDst.bRam = (BYTE*)&cdc_data_tx; // Set destination pointer
05E3  3020     MOVLW 0x20
05E4  0023     MOVLB 0x3
05E5  00A8     MOVWF 0x28
1012:                  
1013:                  i = byte_to_send;
05E6  0021     MOVLB 0x1
05E7  082A     MOVF 0x2A, W
05E8  00A9     MOVWF 0x29
1014:                  if(cdc_mem_type == USB_EP0_ROM)            // Determine type of memory source
05E9  0022     MOVLB 0x2
05EA  08D2     MOVF 0x52, F
05EB  1903     BTFSC STATUS, 0x2
05EC  2DF0     GOTO 0x5F0
05ED  2DF7     GOTO 0x5F7
1015:                  {
1016:                      while(i)
05F0  0021     MOVLB 0x1
05F1  08A9     MOVF 0x29, F
05F2  1903     BTFSC STATUS, 0x2
05F3  2DFB     GOTO 0x5FB
05F4  2DEE     GOTO 0x5EE
05F5  264E     CALL 0x64E
05F6  3185     MOVLP 0x5
1017:                      {
1018:                          *pCDCDst.bRam = *pCDCSrc.bRom;
05EE  264E     CALL 0x64E
05EF  3185     MOVLP 0x5
1019:                          pCDCDst.bRam++;
1020:                          pCDCSrc.bRom++;
1021:                          i--;
1022:                      }//end while(byte_to_send)
1023:                  }
1024:                  else // _RAM
1025:                  {
1026:                      while(i)
05F7  0021     MOVLB 0x1
05F8  08A9     MOVF 0x29, F
05F9  1D03     BTFSS STATUS, 0x2
05FA  2DF5     GOTO 0x5F5
1027:                      {
1028:                          *pCDCDst.bRam = *pCDCSrc.bRam;
1029:                          pCDCDst.bRam++;
1030:                          pCDCSrc.bRam++;
1031:                          i--;
1032:                      }//end while(byte_to_send._word)
1033:                  }//end if(cdc_mem_type...)
1034:                  
1035:                  /*
1036:                   * Lastly, determine if a zero length packet state is necessary.
1037:                   * See explanation in USB Specification 2.0: Section 5.8.3
1038:                   */
1039:                  if(cdc_tx_len == 0)
05FB  0022     MOVLB 0x2
05FC  08D5     MOVF 0x55, F
05FD  1D03     BTFSS STATUS, 0x2
05FE  2E09     GOTO 0x609
1040:                  {
1041:                      if(byte_to_send == CDC_DATA_IN_EP_SIZE)
05FF  0021     MOVLB 0x1
0600  082A     MOVF 0x2A, W
0601  3A40     XORLW 0x40
0602  1D03     BTFSS STATUS, 0x2
0603  2E06     GOTO 0x606
1042:                          cdc_trf_state = CDC_TX_BUSY_ZLP;
0604  3002     MOVLW 0x2
0605  2E07     GOTO 0x607
1043:                      else
1044:                          cdc_trf_state = CDC_TX_COMPLETING;
0606  3003     MOVLW 0x3
0607  0022     MOVLB 0x2
0608  00D4     MOVWF 0x54
1045:                  }//end if(cdc_tx_len...)
1046:                  CDCDataInHandle = USBTxOnePacket(CDC_DATA_EP,(BYTE*)&cdc_data_tx,byte_to_send);
0609  0021     MOVLB 0x1
060A  3020     MOVLW 0x20
060B  01A0     CLRF BDT
060C  0AA0     INCF BDT, F
060D  00A1     MOVWF 0x21
060E  082A     MOVF 0x2A, W
060F  00A2     MOVWF 0x22
0610  3002     MOVLW 0x2
0611  2616     CALL 0x616
0612  3185     MOVLP 0x5
0613  0022     MOVLB 0x2
0614  00C6     MOVWF 0x46
0615  2DBA     GOTO 0x5BA
1047:          
1048:              }//end if(cdc_tx_sate == CDC_TX_BUSY)
1049:              
1050:              USBUnmaskInterrupts();
1051:          }//end CDCTxService
0616  00A5     MOVWF 0x25
1052:          
1053:          #endif //USB_USE_CDC
1054:          
1055:          /** EOF cdc.c ****************************************************************/
