Disassembly Listing for Klondike
Generated From:
/home/chris/Dev/klondike/firmware/Klondike.X/dist/K16/production/Klondike.X.production.cof
Jul 11, 2013 5:52:07 PM

---  /opt/microchip/xc8/v1.12/sources/wmul.c  -----------------------------------------------------------
1:             unsigned int
2:             __wmul(unsigned int multiplier, unsigned int multiplicand)
3:             {
4:             	unsigned int	product = 0;
05CB  01F4     CLRF product
05CC  01F5     CLRF 0x75
0A12  01DA     CLRF i_718
0A13  01DB     CLRF i
5:             
6:             	do {
7:             		if(multiplier & 1)
05CD  1C70     BTFSS multiplicand, 0x0
05CE  2DD3     GOTO 0x5D3
0A14  1C56     BTFSS direction, 0x0
0A15  2A1A     GOTO 0x21A
8:             			product += multiplicand;
05CF  0872     MOVF product, W
05D0  07F4     ADDWF product, F
05D1  0873     MOVF 0x73, W
05D2  3DF5     ADDWFC 0x75, F
0A16  0858     MOVF p, W
0A17  07DA     ADDWF i_718, F
0A18  0859     MOVF x, W
0A19  3DDB     ADDWFC i, F
9:             		multiplicand <<= 1;
05D3  35F2     LSLF product, F
05D4  0DF3     RLF 0x73, F
0A1A  35D8     LSLF p, F
0A1B  0DD9     RLF x, F
10:            		multiplier >>= 1;
05D5  36F1     LSRF 0x71, F
05D6  0CF0     RRF multiplicand, F
0A1C  36D7     LSRF product, F
0A1D  0CD6     RRF direction, F
11:            	} while(multiplier != 0);
05D7  0871     MOVF 0x71, W
05D8  0470     IORWF multiplicand, W
05D9  1D03     BTFSS STATUS, 0x2
05DA  2DCD     GOTO 0x5CD
0A1E  0857     MOVF product, W
0A1F  0456     IORWF direction, W
0A20  1D03     BTFSS STATUS, 0x2
0A21  2A14     GOTO 0x214
12:            	return product;
05DB  0875     MOVF 0x75, W
05DC  00F1     MOVWF 0x71
05DD  0874     MOVF product, W
05DE  00F0     MOVWF multiplicand
0A22  085B     MOVF i, W
0A23  00D7     MOVWF product
0A24  085A     MOVF i_718, W
0A25  00D6     MOVWF direction
13:            }
05DF  0008     RETURN
0A26  0008     RETURN
---  /opt/microchip/xc8/v1.12/sources/memset.c  ---------------------------------------------------------
1:             #include	<string.h>
2:             
3:             #ifdef _PIC16
4:             far void *
5:             memset(far void * p1, int c, register size_t n)
6:             #else /*  _PIC16 */
7:             void *
8:             memset(void * p1, int c, register size_t n)
9:             #endif /* _PIC16 */
10:            {
11:            
12:            #ifdef _PIC16
13:            	register far char *	p;
14:            #else /*  _PIC16 */
15:            	register char *		p;
16:            #endif /* _PIC16 */
17:            
18:            	p = p1;
0780  00DA     MOVWF i_718
0781  00DB     MOVWF i
19:            	while(n--)
0782  3001     MOVLW 0x1
0783  02D8     SUBWF p, F
0784  3000     MOVLW 0x0
0785  3BD9     SUBWFB x, F
0786  0A58     INCF p, W
0787  1903     BTFSC STATUS, 0x2
0788  0A59     INCF x, W
0789  1903     BTFSC STATUS, 0x2
078A  0008     RETURN
0791  2F82     GOTO 0x782
20:            		*p++ = c;
078B  085B     MOVF i, W
078C  0086     MOVWF FSR1L
078D  0187     CLRF FSR1H
078E  0856     MOVF direction, W
078F  0081     MOVWF INDF1
0790  0ADB     INCF i, F
21:            	return p1;
22:            }
0792  0020     MOVLB 0x0
---  /opt/microchip/xc8/v1.12/sources/lwdiv.c  ----------------------------------------------------------
1:             // word unsigned division
2:             
3:             unsigned int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __lwdiv(unsigned int divisor, unsigned int dividend)
7:             #else
8:             __lwdiv(unsigned int dividend, unsigned int divisor)
9:             #endif
0A27  01DB     CLRF i
0A28  01DC     CLRF work
10:            {
0A29  0857     MOVF product, W
0A2A  0456     IORWF direction, W
0A2B  1903     BTFSC STATUS, 0x2
0A2C  2A47     GOTO 0x247
11:            	unsigned int	quotient;
0A2D  01DA     CLRF i_718
12:            	unsigned char	counter;
0A2F  1BD7     BTFSC product, 0x7
0A30  2A34     GOTO 0x234
0A33  2A2E     GOTO 0x22E
13:            
0A31  35D6     LSLF direction, F
0A32  0DD7     RLF product, F
14:            	quotient = 0;
0A2E  0ADA     INCF i_718, F
15:            	if(divisor != 0) {
16:            		counter = 1;
17:            		while((divisor & 0x8000) == 0) {
0A34  35DB     LSLF i, F
0A35  0DDC     RLF work, F
18:            			divisor <<= 1;
0A36  0857     MOVF product, W
0A37  0259     SUBWF x, W
0A38  1D03     BTFSS STATUS, 0x2
0A39  2A3C     GOTO 0x23C
0A3A  0856     MOVF direction, W
0A3B  0258     SUBWF p, W
0A3C  1C03     BTFSS STATUS, 0x0
0A3D  2A43     GOTO 0x243
19:            			counter++;
0A3E  0856     MOVF direction, W
0A3F  02D8     SUBWF p, F
0A40  0857     MOVF product, W
0A41  3BD9     SUBWFB x, F
20:            		}
0A42  145B     BSF i, 0x0
21:            		do {
22:            			quotient <<= 1;
0A43  36D7     LSRF product, F
0A44  0CD6     RRF direction, F
23:            			if(divisor <= dividend) {
0A45  0BDA     DECFSZ i_718, F
0A46  2A34     GOTO 0x234
24:            				dividend -= divisor;
25:            				quotient |= 1;
0A47  085C     MOVF work, W
0A48  00D7     MOVWF product
0A49  085B     MOVF i, W
0A4A  00D6     MOVWF direction
26:            			}
0A4B  0008     RETURN
27:            			divisor >>= 1;
28:            		} while(--counter != 0);
29:            	}
30:            	return quotient;
31:            }
---  /opt/microchip/xc8/v1.12/sources/bmul.c  -----------------------------------------------------------
1:             unsigned char
2:             __bmul(unsigned char multiplier, unsigned char multiplicand)
3:             {
05BF  00F1     MOVWF 0x71
0D21  0020     MOVLB 0x0
4:             	unsigned char	product = 0;
05C0  01F2     CLRF product
0D23  01D7     CLRF product
5:             
6:             	do {
7:             		if(multiplier & 1)
05C2  1871     BTFSC 0x71, 0x0
0D25  1858     BTFSC p, 0x0
8:             			product += multiplicand;
05C1  0870     MOVF multiplicand, W
05C3  07F2     ADDWF product, F
0D24  0856     MOVF direction, W
0D26  07D7     ADDWF product, F
9:             		multiplicand <<= 1;
05C4  35F0     LSLF multiplicand, F
0D27  35D6     LSLF direction, F
10:            		multiplier >>= 1;
05C5  36F1     LSRF 0x71, F
0D28  36D8     LSRF p, F
11:            	} while(multiplier != 0);
05C6  08F1     MOVF 0x71, F
05C7  1D03     BTFSS STATUS, 0x2
05C8  2DC1     GOTO 0x5C1
0D29  08D8     MOVF p, F
0D2A  1D03     BTFSS STATUS, 0x2
0D2B  2D24     GOTO 0x524
12:            	return product;
05C9  0872     MOVF product, W
0D2C  0857     MOVF product, W
13:            }
05CA  0008     RETURN
0D2D  0008     RETURN
14:            
---  /opt/microchip/xc8/v1.12/sources/awdiv.c  ----------------------------------------------------------
1:             // integer signed division
2:             
3:             signed int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __awdiv(signed int divisor, signed int dividend)
7:             #else
8:             __awdiv(signed int dividend, signed int divisor)
9:             #endif
0FC0  01DB     CLRF i
10:            {
0FC1  1FD7     BTFSS product, 0x7
0FC2  2FCA     GOTO 0x7CA
11:            	signed int	quotient;
0FC3  09D6     COMF direction, F
0FC4  09D7     COMF product, F
0FC5  0AD6     INCF direction, F
0FC6  1903     BTFSC STATUS, 0x2
0FC7  0AD7     INCF product, F
12:            	unsigned char	counter, sign;
0FC8  01DB     CLRF i
0FC9  0ADB     INCF i, F
13:            
14:            	sign = 0;
0FCA  1FD9     BTFSS x, 0x7
0FCB  2FD3     GOTO 0x7D3
15:            	if(divisor < 0) {
0FCC  09D8     COMF p, F
0FCD  09D9     COMF x, F
0FCE  0AD8     INCF p, F
0FCF  1903     BTFSC STATUS, 0x2
0FD0  0AD9     INCF x, F
16:            		divisor = -divisor;
0FD1  3001     MOVLW 0x1
0FD2  06DB     XORWF i, F
17:            		sign = 1;
18:            	}
0FD3  01DC     CLRF work
0FD4  01DD     CLRF y
19:            	if(dividend < 0) {
0FD5  0857     MOVF product, W
0FD6  0456     IORWF direction, W
0FD7  1903     BTFSC STATUS, 0x2
0FD8  2FF3     GOTO 0x7F3
20:            		dividend = -dividend;
0FD9  01DA     CLRF i_718
21:            		sign ^= 1;
0FDB  1BD7     BTFSC product, 0x7
0FDC  2FE0     GOTO 0x7E0
0FDF  2FDA     GOTO 0x7DA
22:            	}
0FDD  35D6     LSLF direction, F
0FDE  0DD7     RLF product, F
23:            	quotient = 0;
0FDA  0ADA     INCF i_718, F
24:            	if(divisor != 0) {
25:            		counter = 1;
26:            		while((divisor & 0x8000U) == 0) {
0FE0  35DC     LSLF work, F
0FE1  0DDD     RLF y, F
27:            			divisor <<= 1;
0FE2  0857     MOVF product, W
0FE3  0259     SUBWF x, W
0FE4  1D03     BTFSS STATUS, 0x2
0FE5  2FE8     GOTO 0x7E8
0FE6  0856     MOVF direction, W
0FE7  0258     SUBWF p, W
0FE8  1C03     BTFSS STATUS, 0x0
0FE9  2FEF     GOTO 0x7EF
28:            			counter++;
0FEA  0856     MOVF direction, W
0FEB  02D8     SUBWF p, F
0FEC  0857     MOVF product, W
0FED  3BD9     SUBWFB x, F
29:            		}
0FEE  145C     BSF work, 0x0
30:            		do {
31:            			quotient <<= 1;
0FEF  36D7     LSRF product, F
0FF0  0CD6     RRF direction, F
32:            			if((unsigned int)divisor <= (unsigned int)dividend) {
0FF1  0BDA     DECFSZ i_718, F
0FF2  2FE0     GOTO 0x7E0
33:            				dividend -= divisor;
34:            				quotient |= 1;
0FF3  085B     MOVF i, W
0FF4  1903     BTFSC STATUS, 0x2
0FF5  2FFB     GOTO 0x7FB
35:            			}
0FF6  09DC     COMF work, F
0FF7  09DD     COMF y, F
0FF8  0ADC     INCF work, F
0FF9  1903     BTFSC STATUS, 0x2
0FFA  0ADD     INCF y, F
36:            			*(unsigned int *)&divisor >>= 1;
0FFB  085D     MOVF y, W
0FFC  00D7     MOVWF product
0FFD  085C     MOVF work, W
0FFE  00D6     MOVWF direction
37:            		} while(--counter != 0);
0FFF  0008     RETURN
38:            	}
39:            	if(sign)
40:            		quotient = -quotient;
41:            	return quotient;
42:            }
---  /home/chris/Dev/klondike/firmware/USB/usb_function_generic.c  --------------------------------------
1:             /******************************************************************************
2:               File Information:
3:                   FileName:       usb_function_generic.c
4:                   Dependencies:   See INCLUDES section below
5:                   Processor:      Microchip USB Microcontrollers
6:                   Hardware:       See "<install directory>\Microchip\Help" for details.
7:                                   
8:                   Compiler:       C18, C30, or C32
9:                   Company:        Microchip Technology, Inc.
10:                
11:                  Software License Agreement:
12:                
13:                  The software supplied herewith by Microchip Technology Incorporated
14:                  (the "Company") for its PIC(R) Microcontroller is intended and
15:                  supplied to you, the Company's customer, for use solely and
16:                  exclusively on Microchip PIC Microcontroller products. The
17:                  software is owned by the Company and/or its supplier, and is
18:                  protected under applicable copyright laws. All rights are reserved.
19:                  Any use in violation of the foregoing restrictions may subject the
20:                  user to criminal sanctions under applicable laws, as well as to
21:                  civil liability for the breach of the terms and conditions of this
22:                  license.
23:                
24:                  THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
25:                  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
26:                  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
27:                  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
28:                  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
29:                  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
30:                
31:                   Change History:
32:                   Rev         Description
33:                
34:              Summary:
35:                This file contains all of functions, macros, definitions, variables,
36:                datatypes, etc. that are required for usage with vendor class function
37:                drivers. This file should be included in projects that use vendor class
38:                \function drivers. Vendor class function drivers include MCHPUSB
39:                (Microchip's custom class driver), WinUSB, and LibUSB.
40:                
41:                
42:                
43:                This file is located in the "\<Install Directory\>\\Microchip\\USB\\Generic
44:                Device Driver" directory.
45:              Description:
46:                USB Vender Class Custom Driver Header File
47:                
48:                This file contains functions, macros, definitions, variables,
49:                datatypes, etc. that are required for use of vendor class function
50:                drivers. This file should be included in projects that use vendor class
51:                \function drivers.
52:                
53:                This file is located in the "\<Install Directory\>\\Microchip\\USB\\Generic
54:                Device Driver" directory.
55:                
56:                When including this file in a new project, this file can either be
57:                referenced from the directory in which it was installed or copied
58:                directly into the user application folder. If the first method is
59:                chosen to keep the file located in the folder in which it is installed
60:                then include paths need to be added so that the library and the
61:                application both know where to reference each others files. If the
62:                application folder is located in the same folder as the Microchip
63:                folder (like the current demo folders), then the following include
64:                paths need to be added to the application's project:
65:                
66:                ..\\..\\Microchip\\Include
67:                .
68:                
69:                If a different directory structure is used, modify the paths as
70:                required. An example using absolute paths instead of relative paths
71:                would be the following:
72:                
73:                C:\\Microchip Solutions\\Microchip\\Include
74:                
75:                C:\\Microchip Solutions\\My Demo Application                               
76:              ******************************************************************************/
77:            
78:            //DOM-IGNORE-BEGIN
79:            /********************************************************************
80:             File Description:
81:            
82:             Change History:
83:              Rev    Description
84:              ----   -----------
85:              2.6    Minor changes in include file structure.
86:              2.9h   Implemented USBCheckVendorRequest() function, in order to
87:                     support MS OS Feature Descriptor handling.
88:            ********************************************************************
89:            //DOM-IGNORE-END
90:            
91:            ******************************************************************************/
92:            
93:            /** I N C L U D E S **********************************************************/
94:            #include "USB/usb.h"
95:            #include "./USB/usb_function_generic.h"
96:            
97:            #if defined(USB_USE_GEN)
98:            
99:            /** V A R I A B L E S ********************************************************/
100:           extern volatile CTRL_TRF_SETUP SetupPkt;    //Common buffer that receives the 
101:                                                       //8-byte SETUP packet data from the 
102:                                                       //host during control transfer 
103:                                                       //requests.
104:           
105:           /** P R I V A T E  P R O T O T Y P E S ***************************************/
106:           
107:           /** D E C L A R A T I O N S **************************************************/
108:           
109:           /** U S E R  A P I ***********************************************************/
110:           
111:           /********************************************************************
112:               Function:
113:                   USB_HANDLE USBGenWrite(BYTE ep, BYTE* data, WORD len)
114:                   
115:               Summary:
116:                   Sends the specified data out the specified endpoint
117:           
118:               Description:
119:                   This function sends the specified data out the specified 
120:                   endpoint and returns a handle to the transfer information.
121:           
122:                   Typical Usage:
123:                   <code>
124:                   //make sure that the last transfer isn't busy by checking the handle
125:                   if(!USBHandleBusy(USBGenericInHandle))
126:                   {
127:                       //Send the data contained in the INPacket[] array out on
128:                       //  endpoint USBGEN_EP_NUM
129:                       USBGenericInHandle = USBGenWrite(USBGEN_EP_NUM,(BYTE*)&INPacket[0],sizeof(INPacket));
130:                   }
131:                   </code>
132:                   
133:               PreCondition:
134:                   None
135:                   
136:               Parameters:
137:                   BYTE ep    - the endpoint you want to send the data out of
138:                   BYTE* data - pointer to the data that you wish to send
139:                   WORD len   - the length of the data that you wish to send
140:                   
141:               Return Values:
142:                   USB_HANDLE - a handle for the transfer.  This information
143:                   should be kept to track the status of the transfer
144:                   
145:               Remarks:
146:                   None
147:             
148:            *******************************************************************/
149:            // Implemented as a macro. See usb_function_generic.h
150:           
151:           /********************************************************************
152:               Function:
153:                   USB_HANDLE USBGenRead(BYTE ep, BYTE* data, WORD len)
154:                   
155:               Summary:
156:                   Receives the specified data out the specified endpoint
157:                   
158:               Description:
159:                   Receives the specified data out the specified endpoint.
160:           
161:                   Typical Usage:
162:                   <code>
163:                   //Read 64-bytes from endpoint USBGEN_EP_NUM, into the OUTPacket array.
164:                   //  Make sure to save the return handle so that we can check it later
165:                   //  to determine when the transfer is complete.
166:                   if(!USBHandleBusy(USBOutHandle))
167:                   {
168:                       USBOutHandle = USBGenRead(USBGEN_EP_NUM,(BYTE*)&OUTPacket,64);
169:                   }
170:                   </code>
171:           
172:               PreCondition:
173:                   None
174:                   
175:               Parameters:
176:                   BYTE ep - the endpoint you want to receive the data into
177:                   BYTE* data - pointer to where the data will go when it arrives
178:                   WORD len - the length of the data that you wish to receive
179:                   
180:               Return Values:
181:                   USB_HANDLE - a handle for the transfer.  This information
182:                   should be kept to track the status of the transfer
183:                   
184:               Remarks:
185:                   None
186:             
187:            *******************************************************************/
188:            // Implemented as a macro. See usb_function_generic.h
189:           
190:           
191:           /********************************************************************
192:           	Function:
193:           		void USBCheckVendorRequest(void)
194:           
195:            	Summary:
196:            		This routine handles vendor class specific requests that happen on EP0.
197:                   This function should be called from the USBCBCheckOtherReq() call back
198:                   function whenever implementing a custom/vendor class device.
199:           
200:            	Description:
201:            		This routine handles vendor specific requests that may arrive on EP0 as
202:            		a control transfer.  These can include, but are not necessarily 
203:            		limited to, requests for Microsft specific OS feature descriptor(s).  
204:            		This function should be called from the USBCBCheckOtherReq() call back 
205:            		function whenever using a vendor class device.
206:           
207:                   Typical Usage:
208:                   <code>
209:                   void USBCBCheckOtherReq(void)
210:                   {
211:                       //Since the stack didn't handle the request I need to check
212:                       //  my class drivers to see if it is for them
213:                       USBCheckVendorRequest();
214:                   }
215:                   </code>
216:           
217:           	PreCondition:
218:           		None
219:           
220:           	Parameters:
221:           		Although this function has a void input, this handler function will
222:           		typically need to look at the 8-byte SETUP packet contents that the
223:           		host just sent, which may contain the vendor class specific request.
224:           		
225:           		Therefore, the statically allocated SetupPkt structure may be looked
226:           		at while in the context of this function, and it will contain the most
227:           		recently received 8-byte SETUP packet data.
228:           
229:           	Return Values:
230:           		None
231:           
232:           	Remarks:
233:           		This function normally gets called within the same context as the
234:           		USBDeviceTasks() function, just after a new control transfer request
235:           		from the host has arrived.  If the USB stack is operated in 
236:           		USB_INTERRUPT mode (a usb_config.h option), then this function
237:           		will be executed in the interrupt context.  If however the USB stack
238:           		is operated in the USB_POLLING mode, then this function executes in the
239:           		main loop context.
240:           		
241:           		In order to respond to class specific control transfer request(s) in
242:           		this handler function, it is suggested to use one or more of the
243:           		USBEP0SendRAMPtr(), USBEP0SendROMPtr(), or USBEP0Receive() API 
244:           		functions.
245:            
246:            *******************************************************************/
247:           void USBCheckVendorRequest(void)
248:           {
249:               #if defined(IMPLEMENT_MICROSOFT_OS_DESCRIPTOR)
250:                   WORD Length;
251:               
252:                   //Check if the most recent SETUP request is class specific
253:                   if(SetupPkt.bmRequestType == 0b11000000)    //Class specific, device to host, device level target
254:                   {
255:                       //Check if the host is requesting an MS feature descriptor
256:                       if(SetupPkt.bRequest == GET_MS_DESCRIPTOR)
257:                       {
258:                           //Figure out which descriptor is being requested
259:                           if(SetupPkt.wIndex == EXTENDED_COMPAT_ID)
260:                           {
261:                               //Determine number of bytes to send to host 
262:                               //Lesser of: requested amount, or total size of the descriptor
263:                               Length = CompatIDFeatureDescriptor.dwLength;
264:                               if(SetupPkt.wLength < Length)
265:                               {
266:                                   Length = SetupPkt.wLength;
267:                               }    
268:                                    
269:                               //Prepare to send the requested descriptor to the host
270:                               USBEP0SendROMPtr((ROM BYTE*)&CompatIDFeatureDescriptor, Length, USB_EP0_ROM | USB_EP0_INCLUDE_ZERO);
271:                           }
272:                       }            
273:                   }//if(SetupPkt.bmRequestType == 0b11000000)    
274:                   else if(SetupPkt.bmRequestType == 0b11000001)    //Class specific, device to host, interface target
275:                   {
276:                       //Check if the host is requesting an MS feature descriptor
277:                       if(SetupPkt.bRequest == GET_MS_DESCRIPTOR)
278:                       {
279:                           //Figure out which descriptor is being requested
280:                           if(SetupPkt.wIndex == EXTENDED_PROPERTIES)    
281:                           {
282:                               //Determine number of bytes to send to host 
283:                               //Lesser of: requested amount, or total size of the descriptor
284:                               Length = ExtPropertyFeatureDescriptor.dwLength;
285:                               if(SetupPkt.wLength < Length)
286:                               {
287:                                   Length = SetupPkt.wLength;
288:                               }    
289:                                    
290:                               //Prepare to send the requested descriptor to the host
291:                               USBEP0SendROMPtr((ROM BYTE*)&ExtPropertyFeatureDescriptor, Length, USB_EP0_ROM | USB_EP0_INCLUDE_ZERO);
292:                           }    
293:                       }                   
294:                   }//else if(SetupPkt.bmRequestType == 0b11000001)    
295:               #endif  //#if defined(IMPLEMENT_MICROSOFT_OS_DESCRIPTOR)   
296:           }//void USBCheckVendorRequest(void)
0390  0008     RETURN
297:           
298:           
299:           #endif //def USB_USE_GEN
300:           /** EOF usbgen.c *************************************************************/
---  /home/chris/Dev/klondike/firmware/USB/usb_device.c  ------------------------------------------------
1:             /********************************************************************
2:               File Information:
3:                 FileName:     	usb_device.c
4:                 Dependencies:	See INCLUDES section
5:                 Processor:		PIC18,PIC24, PIC32 and dsPIC33E USB Microcontrollers
6:                 Hardware:		This code is natively intended to be used on Mirochip USB
7:                                 demo boards.  See www.microchip.com/usb (Software & Tools 
8:                                 section) for list of available platforms.  The firmware may 
9:                                 be modified for use on other USB platforms by editing the
10:                				HardwareProfile.h and HardwareProfile - [platform].h files.
11:                Complier:  	    Microchip C18 (for PIC18),C30 (for PIC24 and dsPIC33E)
12:                                and C32 (for PIC32)
13:                Company:		Microchip Technology, Inc.
14:                
15:                Software License Agreement:
16:                
17:                The software supplied herewith by Microchip Technology Incorporated
18:                (the "Company") for its PIC(r) Microcontroller is intended and
19:                supplied to you, the Company's customer, for use solely and
20:                exclusively on Microchip PIC Microcontroller products. The
21:                software is owned by the Company and/or its supplier, and is
22:                protected under applicable copyright laws. All rights are reserved.
23:                Any use in violation of the foregoing restrictions may subject the
24:                user to criminal sanctions under applicable laws, as well as to
25:                civil liability for the breach of the terms and conditions of this
26:                license.
27:                
28:                THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
29:                WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
30:                TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
31:                PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
32:                IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
33:                CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
34:            
35:              Summary:
36:                This file contains functions, macros, definitions, variables,
37:                datatypes, etc. that are required for usage with the MCHPFSUSB device
38:                stack. This file should be included in projects that use the device stack. 
39:                
40:                This file is located in the "\<Install Directory\>\\Microchip\\USB"
41:                directory.
42:            
43:              Description:
44:                USB Device Stack File
45:                
46:                This file contains functions, macros, definitions, variables,
47:                datatypes, etc. that are required for usage with the MCHPFSUSB device
48:                stack. This file should be included in projects that use the device stack.
49:                
50:                This file is located in the "\<Install Directory\>\\Microchip\\USB"
51:                directory.
52:                
53:                When including this file in a new project, this file can either be
54:                referenced from the directory in which it was installed or copied
55:                directly into the user application folder. If the first method is
56:                chosen to keep the file located in the folder in which it is installed
57:                then include paths need to be added so that the library and the
58:                application both know where to reference each others files. If the
59:                application folder is located in the same folder as the Microchip
60:                folder (like the current demo folders), then the following include
61:                paths need to be added to the application's project:
62:                
63:                .
64:                ..\\..\\MicrochipInclude
65:                
66:                If a different directory structure is used, modify the paths as
67:                required. An example using absolute paths instead of relative paths
68:                would be the following:
69:                
70:                C:\\Microchip Solutions\\Microchip\\Include
71:                
72:                C:\\Microchip Solutions\\My Demo Application 
73:            
74:            ********************************************************************
75:             File Description:
76:            
77:             Change History:
78:              Rev    Description
79:              ----   -----------
80:              2.6    Added USBCancelIO() function.  Moved and some stack
81:                     defintions to be more consistant with the host stack.
82:            
83:              2.6a   Fixed issue where a SET_CONFIGURATION received could cause
84:                     inability to transmit on an endpoint if using ping-pong
85:                     and an odd number of packets had been sent on that endpoint 
86:            
87:              2.7    Fixed error where the USB error interrupt flag was not getting
88:                     cleared properly for PIC32 resulting in lots of extra error interrupts.
89:                     http://www.microchip.com/forums/tm.aspx?m=479085
90:            
91:                     Fixed issue with dual role mode when device run in polling
92:                     mode.  Interrupts were remaining enabled after the host mode
93:                     operation was complete.  This was incompatible with polling
94:                     mode operation.
95:            
96:                     Changed how the bus sensing works.  In previous revisions it
97:                     was impossible to use the USBDeviceDetach to detach from the
98:                     bus if the bus voltage was still present.  This is now
99:                     possible.  It was also possible to move the device to the 
100:                    ATTACHED state in interrupt mode even if the bus voltage 
101:                    wasn't available.  This is now prohibited unless VBUS is
102:                    present.
103:                    
104:                    Improved error case handling when the host sends more OUT
105:                    bytes in a control transfer than the firmware was expecting
106:                    to receive (based on the size parameter when calling USBEP0Receive()).
107:                    
108:                    In the USBStdSetCfgHandler(), modified the code so the USBDeviceState
109:                    variable only gets updated to the CONFIGURED_STATE at the end of the 
110:                    function.  
111:           
112:             2.7a   Update to support the PIC18F47J53 A1 and later revision
113:                    devices.
114:           
115:                    Fixed an error on 16-bit and 32-bit processors where a word access
116:                    could be performed on a byte pointer resulting in possible address
117:                    errors with odd aligned pointers.
118:                    
119:             2.8    Several changes to the way control transfers get processed,
120:                    so as to support the ability to allow application/class specific
121:                    handler code to defer the status stage.  
122:                    Implemented USBCtrlEPAllowStatusStage() API function.
123:                    Implemented USBDeferStatusStage() API function (macro).
124:                    These changes also greatly relax the USBDeviceTasks() calling frequency 
125:                    requirement, while allowing USB class handlers more flexibility.
126:                    
127:                    Also implemented the following API functions and macros, for delaying 
128:                    the data stage of a control transfer (with data stage):
129:                    USBDeferINDataStage()
130:                    USBDeferOUTDataStage()
131:                    USBOUTDataStageDeferred()
132:                    USBINDataStageDeferred()
133:                    USBCtrlEPAllowDataStage()      
134:                    
135:                    Fixed USB reset event handler issue, where the USB stack would 
136:                    re-initialize global interrupt settings in the interrupt context, on 
137:                    PIC18 devices with the stack operated in USB_INTERRUPT mode.
138:                    
139:                    Fixed handling of SET/CLEAR FEATURE (endpoint halt) host requests.
140:                    Previous implementation would not always initialize endpoints correctly 
141:                    to DATA0 DTS state after a clear feature endpoint halt request, for 
142:                    all ping pong mode and usage scenarios.
143:                    
144:              2.9   Fixed an issue with STALL handling behavior on non-EP0 endpoints, for 
145:                    PIC24 and PIC32 devices.  
146:              		  
147:              		 Fixed an issue where the ep_data_in[]/ep_data_out[] flags weren't 
148:              		 getting re-initialized coincident with the hardware ping pong pointer 
149:              		 reset during set configuration events.
150:              		 
151:              		 Implemented USBGetNextHandle() API function (actually a macro, defined
152:              		 in usb_device.h).
153:           
154:              2.9d  Added build option for disabling DTS checking
155:              
156:              2.9f  Adding pragma for PIC18F97J94 Family BDT location.
157:           
158:              2.9h  Updated to be able to support optional Microsoft OS Descriptors
159:           
160:              2.9i  Updated to set UCON<SUSPND> bit on PIC16F USB devices during 
161:                    suspend, so as to save power.
162:              
163:           ********************************************************************/
164:           
165:           /*----------------------------------------------------------------------------------
166:           The USBDeviceTasks() function is responsible for detecting and processing various
167:           USB bus events and host requests, such as those required for USB enumeration, when
168:           the USB cable is first attached to the host.  This function is the main dispatcher
169:           routine for the USB stack.
170:           
171:           Additional API functions and macros are also provided by the USB stack, which can be 
172:           used to send/receive USB data to/from the host, among other things.  A full list 
173:           of the available implemented functions/macros are provided in the 
174:           "MCHPFSUSB Library Help".  For normal installations of the MCHPFSUSB Framework,
175:           the USB API documentation can be found from:
176:           
177:           Start menu --> (All Programs) --> Microchip --> MCHPFSUSB vX.x --> Documents --> MCHPFSUSB Library Help
178:           
179:           Once the help file is opened, the API functions/macros are described in the following section:
180:           Library Interface (API) --> Device/Peripheral --> Device Stack --> Interface Routines
181:           Additional API functions may also be provided depending upon the specific USB device class
182:           implemented, and these functions are also documented in the MCHPFSUSB Library Help.
183:           
184:           
185:           If the USB stack is operated in "USB_POLLING" mode (user selectable option in 
186:           usb_config.h), then the application firmware is reponsible for calling the 
187:           USBDeviceTasks() function periodically.  If the USB stack is operated in the 
188:           "USB_INTERRUPT" mode, then the application firmware does not have to directly 
189:           call USBDeviceTasks(), as it will execute only when necessary as an interrupt handler.
190:           
191:           In order to properly operate a USB connection, and to correctly process and respond
192:           to control transfers in the maximum time allowed by the USB specifications, the
193:           USBDeviceTasks() function/interrupt handler must be allowed to execute in a timely
194:           fashion.
195:           
196:           When the USB module is enabled, the USB cable is attached to the host, the USB bus
197:           is not in the suspend state, and the USB stack is operated in the USB_POLLING mode 
198:           with ping pong buffering enabled (at least) on EP0 OUT,  then the maximum allowed 
199:           time between calls to the USBDeviceTasks() function needs to be:
200:           
201:           The faster of:
202:           1.  Once per ~1.8ms, when USBDeviceState == ADR_PENDING_STATE
203:           2.  Once per ~9.8ms, when USBDeviceState == (any other value other than ADR_PENDING_STATE)
204:           3.  Fast enough to ensure the USTAT FIFO can never get full.  See additional explanation below.
205:           
206:           Additional details of the above timing limits are provided:
207:           
208:           Timing item #1: This parameter originates from the 2ms set address "recovery interval"
209:           specification dictated by section "9.2.6.3 Set Address Processing" of the official 
210:           USB 2.0 specifications.
211:           
212:           Timing item #2: This parameter originates from several "10 ms" criteria in the 
213:           USB 2.0 specifications.  For example, reset recovery intervals, resume recovery 
214:           intervals, suspend to actual current reduction, etc. have timing maximums of 10ms.
215:           
216:           Timing item #3: This is not a fixed X.X ms parameter, but depends on the  
217:           transaction rate implemented by the application.  The USBDeviceTasks() function is
218:           responsible for popping entries off the USTAT FIFO.  If the FIFO ever gets full,
219:           then no further USB transactions are allowed to occur, until the firmware pops entries
220:           off the FIFO.  In practice, this means the firmware should call USBDeviceTasks() at
221:           a rate at least as fast as once every three times the USBTransferOnePacket() function
222:           is called.  This ensures that the rate that USTAT FIFO entries are getting added to
223:           the FIFO is lower than the rate that the entries are getting popped off the FIFO (the
224:           USBDeviceTasks() function will pop up to 4 entries per call), which is a
225:           necessary criteria to ensure the USTAT FIFO entries don't "pile up."  Calling
226:           USBDeviceTasks() even more often, ex: >=1 to 1 ratio of USBDeviceTasks() to 
227:           USBTransferOnePacket(), adds further protection against the USTAT FIFO getting full,
228:           and is therefore recommended.
229:           
230:           When the USB stack is operated in USB_INTERRUPT mode, then the above timing 
231:           parameters should be interpreted to be the longest allowed time that the USB 
232:           interrupts may be masked/disabled for, before re-enabling the USB interrupts.
233:           
234:           Calling USBDeviceTasks() (or allowing USBDeviceTasks() to be called) more often 
235:           will still have potential USB data rate speed and processing latency benefits.
236:           It is also beneficial to call USBDeviceTasks() more often than theoretically 
237:           required, since it has been observed that not all host/drivers/bios/hubs are 
238:           100% consistently compliant with all timing parameters of the USB 2.0 specifications.
239:           Therefore, in a USB_POLLING based application, it is still suggested to call 
240:           USBDeviceTasks() as often as there are free CPU cycles.  This ensures best 
241:           performance, along with best possible compatibility with all existing USB 
242:           hosts/hubs (both those that are compliant and [partially] non-compliant).
243:           
244:           If ping pong buffering is not enabled on (at least) EP0 OUT, then it is required
245:           to call (or allow to execute) USBDeviceTasks() much more frequently (ex: once 
246:           per 100us, or preferrably faster).  Therefore, in all applications, it is 
247:           normally recommended to select either the USB_PING_PONG__FULL_PING_PONG or 
248:           USB_PING_PONG__EP0_OUT_ONLY mode (user option in usb_config.h), as these modes
249:           allow for much more relaxed timing requirements, and therefore greater application
250:           firmware design flexibility.
251:           //----------------------------------------------------------------------------------*/
252:           
253:           /** INCLUDES *******************************************************/
254:           #include "./USB/usb.h"
255:           #include "HardwareProfile.h"
256:           
257:           #include "./USB/usb_device_local.h"
258:           
259:           
260:           #if defined(USB_USE_MSD)
261:               #include "./USB/usb_function_msd.h"
262:           #endif
263:           
264:           #if !defined(USE_USB_BUS_SENSE_IO)
265:               #undef USB_BUS_SENSE
266:               #define USB_BUS_SENSE 1
267:           #endif
268:           
269:           #if defined(USB_DEVICE_DISABLE_DTS_CHECKING)
270:               #define _DTS_CHECKING_ENABLED 0
271:           #else
272:               #define _DTS_CHECKING_ENABLED _DTSEN
273:           #endif
274:           
275:           /** DEFINITIONS ****************************************************/
276:           
277:           /** VARIABLES ******************************************************/
278:           #if defined(__18CXX)
279:               #pragma udata
280:           #endif
281:           
282:           USB_VOLATILE USB_DEVICE_STATE USBDeviceState;
283:           USB_VOLATILE BYTE USBActiveConfiguration;
284:           USB_VOLATILE BYTE USBAlternateInterface[USB_MAX_NUM_INT];
285:           volatile BDT_ENTRY *pBDTEntryEP0OutCurrent;
286:           volatile BDT_ENTRY *pBDTEntryEP0OutNext;
287:           volatile BDT_ENTRY *pBDTEntryOut[USB_MAX_EP_NUMBER+1];
288:           volatile BDT_ENTRY *pBDTEntryIn[USB_MAX_EP_NUMBER+1];
289:           USB_VOLATILE BYTE shortPacketStatus;
290:           USB_VOLATILE BYTE controlTransferState;
291:           USB_VOLATILE IN_PIPE inPipes[1];
292:           USB_VOLATILE OUT_PIPE outPipes[1];
293:           USB_VOLATILE BYTE *pDst;
294:           USB_VOLATILE BOOL RemoteWakeup;
295:           USB_VOLATILE BOOL USBBusIsSuspended;
296:           USB_VOLATILE USTAT_FIELDS USTATcopy;
297:           USB_VOLATILE BYTE endpoint_number;
298:           USB_VOLATILE BOOL BothEP0OutUOWNsSet;
299:           USB_VOLATILE EP_STATUS ep_data_in[USB_MAX_EP_NUMBER+1];
300:           USB_VOLATILE EP_STATUS ep_data_out[USB_MAX_EP_NUMBER+1];
301:           USB_VOLATILE BYTE USBStatusStageTimeoutCounter;
302:           volatile BOOL USBDeferStatusStagePacket;
303:           volatile BOOL USBStatusStageEnabledFlag1;
304:           volatile BOOL USBStatusStageEnabledFlag2;
305:           volatile BOOL USBDeferINDataStagePackets;
306:           volatile BOOL USBDeferOUTDataStagePackets;
307:           
308:           
309:           #if (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
310:               #define BDT_NUM_ENTRIES      ((USB_MAX_EP_NUMBER + 1) * 2)
311:           #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
312:               #define BDT_NUM_ENTRIES      (((USB_MAX_EP_NUMBER + 1) * 2)+1)
313:           #elif (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
314:               #define BDT_NUM_ENTRIES      ((USB_MAX_EP_NUMBER + 1) * 4)
315:           #elif (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
316:               #define BDT_NUM_ENTRIES      (((USB_MAX_EP_NUMBER + 1) * 4)-2)
317:           #else
318:               #error "No ping pong mode defined."
319:           #endif
320:           
321:           /** USB FIXED LOCATION VARIABLES ***********************************/
322:           #if defined(__18CXX)
323:               #pragma udata USB_BDT=USB_BDT_ADDRESS
324:           #endif
325:           
326:           volatile BDT_ENTRY BDT[BDT_NUM_ENTRIES] BDT_BASE_ADDR_TAG;
327:           
328:           /********************************************************************
329:            * Section B: EP0 Buffer Space
330:            *******************************************************************/
331:           volatile CTRL_TRF_SETUP SetupPkt CTRL_TRF_SETUP_ADDR_TAG;
332:           volatile BYTE CtrlTrfData[USB_EP0_BUFF_SIZE] CTRL_TRF_DATA_ADDR_TAG;
333:           
334:           /********************************************************************
335:            * Section C: non-EP0 Buffer Space
336:            *******************************************************************/
337:           #if defined(USB_USE_MSD)
338:           	//volatile far USB_MSD_CBW_CSW msd_cbw_csw;
339:           	volatile USB_MSD_CBW msd_cbw;
340:           	volatile USB_MSD_CSW msd_csw;
341:           	//#pragma udata
342:           
343:           	#if defined(__18CXX)
344:           		#pragma udata myMSD=MSD_BUFFER_ADDRESS
345:           	#endif
346:           	volatile char msd_buffer[512];
347:           #endif
348:           
349:           
350:           
351:           ////Depricated in v2.2 - will be removed in a future revision
352:           #if !defined(USB_USER_DEVICE_DESCRIPTOR)
353:               //Device descriptor
354:               extern ROM USB_DEVICE_DESCRIPTOR device_dsc;
355:           #else
356:               USB_USER_DEVICE_DESCRIPTOR_INCLUDE;
357:           #endif
358:           
359:           #if !defined(USB_USER_CONFIG_DESCRIPTOR)
360:               //Array of configuration descriptors
361:               extern ROM BYTE *ROM USB_CD_Ptr[];
362:           #else
363:               USB_USER_CONFIG_DESCRIPTOR_INCLUDE;
364:           #endif
365:           
366:           extern ROM BYTE *ROM USB_SD_Ptr[];
367:           
368:           /** DECLARATIONS ***************************************************/
369:           #if defined(__18CXX)
370:               #pragma code
371:           #endif
372:           
373:           /** Macros *********************************************************/
374:           
375:           /** Function Prototypes ********************************************/
376:           //External
377:           //This is the prototype for the required user event handler
378:           BOOL USER_USB_CALLBACK_EVENT_HANDLER(int event, void *pdata, WORD size);
379:           
380:           //Internal Functions
381:           static void USBCtrlEPService(void);
382:           static void USBCtrlTrfSetupHandler(void);
383:           static void USBCtrlTrfInHandler(void);
384:           static void USBCheckStdRequest(void);
385:           static void USBStdGetDscHandler(void);
386:           static void USBCtrlEPServiceComplete(void);
387:           static void USBCtrlTrfTxService(void);
388:           static void USBCtrlTrfRxService(void);
389:           static void USBStdSetCfgHandler(void);
390:           static void USBStdGetStatusHandler(void);
391:           static void USBStdFeatureReqHandler(void);
392:           static void USBCtrlTrfOutHandler(void);
393:           static void USBConfigureEndpoint(BYTE EPNum, BYTE direction);
394:           static void USBWakeFromSuspend(void);
395:           static void USBSuspend(void);
396:           static void USBStallHandler(void);
397:           
398:           //static BOOL USBIsTxBusy(BYTE EPNumber);
399:           //static void USBPut(BYTE EPNum, BYTE Data);
400:           //static void USBEPService(void);
401:           //static void USBProtocolResetHandler(void);
402:           
403:           /******************************************************************************/
404:           /** Function Implementations *************************************************/
405:           /******************************************************************************/
406:           
407:           /******************************************************************************/
408:           /** Internal Macros *********************************************************/
409:           /******************************************************************************/
410:           
411:           /****************************************************************************
412:             Function:
413:               void USBAdvancePingPongBuffer(BDT_ENTRY** buffer)
414:           
415:             Description:
416:               This function will advance the passed pointer to the next buffer based on
417:               the ping pong option setting.  This function should be used for EP1-EP15
418:               only.  This function is not valid for EP0.
419:           
420:             Precondition:
421:               None
422:           
423:             Parameters:
424:               BDT_ENTRY** - pointer to the BDT_ENTRY pointer that you want to be advanced
425:               to the next buffer state
426:           
427:             Return Values:
428:               None
429:           
430:             Remarks:
431:               None
432:           
433:             ***************************************************************************/
434:           #define USBAdvancePingPongBuffer(buffer) ((BYTE_VAL*)buffer)->Val ^= USB_NEXT_PING_PONG;
435:           #define USBHALPingPongSetToOdd(buffer)   {((BYTE_VAL*)buffer)->Val |= USB_NEXT_PING_PONG;}
436:           #define USBHALPingPongSetToEven(buffer)  {((BYTE_VAL*)buffer)->Val &= ~USB_NEXT_PING_PONG;}
437:           
438:           
439:           /******************************************************************************/
440:           /** External API Functions ****************************************************/
441:           /******************************************************************************/
442:           
443:           /**************************************************************************
444:               Function:
445:                   void USBDeviceInit(void)
446:               
447:               Description:
448:                   This function initializes the device stack it in the default state. The
449:                   USB module will be completely reset including all of the internal
450:                   variables, registers, and interrupt flags.
451:                           
452:               Precondition:
453:                   This function must be called before any of the other USB Device
454:                   functions can be called, including USBDeviceTasks().
455:                   
456:               Parameters:
457:                   None
458:                
459:               Return Values:
460:                   None
461:                   
462:               Remarks:
463:                   None
464:                                                                     
465:             ***************************************************************************/
466:           void USBDeviceInit(void)
467:           {
468:               BYTE i;
469:           
470:               USBDisableInterrupts();
0213  0021     MOVLB 0x1
0214  1112     BCF PIR2, 0x2
471:           
472:               // Clear all USB error flags
473:               USBClearInterruptRegister(U1EIR);  
0215  003D     MOVLB 0x1D
0216  0193     CLRF 0x13
474:                  
475:               // Clears all USB interrupts          
476:               USBClearInterruptRegister(U1IR); 
0217  0190     CLRF 0x10
477:           
478:               //Clear all of the endpoint control registers
479:               U1EP0 = 0;
0218  0198     CLRF T1CON
480:               
481:               DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
0219  300E     MOVLW 0xE
021A  0020     MOVLB 0x0
021B  00D9     MOVWF x
021C  3099     MOVLW 0x99
021D  00D8     MOVWF p
021E  01DA     CLRF i_718
021F  0858     MOVF p, W
0220  0086     MOVWF FSR1L
0221  0859     MOVF x, W
0222  0087     MOVWF FSR1H
0223  0181     CLRF INDF1
0224  0AD8     INCF p, F
0225  1903     BTFSC STATUS, 0x2
0226  0AD9     INCF x, F
0227  0ADA     INCF i_718, F
0228  1903     BTFSC STATUS, 0x2
0229  2A1F     GOTO 0x21F
482:           
483:               SetConfigurationOptions();
022A  3016     MOVLW 0x16
022B  003D     MOVLB 0x1D
022C  23DE     CALL 0x3DE
022D  3180     MOVLP 0x0
484:           
485:               //power up the module (if not already powered)
486:               USBPowerModule();
487:           
488:               //set the address of the BDT (if applicable)
489:               USBSetBDTAddress(BDT);
490:           
491:               //Clear all of the BDT entries
492:               for(i=0;i<(sizeof(BDT)/sizeof(BDT_ENTRY));i++)
022E  0020     MOVLB 0x0
022F  01DB     CLRF i
023B  3008     MOVLW 0x8
023C  0ADB     INCF i, F
023D  025B     SUBWF i, W
023E  1C03     BTFSS STATUS, 0x0
023F  2A30     GOTO 0x230
493:               {
494:                   BDT[i].Val = 0x00;
0230  085B     MOVF i, W
0231  0709     ADDWF WREG, W
0232  0709     ADDWF WREG, W
0233  3E20     ADDLW 0x20
0234  0086     MOVWF FSR1L
0235  3000     MOVLW 0x0
0236  0187     CLRF FSR1H
0237  3FC0     MOVWI [0]FSR1
0238  3FC1     MOVWI [1]FSR1
0239  3FC2     MOVWI [2]FSR1
023A  3FC3     MOVWI [3]FSR1
495:               }
496:           
497:               // Assert reset request to all of the Ping Pong buffer pointers
498:               USBPingPongBufferReset = 1;                    
0240  003D     MOVLB 0x1D
0241  170E     BSF PORTC, 0x6
499:           
500:               // Reset to default address
501:               U1ADDR = 0x00;                   
0242  0196     CLRF TMR1L
502:           
503:               // Make sure packet processing is enabled
504:               USBPacketDisable = 0;           
0243  120E     BCF PORTC, 0x4
505:           
506:               //Stop trying to reset ping pong buffer pointers
507:               USBPingPongBufferReset = 0;
0244  130E     BCF PORTC, 0x6
508:           
509:               // Flush any pending transactions
510:               while(USBTransactionCompleteIF == 1)      
0245  003D     MOVLB 0x1D
0246  1D90     BTFSS 0x10, 0x3
0247  2A4F     GOTO 0x24F
024E  2A45     GOTO 0x245
511:               {
512:                   USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
0248  1190     BCF 0x10, 0x3
513:                   //Initialize USB stack software state variables
514:                   inPipes[0].info.Val = 0;
0249  0022     MOVLB 0x2
024A  01CA     CLRF 0x4A
515:                   outPipes[0].info.Val = 0;
024B  01A2     CLRF 0x22
516:                   outPipes[0].wCount.Val = 0;
024C  01A3     CLRF 0x23
024D  01A4     CLRF 0x24
517:               }
518:           
519:               //Set flags to TRUE, so the USBCtrlEPAllowStatusStage() function knows not to
520:               //try and arm a status stage, even before the first control transfer starts.
521:               USBStatusStageEnabledFlag1 = TRUE;  
024F  3001     MOVLW 0x1
0250  0022     MOVLB 0x2
0251  00B6     MOVWF 0x36
522:               USBStatusStageEnabledFlag2 = TRUE;
0252  00B7     MOVWF 0x37
523:               //Initialize other flags
524:               USBDeferINDataStagePackets = FALSE;
0253  01B2     CLRF 0x32
525:               USBDeferOUTDataStagePackets = FALSE;
0254  01B3     CLRF 0x33
526:               USBBusIsSuspended = FALSE;
527:           
528:           	//Initialize all pBDTEntryIn[] and pBDTEntryOut[]
529:           	//pointers to NULL, so they don't get used inadvertently.  
530:           	for(i = 0; i < (BYTE)(USB_MAX_EP_NUMBER+1u); i++)
0255  0020     MOVLB 0x0
0256  01DB     CLRF i
0269  3002     MOVLW 0x2
026B  0ADB     INCF i, F
026C  025B     SUBWF i, W
026D  1C03     BTFSS STATUS, 0x0
026E  2A57     GOTO 0x257
531:           	{
532:           		pBDTEntryIn[i] = 0u;
0257  085B     MOVF i, W
0258  3E6A     ADDLW 0x6A
0259  0086     MOVWF FSR1L
025A  0187     CLRF FSR1H
025B  0181     CLRF INDF1
533:           		pBDTEntryOut[i] = 0u;		
025C  085B     MOVF i, W
025D  3E2A     ADDLW 0x2A
025E  0086     MOVWF FSR1L
025F  3001     MOVLW 0x1
0260  0087     MOVWF FSR1H
0261  0181     CLRF INDF1
534:           		ep_data_in[i].Val = 0u;
0262  085B     MOVF i, W
0263  3E26     ADDLW 0x26
0264  0086     MOVWF FSR1L
0265  0181     CLRF INDF1
535:                   ep_data_out[i].Val = 0u;
0266  085B     MOVF i, W
0267  3E28     ADDLW 0x28
0268  0086     MOVWF FSR1L
026A  0181     CLRF INDF1
536:           	}
537:           
538:               //Get ready for the first packet
539:               pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
026F  3028     MOVLW 0x28
0270  00EA     MOVWF pBDTEntryIn
540:               // Initialize EP0 as a Ctrl EP
541:               U1EP0 = EP_CTRL|USB_HANDSHAKE_ENABLED;        
0271  3016     MOVLW 0x16
0272  003D     MOVLB 0x1D
0273  0098     MOVWF T1CON
542:           	//Prepare for the first SETUP on EP0 OUT
543:               BDT[EP0_OUT_EVEN].ADR = ConvertToPhysicalAddress(&SetupPkt);
0274  3040     MOVLW 0x40
0275  0020     MOVLB 0x0
0276  00D6     MOVWF direction
0277  01D7     CLRF product
0278  00A2     MOVWF 0x22
0279  0857     MOVF product, W
027A  00A3     MOVWF 0x23
544:               BDT[EP0_OUT_EVEN].CNT = USB_EP0_BUFF_SIZE;
027B  3008     MOVLW 0x8
027C  00A1     MOVWF 0x21
545:               BDT[EP0_OUT_EVEN].STAT.Val = _USIE|_DAT0|_BSTALL;
027D  3084     MOVLW 0x84
027E  00A0     MOVWF BDT
546:           
547:               // Clear active configuration
548:               USBActiveConfiguration = 0;     
027F  0021     MOVLB 0x1
0280  01ED     CLRF controlTransferState
549:           
550:               //Indicate that we are now in the detached state        
551:               USBDeviceState = DETACHED_STATE;
0281  01EA     CLRF pBDTEntryIn
552:           }
0282  0008     RETURN
553:           
554:           /**************************************************************************
555:             Function:
556:                   void USBDeviceTasks(void)
557:               
558:             Summary:
559:               This function is the main state machine/transaction handler of the USB 
560:               device side stack.  When the USB stack is operated in "USB_POLLING" mode 
561:               (usb_config.h user option) the USBDeviceTasks() function should be called 
562:               periodically to receive and transmit packets through the stack. This 
563:               function also takes care of control transfers associated with the USB 
564:               enumeration process, and detecting various USB events (such as suspend).  
565:               This function should be called at least once every 1.8ms during the USB 
566:               enumeration process. After the enumeration process is complete (which can 
567:               be determined when USBGetDeviceState() returns CONFIGURED_STATE), the 
568:               USBDeviceTasks() handler may be called the faster of: either once 
569:               every 9.8ms, or as often as needed to make sure that the hardware USTAT 
570:               FIFO never gets full.  A good rule of thumb is to call USBDeviceTasks() at
571:               a minimum rate of either the frequency that USBTransferOnePacket() gets 
572:               called, or, once/1.8ms, whichever is faster.  See the inline code comments 
573:               near the top of usb_device.c for more details about minimum timing 
574:               requirements when calling USBDeviceTasks().
575:               
576:               When the USB stack is operated in "USB_INTERRUPT" mode, it is not necessary
577:               to call USBDeviceTasks() from the main loop context.  In the USB_INTERRUPT
578:               mode, the USBDeviceTasks() handler only needs to execute when a USB 
579:               interrupt occurs, and therefore only needs to be called from the interrupt 
580:               context.
581:           
582:             Description:
583:               This function is the main state machine/transaction handler of the USB 
584:               device side stack.  When the USB stack is operated in "USB_POLLING" mode 
585:               (usb_config.h user option) the USBDeviceTasks() function should be called 
586:               periodically to receive and transmit packets through the stack. This 
587:               function also takes care of control transfers associated with the USB 
588:               enumeration process, and detecting various USB events (such as suspend).  
589:               This function should be called at least once every 1.8ms during the USB 
590:               enumeration process. After the enumeration process is complete (which can 
591:               be determined when USBGetDeviceState() returns CONFIGURED_STATE), the 
592:               USBDeviceTasks() handler may be called the faster of: either once 
593:               every 9.8ms, or as often as needed to make sure that the hardware USTAT 
594:               FIFO never gets full.  A good rule of thumb is to call USBDeviceTasks() at
595:               a minimum rate of either the frequency that USBTransferOnePacket() gets 
596:               called, or, once/1.8ms, whichever is faster.  See the inline code comments 
597:               near the top of usb_device.c for more details about minimum timing 
598:               requirements when calling USBDeviceTasks().
599:               
600:               When the USB stack is operated in "USB_INTERRUPT" mode, it is not necessary
601:               to call USBDeviceTasks() from the main loop context.  In the USB_INTERRUPT
602:               mode, the USBDeviceTasks() handler only needs to execute when a USB 
603:               interrupt occurs, and therefore only needs to be called from the interrupt 
604:               context.
605:           
606:               Typical usage:
607:               <code>
608:               void main(void)
609:               {
610:                   USBDeviceInit();
611:                   while(1)
612:                   {
613:                       USBDeviceTasks(); //Takes care of enumeration and other USB events
614:                       if((USBGetDeviceState() \< CONFIGURED_STATE) ||
615:                          (USBIsDeviceSuspended() == TRUE))
616:                       {
617:                           //Either the device is not configured or we are suspended,
618:                           // so we don't want to execute any USB related application code
619:                           continue;   //go back to the top of the while loop
620:                       }
621:                       else
622:                       {
623:                           //Otherwise we are free to run USB and non-USB related user 
624:                           //application code.
625:                           UserApplication();
626:                       }
627:                   }
628:               }
629:               </code>
630:           
631:             Precondition:
632:               Make sure the USBDeviceInit() function has been called prior to calling
633:               USBDeviceTasks() for the first time.
634:             Remarks:
635:               USBDeviceTasks() does not need to be called while in the USB suspend mode, 
636:               if the user application firmware in the USBCBSuspend() callback function
637:               enables the ACTVIF USB interrupt source and put the microcontroller into 
638:               sleep mode.  If the application firmware decides not to sleep the 
639:               microcontroller core during USB suspend (ex: continues running at full 
640:               frequency, or clock switches to a lower frequency), then the USBDeviceTasks()
641:               function must still be called periodically, at a rate frequent enough to 
642:               ensure the 10ms resume recovery interval USB specification is met.  Assuming
643:               a worst case primary oscillator and PLL start up time of <5ms, then 
644:               USBDeviceTasks() should be called once every 5ms in this scenario.
645:              
646:               When the USB cable is detached, or the USB host is not actively powering 
647:               the VBUS line to +5V nominal, the application firmware does not always have 
648:               to call USBDeviceTasks() frequently, as no USB activity will be taking 
649:               place.  However, if USBDeviceTasks() is not called regularly, some 
650:               alternative means of promptly detecting when VBUS is powered (indicating 
651:               host attachment), or not powered (host powered down or USB cable unplugged)
652:               is still needed.  For self or dual self/bus powered USB applications, see 
653:               the USBDeviceAttach() and USBDeviceDetach() API documentation for additional 
654:               considerations.
655:                                
656:             **************************************************************************/
657:           
658:           #if defined(USB_INTERRUPT) 
659:           #if defined(__18CXX) || defined (_PIC14E)
660:               void USBDeviceTasks(void)
661:             #elif defined(__C30__) || defined __XC16__
662:               void __attribute__((interrupt,auto_psv)) _USB1Interrupt()
663:             #elif defined(__PIC32MX__)
664:               void __attribute__((interrupt(),vector(_USB_1_VECTOR))) _USB1Interrupt( void ) 
665:             #endif
666:           #else
667:           void USBDeviceTasks(void)
668:           #endif
669:           {
670:               BYTE i;
671:           
672:           #ifdef USB_SUPPORT_OTG
673:               //SRP Time Out Check
674:               if (USBOTGSRPIsReady())
675:               {
676:                   if (USBT1MSECIF && USBT1MSECIE)
677:                   {
678:                       if (USBOTGGetSRPTimeOutFlag())
679:                       {
680:                           if (USBOTGIsSRPTimeOutExpired())
681:                           {
682:                               USB_OTGEventHandler(0,OTG_EVENT_SRP_FAILED,0,0);
683:                           }       
684:                       }
685:           
686:                       //Clear Interrupt Flag
687:                       USBClearInterruptFlag(USBT1MSECIFReg,USBT1MSECIFBitNum);
688:                   }
689:               }
690:           #endif
691:           
692:               #if defined(USB_POLLING)
693:               //If the interrupt option is selected then the customer is required
694:               //  to notify the stack when the device is attached or removed from the
695:               //  bus by calling the USBDeviceAttach() and USBDeviceDetach() functions.
696:               if (USB_BUS_SENSE != 1)
697:               {
698:                    // Disable module & detach from bus
699:                    U1CON = 0;             
700:           
701:                    // Mask all USB interrupts              
702:                    U1IE = 0;          
703:           
704:                    //Move to the detached state                  
705:                    USBDeviceState = DETACHED_STATE;
706:           
707:                    #ifdef  USB_SUPPORT_OTG    
708:                        //Disable D+ Pullup
709:                        U1OTGCONbits.DPPULUP = 0;
710:           
711:                        //Disable HNP
712:                        USBOTGDisableHnp();
713:           
714:                        //Deactivate HNP
715:                        USBOTGDeactivateHnp();
716:                        
717:                        //If ID Pin Changed State
718:                        if (USBIDIF && USBIDIE)
719:                        {  
720:                            //Re-detect & Initialize
721:                             USBOTGInitialize();
722:           
723:                             //Clear ID Interrupt Flag
724:                             USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
725:                        }
726:                    #endif
727:           
728:                    #if defined __C30__ || defined __XC16__
729:                        //USBClearInterruptFlag(U1OTGIR, 3); 
730:                    #endif
731:                       //return so that we don't go through the rest of 
732:                       //the state machine
733:                    USBClearUSBInterrupt();
734:                    return;
735:               }
736:           
737:           	#ifdef USB_SUPPORT_OTG
738:               //If Session Is Started Then
739:               else
740:           	{
741:                   //If SRP Is Ready
742:                   if (USBOTGSRPIsReady())
743:                   {   
744:                       //Clear SRPReady
745:                       USBOTGClearSRPReady();
746:           
747:                       //Clear SRP Timeout Flag
748:                       USBOTGClearSRPTimeOutFlag();
749:           
750:                       //Indicate Session Started
751:                       UART2PrintString( "\r\n***** USB OTG B Event - Session Started  *****\r\n" );
752:                   }
753:               }
754:           	#endif	//#ifdef USB_SUPPORT_OTG
755:           
756:               //if we are in the detached state
757:               if(USBDeviceState == DETACHED_STATE)
0141  0021     MOVLB 0x1
0142  08EA     MOVF pBDTEntryIn, F
0143  1D03     BTFSS STATUS, 0x2
0144  2952     GOTO 0x152
758:               {
759:           	    //Initialize register to known value
760:                   U1CON = 0;                          
0145  003D     MOVLB 0x1D
0146  018E     CLRF PORTC
761:           
762:                   // Mask all USB interrupts
763:                   U1IE = 0;                                
0147  0192     CLRF PIR2
764:           
765:                   //Enable/set things like: pull ups, full/low-speed mode, 
766:                   //set the ping pong mode, and set internal transceiver
767:                   SetConfigurationOptions();
0148  3016     MOVLW 0x16
0149  23DE     CALL 0x3DE
014A  3180     MOVLP 0x0
768:           
769:                   // Enable module & attach to bus
770:                   while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
014B  198E     BTFSC PORTC, 0x3
014C  294F     GOTO 0x14F
014D  158E     BSF PORTC, 0x3
014E  294B     GOTO 0x14B
771:           
772:                   //moved to the attached state
773:                   USBDeviceState = ATTACHED_STATE;
014F  0021     MOVLB 0x1
0150  01EA     CLRF pBDTEntryIn
0151  0AEA     INCF pBDTEntryIn, F
774:           
775:                   #ifdef  USB_SUPPORT_OTG
776:                       U1OTGCON |= USB_OTG_DPLUS_ENABLE | USB_OTG_ENABLE;  
777:                   #endif
778:               }
779:           	#endif  //#if defined(USB_POLLING)
780:           
781:               if(USBDeviceState == ATTACHED_STATE)
0152  036A     DECF pBDTEntryIn, W
0153  1D03     BTFSS STATUS, 0x2
0154  295F     GOTO 0x15F
782:               {
783:                   /*
784:                    * After enabling the USB module, it takes some time for the
785:                    * voltage on the D+ or D- line to rise high enough to get out
786:                    * of the SE0 condition. The USB Reset interrupt should not be
787:                    * unmasked until the SE0 condition is cleared. This helps
788:                    * prevent the firmware from misinterpreting this unique event
789:                    * as a USB bus reset from the USB host.
790:                    */
791:           
792:                   if(!USBSE0Event)
0155  003D     MOVLB 0x1D
0156  1A8E     BTFSC PORTC, 0x5
0157  295F     GOTO 0x15F
793:                   {
794:                       USBClearInterruptRegister(U1IR);// Clear all USB interrupts
0158  0190     CLRF 0x10
795:                       #if defined(USB_POLLING)
796:                           U1IE=0;                        // Mask all USB interrupts
0159  0192     CLRF PIR2
797:                       #endif
798:                       USBResetIE = 1;             // Unmask RESET interrupt
015A  1412     BSF PIR2, 0x0
799:                       USBIdleIE = 1;             // Unmask IDLE interrupt
015B  1612     BSF PIR2, 0x4
800:                       USBDeviceState = POWERED_STATE;
015C  3002     MOVLW 0x2
015D  0021     MOVLB 0x1
015E  00EA     MOVWF pBDTEntryIn
801:                   }
802:               }
803:           
804:               #ifdef  USB_SUPPORT_OTG
805:                   //If ID Pin Changed State
806:                   if (USBIDIF && USBIDIE)
807:                   {  
808:                       //Re-detect & Initialize
809:                       USBOTGInitialize();
810:           
811:                       USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
812:                   }
813:               #endif
814:           
815:               /*
816:                * Task A: Service USB Activity Interrupt
817:                */
818:               if(USBActivityIF && USBActivityIE)
015F  003D     MOVLB 0x1D
0160  1910     BTFSC 0x10, 0x2
0161  1D12     BTFSS PIR2, 0x2
0162  2966     GOTO 0x166
819:               {
820:                   USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
0163  1110     BCF 0x10, 0x2
821:                   #if defined(USB_SUPPORT_OTG)
822:                       U1OTGIR = 0x10;        
823:                   #else
824:                       USBWakeFromSuspend();
0164  2330     CALL 0x330
0165  3180     MOVLP 0x0
825:                   #endif
826:               }
827:           
828:               /*
829:                * Pointless to continue servicing if the device is in suspend mode.
830:                */
831:               if(USBSuspendControl==1)
0166  1C8E     BTFSS PORTC, 0x1
0167  296B     GOTO 0x16B
832:               {
833:                   USBClearUSBInterrupt();
0168  0020     MOVLB 0x0
0169  1112     BCF PIR2, 0x2
834:                   return;
016A  0008     RETURN
835:               }
836:           
837:               /*
838:                * Task B: Service USB Bus Reset Interrupt.
839:                * When bus reset is received during suspend, ACTVIF will be set first,
840:                * once the UCONbits.SUSPND is clear, then the URSTIF bit will be asserted.
841:                * This is why URSTIF is checked after ACTVIF.
842:                *
843:                * The USB reset flag is masked when the USB state is in
844:                * DETACHED_STATE or ATTACHED_STATE, and therefore cannot
845:                * cause a USB reset event during these two states.
846:                */
847:               if(USBResetIF && USBResetIE)
016B  1810     BTFSC 0x10, 0x0
016C  1C12     BTFSS PIR2, 0x0
016D  2974     GOTO 0x174
848:               {
849:                   USBDeviceInit();
016E  2213     CALL 0x213
016F  3180     MOVLP 0x0
850:           
851:                   //Re-enable the interrupts since the USBDeviceInit() function will
852:                   //  disable them.  This will do nothing in a polling setup
853:                   USBUnmaskInterrupts();
854:           
855:                   USBDeviceState = DEFAULT_STATE;
0170  3004     MOVLW 0x4
0171  00EA     MOVWF pBDTEntryIn
856:           
857:                   #ifdef USB_SUPPORT_OTG
858:                        //Disable HNP
859:                        USBOTGDisableHnp();
860:           
861:                        //Deactivate HNP
862:                        USBOTGDeactivateHnp();
863:                   #endif
864:           
865:                   USBClearInterruptFlag(USBResetIFReg,USBResetIFBitNum);
0172  003D     MOVLB 0x1D
0173  1010     BCF 0x10, 0x0
866:               }
867:           
868:               /*
869:                * Task C: Service other USB interrupts
870:                */
871:               if(USBIdleIF && USBIdleIE)
0174  1A10     BTFSC 0x10, 0x4
0175  1E12     BTFSS PIR2, 0x4
0176  297B     GOTO 0x17B
872:               { 
873:                   #ifdef  USB_SUPPORT_OTG 
874:                       //If Suspended, Try to switch to Host
875:                       USBOTGSelectRole(ROLE_HOST);
876:                   #else
877:                       USBSuspend();
0177  2329     CALL 0x329
0178  3180     MOVLP 0x0
878:                   #endif
879:                   
880:                   USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
0179  003D     MOVLB 0x1D
017A  1210     BCF 0x10, 0x4
881:               }
882:           
883:               if(USBSOFIF)
017B  1F10     BTFSS 0x10, 0x6
017C  2992     GOTO 0x192
884:               {
885:                   if(USBSOFIE)
017D  1F12     BTFSS PIR2, 0x6
017E  2987     GOTO 0x187
886:                   {
887:                       USB_SOF_HANDLER(EVENT_SOF,0,1);
017F  3073     MOVLW 0x73
0180  0020     MOVLB 0x0
0181  00E0     MOVWF count
0182  01E1     CLRF 0x61
0183  23E4     CALL 0x3E4
0184  3180     MOVLP 0x0
0185  21E4     CALL 0x1E4
0186  3180     MOVLP 0x0
888:                   }    
889:                   USBClearInterruptFlag(USBSOFIFReg,USBSOFIFBitNum);
0187  003D     MOVLB 0x1D
0188  1310     BCF 0x10, 0x6
890:                   
891:                   #if defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)
892:                       //Supporting this feature requires a 1ms timebase for keeping track of the timeout interval.
893:                       #if(USB_SPEED_OPTION == USB_LOW_SPEED)
894:                           #warning "Double click this message.  See inline code comments."
895:                           //The "USB_ENABLE_STATUS_STAGE_TIMEOUTS" feature is optional and is
896:                           //not strictly needed in all applications (ex: those that never call 
897:                           //USBDeferStatusStage() and don't use host to device (OUT) control
898:                           //transfers with data stage).  
899:                           //However, if this feature is enabled and used, it requires a timer 
900:                           //(preferrably 1ms) to decrement the USBStatusStageTimeoutCounter.  
901:                           //In USB Full Speed applications, the host sends Start-of-Frame (SOF) 
902:                           //packets at a 1ms rate, which generates SOFIF interrupts.
903:                           //These interrupts can be used to decrement USBStatusStageTimeoutCounter as shown 
904:                           //below.  However, the host does not send SOF packets to Low Speed devices.  
905:                           //Therefore, some other method  (ex: using a general purpose microcontroller 
906:                           //timer, such as Timer0) needs to be implemented to call and execute the below code
907:                           //at a once/1ms rate, in a low speed USB application.
908:                           //Note: Pre-condition to executing the below code: USBDeviceInit() should have
909:                           //been called at least once (since the last microcontroller reset/power up), 
910:                           //prior to executing the below code.
911:                       #endif
912:                       
913:                       //Decrement our status stage counter.
914:                       if(USBStatusStageTimeoutCounter != 0u)
0189  0022     MOVLB 0x2
018A  0838     MOVF 0x38, W
018B  1D03     BTFSS STATUS, 0x2
915:                       {
916:                           USBStatusStageTimeoutCounter--;
018C  03B8     DECF 0x38, F
917:                       }
918:                       //Check if too much time has elapsed since progress was made in 
919:                       //processing the control transfer, without arming the status stage.  
920:                       //If so, auto-arm the status stage to ensure that the control 
921:                       //transfer can [eventually] complete, within the timing limits
922:                       //dictated by section 9.2.6 of the official USB 2.0 specifications.
923:                       if(USBStatusStageTimeoutCounter == 0)
018D  08B8     MOVF 0x38, F
018E  1D03     BTFSS STATUS, 0x2
018F  2992     GOTO 0x192
924:                       {
925:                           USBCtrlEPAllowStatusStage();    //Does nothing if the status stage was already armed.
0190  2283     CALL 0x283
0191  3180     MOVLP 0x0
926:                       } 
927:                   #endif
928:               }
929:           
930:               if(USBStallIF && USBStallIE)
0192  003D     MOVLB 0x1D
0193  1A90     BTFSC 0x10, 0x5
0194  1E92     BTFSS PIR2, 0x5
0195  2998     GOTO 0x198
931:               {
932:                   USBStallHandler();
0196  2311     CALL 0x311
0197  3180     MOVLP 0x0
933:               }
934:           
935:               if(USBErrorIF && USBErrorIE)
0198  1890     BTFSC 0x10, 0x1
0199  1C92     BTFSS PIR2, 0x1
019A  29A6     GOTO 0x1A6
936:               {
937:                   USB_ERROR_HANDLER(EVENT_BUS_ERROR,0,1);
019B  30FF     MOVLW 0xFF
019C  0020     MOVLB 0x0
019D  00E0     MOVWF count
019E  307F     MOVLW 0x7F
019F  00E1     MOVWF 0x61
01A0  23E4     CALL 0x3E4
01A1  3180     MOVLP 0x0
01A2  21E4     CALL 0x1E4
01A3  3180     MOVLP 0x0
938:                   USBClearInterruptRegister(U1EIR);               // This clears UERRIF
01A4  003D     MOVLB 0x1D
01A5  0193     CLRF 0x13
939:           
940:                   //On PIC18, clearing the source of the error will automatically clear
941:                   //  the interrupt flag.  On other devices the interrupt flag must be 
942:                   //  manually cleared. 
943:                   #if defined(__C32__) || defined(__C30__) || defined __XC16__
944:                       USBClearInterruptFlag( USBErrorIFReg, USBErrorIFBitNum );
945:                   #endif
946:               }
947:           
948:               /*
949:                * Pointless to continue servicing if the host has not sent a bus reset.
950:                * Once bus reset is received, the device transitions into the DEFAULT
951:                * state and is ready for communication.
952:                */
953:               if(USBDeviceState < DEFAULT_STATE)
01A6  3004     MOVLW 0x4
01A7  0021     MOVLB 0x1
01A8  026A     SUBWF pBDTEntryIn, W
01A9  1C03     BTFSS STATUS, 0x0
01AA  2968     GOTO 0x168
954:               {
955:           	    USBClearUSBInterrupt();
956:           	    return; 
957:           	}  
958:           
959:               /*
960:                * Task D: Servicing USB Transaction Complete Interrupt
961:                */
962:               if(USBTransactionCompleteIE)
01AB  003D     MOVLB 0x1D
01AC  1D92     BTFSS PIR2, 0x3
01AD  2968     GOTO 0x168
963:               {
964:           	    for(i = 0; i < 4u; i++)	//Drain or deplete the USAT FIFO entries.  If the USB FIFO ever gets full, USB bandwidth 
01AE  0021     MOVLB 0x1
01AF  01A7     CLRF 0x27
01DD  0021     MOVLB 0x1
01DE  3004     MOVLW 0x4
01DF  0AA7     INCF 0x27, F
01E0  0227     SUBWF 0x27, W
01E1  1803     BTFSC STATUS, 0x0
01E2  2968     GOTO 0x168
01E3  29B0     GOTO 0x1B0
965:           		{						//utilization can be compromised, and the device won't be able to receive SETUP packets.
966:           		    if(USBTransactionCompleteIF)
01B0  003D     MOVLB 0x1D
01B1  1D90     BTFSS 0x10, 0x3
01B2  2968     GOTO 0x168
967:           		    {
968:               		    //Save and extract USTAT register info.  Will use this info later.
969:                           USTATcopy.Val = U1STAT;
01B3  080F     MOVF 0xF, W
01B4  0021     MOVLB 0x1
01B5  00EF     MOVWF pBDTEntryEP0OutNext
970:                           endpoint_number = USBHALGetLastEndpoint(USTATcopy);
01B6  0C6F     RRF pBDTEntryEP0OutNext, W
01B7  00A6     MOVWF 0x26
01B8  0CA6     RRF 0x26, F
01B9  0C26     RRF 0x26, W
01BA  390F     ANDLW 0xF
01BB  0022     MOVLB 0x2
01BC  00BB     MOVWF 0x3B
971:                           
972:                           USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
01BD  003D     MOVLB 0x1D
01BE  1190     BCF 0x10, 0x3
973:                           
974:                           //Keep track of the hardware ping pong state for endpoints other
975:                           //than EP0, if ping pong buffering is enabled.
976:                           #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) 
977:                               if(USBHALGetLastDirection(USTATcopy) == OUT_FROM_HOST)
01BF  0021     MOVLB 0x1
01C0  196F     BTFSC pBDTEntryEP0OutNext, 0x2
01C1  29C6     GOTO 0x1C6
978:                               {
979:                                   ep_data_out[endpoint_number].bits.ping_pong_state ^= 1;
01C2  0022     MOVLB 0x2
01C3  083B     MOVF 0x3B, W
01C4  3E28     ADDLW 0x28
01C5  29C9     GOTO 0x1C9
980:                               }   
981:                               else
982:                               {
983:                                   ep_data_in[endpoint_number].bits.ping_pong_state ^= 1;
01C6  0022     MOVLB 0x2
01C7  083B     MOVF 0x3B, W
01C8  3E26     ADDLW 0x26
01C9  0086     MOVWF FSR1L
01CA  3001     MOVLW 0x1
01CB  0087     MOVWF FSR1H
01CC  0681     XORWF INDF1, F
984:                               }         
985:                           #endif    
986:                           
987:                           //USBCtrlEPService only services transactions over EP0.
988:                           //It ignores all other EP transactions.
989:                           if(endpoint_number == 0)
01CD  08BB     MOVF 0x3B, F
01CE  1D03     BTFSS STATUS, 0x2
01CF  29D3     GOTO 0x1D3
990:                           {
991:                               USBCtrlEPService();
01D0  22BD     CALL 0x2BD
01D1  3180     MOVLP 0x0
992:                           }
01D2  29DD     GOTO 0x1DD
993:                           else
994:                           {
995:                               USB_TRANSFER_COMPLETE_HANDLER(EVENT_TRANSFER, (BYTE*)&USTATcopy.Val, 0);
01D3  3072     MOVLW 0x72
01D4  0020     MOVLB 0x0
01D5  00E0     MOVWF count
01D6  30EF     MOVLW 0xEF
01D7  01E1     CLRF 0x61
01D8  00E2     MOVWF 0x62
01D9  01E3     CLRF 0x63
01DA  01E4     CLRF 0x64
01DB  21E4     CALL 0x1E4
01DC  3180     MOVLP 0x0
996:                           }
997:           		    }//end if(USBTransactionCompleteIF)
998:           		    else
999:           		    	break;	//USTAT FIFO must be empty.
1000:          		}//end for()
1001:          	}//end if(USBTransactionCompleteIE)   
1002:          
1003:              USBClearUSBInterrupt();
1004:          }//end of USBDeviceTasks()
01E4  0861     MOVF 0x61, W
1005:          
1006:          /*******************************************************************************
1007:            Function:
1008:                  void USBEnableEndpoint(BYTE ep, BYTE options)
1009:              
1010:            Summary:
1011:              This function will enable the specified endpoint with the specified
1012:              options
1013:            Description:
1014:              This function will enable the specified endpoint with the specified
1015:              options.
1016:              
1017:              Typical Usage:
1018:              <code>
1019:              void USBCBInitEP(void)
1020:              {
1021:                  USBEnableEndpoint(MSD_DATA_IN_EP,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
1022:                  USBMSDInit();
1023:              }
1024:              </code>
1025:              
1026:              In the above example endpoint number MSD_DATA_IN_EP is being configured
1027:              for both IN and OUT traffic with handshaking enabled. Also since
1028:              MSD_DATA_IN_EP is not endpoint 0 (MSD does not allow this), then we can
1029:              explicitly disable SETUP packets on this endpoint.
1030:            Conditions:
1031:              None
1032:            Input:
1033:              BYTE ep -       the endpoint to be configured
1034:              BYTE options -  optional settings for the endpoint. The options should
1035:                              be ORed together to form a single options string. The
1036:                              available optional settings for the endpoint. The
1037:                              options should be ORed together to form a single options
1038:                              string. The available options are the following\:
1039:                              * USB_HANDSHAKE_ENABLED enables USB handshaking (ACK,
1040:                                NAK)
1041:                              * USB_HANDSHAKE_DISABLED disables USB handshaking (ACK,
1042:                                NAK)
1043:                              * USB_OUT_ENABLED enables the out direction
1044:                              * USB_OUT_DISABLED disables the out direction
1045:                              * USB_IN_ENABLED enables the in direction
1046:                              * USB_IN_DISABLED disables the in direction
1047:                              * USB_ALLOW_SETUP enables control transfers
1048:                              * USB_DISALLOW_SETUP disables control transfers
1049:                              * USB_STALL_ENDPOINT STALLs this endpoint
1050:            Return:
1051:              None
1052:            Remarks:
1053:              None                                                                                                          
1054:            *****************************************************************************/
1055:          void USBEnableEndpoint(BYTE ep, BYTE options)
1056:          {
1057:              unsigned char* p;
1058:                  
1059:              //Use USBConfigureEndpoint() to set up the pBDTEntryIn/Out[ep] pointer and 
1060:              //starting DTS state in the BDT entry.
1061:              if(options & USB_OUT_ENABLED)
0348  00DF     MOVWF handle
0349  1D5A     BTFSS i_718, 0x2
034A  2B4E     GOTO 0x34E
1062:              {
1063:                  USBConfigureEndpoint(ep, OUT_FROM_HOST);
034B  01D6     CLRF direction
034C  2367     CALL 0x367
034D  3180     MOVLP 0x0
1064:              }
1065:              if(options & USB_IN_ENABLED)
034E  1CDA     BTFSS i_718, 0x1
034F  2B54     GOTO 0x354
1066:              {
1067:                  USBConfigureEndpoint(ep, IN_TO_HOST);
0350  01D6     CLRF direction
0351  0AD6     INCF direction, F
0352  085F     MOVF handle, W
0353  2367     CALL 0x367
1068:              }
1069:          
1070:              //Update the relevant UEPx register to actually enable the endpoint with
1071:              //the specified options (ex: handshaking enabled, control transfers allowed,
1072:              //etc.)
1073:              #if defined(__C32__)
1074:                  p = (unsigned char*)(&U1EP0+(4*ep));
1075:              #else
1076:                  p = (unsigned char*)(&U1EP0+ep);
0354  085F     MOVF handle, W
0355  3E98     ADDLW 0x98
0356  00DB     MOVWF i
0357  300E     MOVLW 0xE
0358  01DC     CLRF work
0359  3DDC     ADDWFC work, F
035A  085B     MOVF i, W
035B  00DD     MOVWF y
035C  085C     MOVF work, W
035D  00DE     MOVWF data
1077:              #endif
1078:              *p = options;
035E  085A     MOVF i_718, W
035F  00DB     MOVWF i
0360  085D     MOVF y, W
0361  0086     MOVWF FSR1L
0362  085E     MOVF data, W
0363  0087     MOVWF FSR1H
0364  085B     MOVF i, W
0365  0081     MOVWF INDF1
1079:          }
0366  0008     RETURN
1080:          
1081:          
1082:          /*************************************************************************
1083:            Function:
1084:              USB_HANDLE USBTransferOnePacket(BYTE ep, BYTE dir, BYTE* data, BYTE len)
1085:              
1086:            Summary:
1087:              Transfers a single packet (one transaction) of data on the USB bus.
1088:          
1089:            Description:
1090:              The USBTransferOnePacket() function prepares a USB endpoint
1091:              so that it may send data to the host (an IN transaction), or 
1092:              receive data from the host (an OUT transaction).  The 
1093:              USBTransferOnePacket() function can be used both to receive	and 
1094:              send data to the host.  This function is the primary API function 
1095:              provided by the USB stack firmware for sending or receiving application 
1096:              data over the USB port.  
1097:          
1098:              The USBTransferOnePacket() is intended for use with all application 
1099:              endpoints.  It is not used for sending or receiving applicaiton data 
1100:              through endpoint 0 by using control transfers.  Separate API 
1101:              functions, such as USBEP0Receive(), USBEP0SendRAMPtr(), and
1102:              USBEP0SendROMPtr() are provided for this purpose.
1103:          
1104:              The	USBTransferOnePacket() writes to the Buffer Descriptor Table (BDT)
1105:              entry associated with an endpoint buffer, and sets the UOWN bit, which 
1106:              prepares the USB hardware to allow the transaction to complete.  The 
1107:              application firmware can use the USBHandleBusy() macro to check the 
1108:              status of the transaction, to see if the data has been successfully 
1109:              transmitted yet.
1110:          
1111:          
1112:              Typical Usage
1113:              <code>
1114:              //make sure that the we are in the configured state
1115:              if(USBGetDeviceState() == CONFIGURED_STATE)
1116:              {
1117:                  //make sure that the last transaction isn't busy by checking the handle
1118:                  if(!USBHandleBusy(USBInHandle))
1119:                  {
1120:          	        //Write the new data that we wish to send to the host to the INPacket[] array
1121:          	        INPacket[0] = USEFUL_APPLICATION_VALUE1;
1122:          	        INPacket[1] = USEFUL_APPLICATION_VALUE2;
1123:          	        //INPacket[2] = ... (fill in the rest of the packet data)
1124:          	      
1125:                      //Send the data contained in the INPacket[] array through endpoint "EP_NUM"
1126:                      USBInHandle = USBTransferOnePacket(EP_NUM,IN_TO_HOST,(BYTE*)&INPacket[0],sizeof(INPacket));
1127:                  }
1128:              }
1129:              </code>
1130:          
1131:            Conditions:
1132:              Before calling USBTransferOnePacket(), the following should be true.
1133:              1.  The USB stack has already been initialized (USBDeviceInit() was called).
1134:              2.  A transaction is not already pending on the specified endpoint.  This
1135:                  is done by checking the previous request using the USBHandleBusy() 
1136:                  macro (see the typical usage example).
1137:              3.  The host has already sent a set configuration request and the 
1138:                  enumeration process is complete.
1139:                  This can be checked by verifying that the USBGetDeviceState() 
1140:                  macro returns "CONFIGURED_STATE", prior to calling 
1141:                  USBTransferOnePacket().
1142:           					
1143:            Input:
1144:              BYTE ep - The endpoint number that the data will be transmitted or 
1145:          	          received on
1146:              BYTE dir - The direction of the transfer
1147:                         This value is either OUT_FROM_HOST or IN_TO_HOST
1148:              BYTE* data - For IN transactions: pointer to the RAM buffer containing 
1149:                           the data to be sent to the host.  For OUT transactions: pointer
1150:                           to the RAM buffer that the received data should get written to.
1151:             BYTE len - Length of the data needing to be sent (for IN transactions).
1152:                        For OUT transactions, the len parameter should normally be set
1153:                        to the endpoint size specified in the endpoint descriptor.    
1154:          
1155:            Return Values:
1156:              USB_HANDLE - handle to the transfer.  The handle is a pointer to 
1157:                           the BDT entry associated with this transaction.  The
1158:                           status of the transaction (ex: if it is complete or still
1159:                           pending) can be checked using the USBHandleBusy() macro
1160:                           and supplying the USB_HANDLE provided by
1161:                           USBTransferOnePacket().
1162:          
1163:            Remarks:
1164:              If calling the USBTransferOnePacket() function from within the USBCBInitEP()
1165:              callback function, the set configuration is still being processed and the
1166:              USBDeviceState may not be == CONFIGURED_STATE yet.  In this	special case, 
1167:              the USBTransferOnePacket() may still be called, but make sure that the 
1168:              endpoint has been enabled and initialized by the USBEnableEndpoint() 
1169:              function first.  
1170:              
1171:            *************************************************************************/
1172:          USB_HANDLE USBTransferOnePacket(BYTE ep,BYTE dir,BYTE* data,BYTE len)
1173:          {
1174:              volatile BDT_ENTRY* handle;
1175:          
1176:              //If the direction is IN
1177:              if(dir != 0)
0DB2  00DE     MOVWF data
0DB3  0859     MOVF x, W
0DB4  1903     BTFSC STATUS, 0x2
0DB5  2DBB     GOTO 0x5BB
1178:              {
1179:                  //point to the IN BDT of the specified endpoint
1180:                  handle = pBDTEntryIn[ep];
0DB6  085E     MOVF data, W
0DB7  3E6A     ADDLW 0x6A
0DB8  0086     MOVWF FSR1L
0DB9  0187     CLRF FSR1H
0DBA  2DBF     GOTO 0x5BF
1181:              }
1182:              else
1183:              {
1184:                  //else point to the OUT BDT of the specified endpoint
1185:                  handle = pBDTEntryOut[ep];
0DBB  085E     MOVF data, W
0DBC  3183     MOVLP 0x3
0DBD  23D3     CALL 0x3D3
0DBE  3188     MOVLP 0x8
0DBF  0801     MOVF INDF1, W
0DC0  00DF     MOVWF handle
1186:              }
1187:              
1188:              //Error checking code.  Make sure the handle (pBDTEntryIn[ep] or
1189:              //pBDTEntryOut[ep]) is initialized before using it.
1190:              if(handle == 0)
0DC1  08DF     MOVF handle, F
0DC2  1903     BTFSC STATUS, 0x2
1191:              {
1192:          	    return 0;
0DC3  3400     RETLW 0x0
1193:          	}
1194:          
1195:              //Toggle the DTS bit if required
1196:              #if (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
1197:                  handle->STAT.Val ^= _DTSMASK;
1198:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
1199:                  if(ep != 0)
1200:                  {
1201:                      handle->STAT.Val ^= _DTSMASK;
1202:                  }
1203:              #endif
1204:          
1205:              //Set the data pointer, data length, and enable the endpoint
1206:              handle->ADR = ConvertToPhysicalAddress(data);
0DC4  085A     MOVF i_718, W
0DC5  00DC     MOVWF work
0DC6  3002     MOVLW 0x2
0DC7  00DD     MOVWF y
0DC8  085F     MOVF handle, W
0DC9  3E02     ADDLW 0x2
0DCA  0086     MOVWF FSR1L
0DCB  0187     CLRF FSR1H
0DCC  085C     MOVF work, W
0DCD  3FC0     MOVWI [0]FSR1
0DCE  085D     MOVF y, W
0DCF  3FC1     MOVWI [1]FSR1
1207:              handle->CNT = len;
0DD0  0A5F     INCF handle, W
0DD1  0086     MOVWF FSR1L
0DD2  085B     MOVF i, W
0DD3  0081     MOVWF INDF1
1208:              handle->STAT.Val &= _DTSMASK;
0DD4  085F     MOVF handle, W
0DD5  0086     MOVWF FSR1L
0DD6  3040     MOVLW 0x40
0DD7  0581     ANDWF INDF1, F
1209:              handle->STAT.Val |= _USIE | (_DTSEN & _DTS_CHECKING_ENABLED);
0DD8  085F     MOVF handle, W
0DD9  0086     MOVWF FSR1L
0DDA  3088     MOVLW 0x88
0DDB  0481     IORWF INDF1, F
1210:          
1211:              //Point to the next buffer for ping pong purposes.
1212:              if(dir != OUT_FROM_HOST)
0DDC  0859     MOVF x, W
0DDD  1903     BTFSC STATUS, 0x2
0DDE  2DE3     GOTO 0x5E3
1213:              {
1214:                  //toggle over the to the next buffer for an IN endpoint
1215:                  USBAdvancePingPongBuffer(&pBDTEntryIn[ep]);      
0DDF  085E     MOVF data, W
0DE0  3E6A     ADDLW 0x6A
0DE1  0086     MOVWF FSR1L
0DE2  2DE6     GOTO 0x5E6
1216:              }
1217:              else
1218:              {
1219:                  //toggle over the to the next buffer for an OUT endpoint
1220:                  USBAdvancePingPongBuffer(&pBDTEntryOut[ep]);     
0DE3  085E     MOVF data, W
0DE4  3183     MOVLP 0x3
0DE5  23D3     CALL 0x3D3
0DE6  3004     MOVLW 0x4
0DE7  0681     XORWF INDF1, F
1221:              }
1222:              return (USB_HANDLE)handle;
0DE8  085F     MOVF handle, W
1223:          }
0DE9  0008     RETURN
1224:          
1225:          
1226:          /********************************************************************
1227:              Function:
1228:                  void USBStallEndpoint(BYTE ep, BYTE dir)
1229:                  
1230:              Summary:
1231:                   Configures the specified endpoint to send STALL to the host, the next
1232:                   time the host tries to access the endpoint.
1233:              
1234:              PreCondition:
1235:                  None
1236:                  
1237:              Parameters:
1238:                  BYTE ep - The endpoint number that should be configured to send STALL.
1239:                  BYTE dir - The direction of the endpoint to STALL, either 
1240:                             IN_TO_HOST or OUT_FROM_HOST.
1241:                  
1242:              Return Values:
1243:                  None
1244:                  
1245:              Remarks:
1246:                  None
1247:          
1248:           *******************************************************************/
1249:          void USBStallEndpoint(BYTE ep, BYTE dir)
1250:          {
1251:              BDT_ENTRY *p;
1252:          
1253:              if(ep == 0)
1254:              {
1255:                  //For control endpoints (ex: EP0), we need to STALL both IN and OUT
1256:                  //endpoints.  EP0 OUT must also be prepared to receive the next SETUP 
1257:                  //packet that will arrrive.
1258:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
1259:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
1260:                  pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
1261:                  pBDTEntryIn[0]->STAT.Val = _USIE|_BSTALL; 
1262:                         
1263:              }
1264:              else
1265:              {
1266:                  p = (BDT_ENTRY*)(&BDT[EP(ep,dir,0)]);
1267:                  p->STAT.Val |= _BSTALL | _USIE;
1268:              
1269:                  //If the device is in FULL or ALL_BUT_EP0 ping pong modes
1270:                  //then stall that entry as well
1271:                  #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
1272:              
1273:                  p = (BDT_ENTRY*)(&BDT[EP(ep,dir,1)]);
1274:                  p->STAT.Val |= _BSTALL | _USIE;
1275:                  #endif
1276:              }
1277:          }
1278:          
1279:          /**************************************************************************
1280:              Function:
1281:                  void USBCancelIO(BYTE endpoint)
1282:              
1283:              Description:
1284:                  This function cancels the transfers pending on the specified endpoint.
1285:                  This function can only be used after a SETUP packet is received and 
1286:                  before that setup packet is handled.  This is the time period in which
1287:                  the EVENT_EP0_REQUEST is thrown, before the event handler function
1288:                  returns to the stack.
1289:          
1290:              Precondition:
1291:            
1292:              Parameters:
1293:                  BYTE endpoint - the endpoint number you wish to cancel the transfers for
1294:               
1295:              Return Values:
1296:                  None
1297:                  
1298:              Remarks:
1299:                  None
1300:                                                                    
1301:            **************************************************************************/
1302:          void USBCancelIO(BYTE endpoint)
1303:          {
1304:              if(USBPacketDisable == 1)
1305:              {
1306:              	//The PKTDIS bit is currently set right now.  It is therefore "safe"
1307:              	//to mess with the BDT right now.
1308:              	pBDTEntryIn[endpoint]->Val &= _DTSMASK;	//Makes UOWN = 0 (_UCPU mode).  Deactivates endpoint.  Only sends NAKs.
1309:              	pBDTEntryIn[endpoint]->Val ^= _DTSMASK;	//Toggle the DTS bit.  This packet didn't get sent yet, and the next call to USBTransferOnePacket() will re-toggle the DTS bit back to the original (correct) value.
1310:              	
1311:              	//Need to do additional handling if ping-pong buffering is being used
1312:                  #if ((USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0))
1313:                  //Point to the next buffer for ping pong purposes.  UOWN getting cleared
1314:                  //(either due to SIE clearing it after a transaction, or the firmware
1315:                  //clearing it) makes hardware ping pong pointer advance.
1316:                  USBAdvancePingPongBuffer(&pBDTEntryIn[endpoint]);       
1317:              
1318:              	pBDTEntryIn[endpoint]->STAT.Val &= _DTSMASK;
1319:              	pBDTEntryIn[endpoint]->STAT.Val ^= _DTSMASK;
1320:                  #endif
1321:              }
1322:          }
1323:          
1324:          /**************************************************************************
1325:              Function:
1326:                  void USBDeviceDetach(void)
1327:             
1328:              Summary:
1329:                  This function configures the USB module to "soft detach" itself from
1330:                  the USB host.
1331:                  
1332:              Description:
1333:                  This function configures the USB module to perform a "soft detach"
1334:                  operation, by disabling the D+ (or D-) ~1.5k pull up resistor, which
1335:                  lets the host know the device is present and attached.  This will make
1336:                  the host think that the device has been unplugged.  This is potentially
1337:                  useful, as it allows the USB device to force the host to re-enumerate
1338:                  the device (on the firmware has re-enabled the USB module/pull up, by
1339:                  calling USBDeviceAttach(), to "soft re-attach" to the host).
1340:                  
1341:              Precondition:
1342:                  Should only be called when USB_INTERRUPT is defined.  See remarks
1343:                  section if USB_POLLING mode option is being used (usb_config.h option).
1344:          
1345:                  Additionally, this function should only be called from the main() loop 
1346:                  context.  Do not call this function from within an interrupt handler, as 
1347:                  this function may modify global interrupt enable bits and settings.
1348:                  
1349:              Parameters:
1350:                  None
1351:               
1352:              Return Values:
1353:                  None
1354:                  
1355:              Remarks:
1356:                  If the application firmware calls USBDeviceDetach(), it is strongly
1357:                  recommended that the firmware wait at least >= 80ms before calling
1358:                  USBDeviceAttach().  If the firmeware performs a soft detach, and then
1359:                  re-attaches too soon (ex: after a few micro seconds for instance), some
1360:                  hosts may interpret this as an unexpected "glitch" rather than as a
1361:                  physical removal/re-attachment of the USB device.  In this case the host
1362:                  may simply ignore the event without re-enumerating the device.  To 
1363:                  ensure that the host properly detects and processes the device soft
1364:                  detach/re-attach, it is recommended to make sure the device remains 
1365:                  detached long enough to mimic a real human controlled USB 
1366:                  unplug/re-attach event (ex: after calling USBDeviceDetach(), do not
1367:                  call USBDeviceAttach() for at least 80+ms, preferrably longer.
1368:                  
1369:                  Neither the USBDeviceDetach() or USBDeviceAttach() functions are blocking
1370:                  or take long to execute.  It is the application firmware's 
1371:                  responsibility for adding the 80+ms delay, when using these API 
1372:                  functions.
1373:                  
1374:                  Note: The Windows plug and play event handler processing is fairly 
1375:                  slow, especially in certain versions of Windows, and for certain USB
1376:                  device classes.  It has been observed that some device classes need to
1377:                  provide even more USB detach dwell interval (before calling 
1378:                  USBDeviceAttach()), in order to work correctly after re-enumeration.
1379:                  If the USB device is a CDC class device, it is recommended to wait
1380:                  at least 1.5 seconds or longer, before soft re-attaching to the host,
1381:                  to provide the plug and play event handler enough time to finish 
1382:                  processing the removal event, before the re-attach occurs.
1383:                  
1384:                  If the application is using the USB_POLLING mode option, then the 
1385:                  USBDeviceDetach() and USBDeviceAttach() functions are not available.  
1386:                  In this mode, the USB stack relies on the "#define USE_USB_BUS_SENSE_IO" 
1387:                  and "#define USB_BUS_SENSE" options in the 
1388:                  HardwareProfile  [platform name].h file. 
1389:          
1390:                  When using the USB_POLLING mode option, and the 
1391:                  "#define USE_USB_BUS_SENSE_IO" definition has been commented out, then 
1392:                  the USB stack assumes that it should always enable the USB module at 
1393:                  pretty much all times.  Basically, anytime the application firmware 
1394:                  calls USBDeviceTasks(), the firmware will automatically enable the USB 
1395:                  module.  This mode would typically be selected if the application was 
1396:                  designed to be a purely bus powered device.  In this case, the 
1397:                  application is powered from the +5V VBUS supply from the USB port, so 
1398:                  it is correct and sensible in this type of application to power up and 
1399:                  turn on the USB module, at anytime that the microcontroller is 
1400:                  powered (which implies the USB cable is attached and the host is also 
1401:                  powered).
1402:          
1403:                  In a self powered application, the USB stack is designed with the 
1404:                  intention that the user will enable the "#define USE_USB_BUS_SENSE_IO" 
1405:                  option in the HardwareProfile  [platform name].h file.  When this 
1406:                  option is defined, then the USBDeviceTasks() function will automatically 
1407:                  check the I/O pin port value of the designated pin (based on the 
1408:                  #define USB_BUS_SENSE option in the HardwareProfile  [platform name].h 
1409:                  file), every time the application calls USBDeviceTasks().  If the 
1410:                  USBDeviceTasks() function is executed and finds that the pin defined by 
1411:                  the #define USB_BUS_SENSE is in a logic low state, then it will 
1412:                  automatically disable the USB module and tri-state the D+ and D- pins.  
1413:                  If however the USBDeviceTasks() function is executed and finds the pin 
1414:                  defined by the #define USB_BUS_SENSE is in a logic high state, then it 
1415:                  will automatically enable the USB module, if it has not already been 
1416:                  enabled.        
1417:                                                                    
1418:            **************************************************************************/
1419:          #if defined(USB_INTERRUPT)
1420:          void USBDeviceDetach(void)
1421:          {
1422:              //If the interrupt option is selected then the customer is required
1423:              //  to notify the stack when the device is attached or removed from the
1424:              //  bus by calling the USBDeviceAttach() and USBDeviceDetach() functions.
1425:          #ifdef USB_SUPPORT_OTG
1426:              if (USB_BUS_SENSE != 1)
1427:          #endif
1428:              {
1429:                   // Disable module & detach from bus
1430:                   U1CON = 0;             
1431:          
1432:                   // Mask all USB interrupts              
1433:                   U1IE = 0;          
1434:          
1435:                   //Move to the detached state                  
1436:                   USBDeviceState = DETACHED_STATE;
1437:          
1438:                   #ifdef  USB_SUPPORT_OTG    
1439:                       //Disable D+ Pullup
1440:                       U1OTGCONbits.DPPULUP = 0;
1441:          
1442:                       //Disable HNP
1443:                       USBOTGDisableHnp();
1444:          
1445:                       //Deactivate HNP
1446:                       USBOTGDeactivateHnp();
1447:                       
1448:                       //If ID Pin Changed State
1449:                       if (USBIDIF && USBIDIE)
1450:                       {  
1451:                           //Re-detect & Initialize
1452:                            USBOTGInitialize();
1453:          
1454:                            //Clear ID Interrupt Flag
1455:                            USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
1456:                       }
1457:                   #endif
1458:          
1459:                   #if defined __C30__ || defined __XC16__
1460:                       //USBClearInterruptFlag(U1OTGIR, 3); 
1461:                   #endif
1462:                      //return so that we don't go through the rest of 
1463:                      //the state machine
1464:                    return;
1465:              }
1466:          
1467:          #ifdef USB_SUPPORT_OTG
1468:              //If Session Is Started Then
1469:             else
1470:             {
1471:                  //If SRP Is Ready
1472:                  if (USBOTGSRPIsReady())
1473:                  {   
1474:                      //Clear SRPReady
1475:                      USBOTGClearSRPReady();
1476:          
1477:                      //Clear SRP Timeout Flag
1478:                      USBOTGClearSRPTimeOutFlag();
1479:          
1480:                      //Indicate Session Started
1481:                      UART2PrintString( "\r\n***** USB OTG B Event - Session Started  *****\r\n" );
1482:                  }
1483:              }
1484:          #endif
1485:          }
1486:          #endif  //#if defined(USB_INTERRUPT)
1487:          /**************************************************************************
1488:              Function:
1489:                  void USBDeviceAttach(void)
1490:              
1491:              Summary:
1492:                  Checks if VBUS is present, and that the USB module is not already 
1493:                  initalized, and if so, enables the USB module so as to signal device 
1494:                  attachment to the USB host.   
1495:          
1496:              Description:
1497:                  This function indicates to the USB host that the USB device has been
1498:                  attached to the bus.  This function needs to be called in order for the
1499:                  device to start to enumerate on the bus.
1500:                          
1501:              Precondition:
1502:                  Should only be called when USB_INTERRUPT is defined.  Also, should only 
1503:                  be called from the main() loop context.  Do not call USBDeviceAttach()
1504:                  from within an interrupt handler, as the USBDeviceAttach() function
1505:                  may modify global interrupt enable bits and settings.
1506:          
1507:                  For normal USB devices:
1508:                  Make sure that if the module was previously on, that it has been turned off 
1509:                  for a long time (ex: 100ms+) before calling this function to re-enable the module.
1510:                  If the device turns off the D+ (for full speed) or D- (for low speed) ~1.5k ohm
1511:                  pull up resistor, and then turns it back on very quickly, common hosts will sometimes 
1512:                  reject this event, since no human could ever unplug and reattach a USB device in a 
1513:                  microseconds (or nanoseconds) timescale.  The host could simply treat this as some kind 
1514:                  of glitch and ignore the event altogether.  
1515:              Parameters:
1516:                  None
1517:               
1518:              Return Values:
1519:                  None       
1520:              
1521:              Remarks: 
1522:          		See also the USBDeviceDetach() API function documentation.                                                 
1523:          ****************************************************************************/
1524:          #if defined(USB_INTERRUPT)
1525:          void USBDeviceAttach(void)
1526:          {
1527:              //if we are in the detached state
1528:              if(USBDeviceState == DETACHED_STATE)
1529:              {
1530:                  if(USB_BUS_SENSE == 1)
1531:                  {
1532:              	    //Initialize registers to known states.
1533:                      U1CON = 0;          
1534:              
1535:                      // Mask all USB interrupts
1536:                      U1IE = 0;                                
1537:              
1538:                      //Configure things like: pull ups, full/low-speed mode, 
1539:                      //set the ping pong mode, and set internal transceiver
1540:                      SetConfigurationOptions();
1541:              
1542:                      USBEnableInterrupts();  //Modifies global interrupt settings
1543:              
1544:                      // Enable module & attach to bus
1545:                      while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
1546:              
1547:                      //moved to the attached state
1548:                      USBDeviceState = ATTACHED_STATE;
1549:              
1550:                      #ifdef  USB_SUPPORT_OTG
1551:                          U1OTGCON = USB_OTG_DPLUS_ENABLE | USB_OTG_ENABLE;  
1552:                      #endif
1553:                  }
1554:              }
1555:          }
1556:          #endif  //#if defined(USB_INTERRUPT)
1557:          
1558:          
1559:          /*******************************************************************************
1560:            Function: void USBCtrlEPAllowStatusStage(void);
1561:              
1562:            Summary: This function prepares the proper endpoint 0 IN or endpoint 0 OUT 
1563:                      (based on the controlTransferState) to allow the status stage packet
1564:                      of a control transfer to complete.  This function gets used 
1565:                      internally by the USB stack itself, but it may also be called from
1566:                      the application firmware, IF the application firmware called
1567:                      the USBDeferStatusStage() function during the initial processing
1568:                      of the control transfer request.  In this case, the application
1569:                      must call the USBCtrlEPAllowStatusStage() once, after it has fully
1570:                      completed processing and handling the data stage portion of the
1571:                      request.  
1572:                      
1573:                      If the application firmware has no need for delaying control 
1574:                      transfers, and therefore never calls USBDeferStatusStage(), then the
1575:                      application firmware should not call USBCtrlEPAllowStatusStage().
1576:                      
1577:            Description:
1578:              
1579:            Conditions:
1580:              None
1581:          
1582:            Input:
1583:          
1584:            Return:
1585:          
1586:            Remarks:
1587:              None                                                                                                          
1588:            *****************************************************************************/
1589:          void USBCtrlEPAllowStatusStage(void)
1590:          {
1591:              //Check and set two flags, prior to actually modifying any BDT entries.
1592:              //This double checking is necessary to make certain that 
1593:              //USBCtrlEPAllowStatusStage() can be called twice simultaneously (ex: once 
1594:              //in main loop context, while simultaneously getting an interrupt which 
1595:              //tries to call USBCtrlEPAllowStatusStage() again, at the same time).
1596:              if(USBStatusStageEnabledFlag1 == FALSE)
0283  0022     MOVLB 0x2
0284  08B6     MOVF 0x36, F
0285  1D03     BTFSS STATUS, 0x2
0286  0008     RETURN
1597:              {
1598:                  USBStatusStageEnabledFlag1 = TRUE;  
0287  3001     MOVLW 0x1
0288  00B6     MOVWF 0x36
1599:                  if(USBStatusStageEnabledFlag2 == FALSE)
0289  08B7     MOVF 0x37, F
028A  1D03     BTFSS STATUS, 0x2
028B  0008     RETURN
1600:                  {
1601:                      USBStatusStageEnabledFlag2 = TRUE;
028C  00B7     MOVWF 0x37
1602:                  
1603:                      //Determine which endpoints (EP0 IN or OUT needs arming for the status
1604:                      //stage), based on the type of control transfer currently pending.
1605:                      if(controlTransferState == CTRL_TRF_RX)
028D  0020     MOVLB 0x0
028E  086D     MOVF controlTransferState, W
028F  3A02     XORLW 0x2
0290  1D03     BTFSS STATUS, 0x2
0291  2A99     GOTO 0x299
1606:                      {
1607:                          pBDTEntryIn[0]->CNT = 0;
0292  0A6A     INCF pBDTEntryIn, W
0293  0086     MOVWF FSR1L
0294  0187     CLRF FSR1H
0295  0181     CLRF INDF1
1608:                          pBDTEntryIn[0]->STAT.Val = _USIE|_DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);        
0296  086A     MOVF pBDTEntryIn, W
0297  3185     MOVLP 0x5
0298  2D10     GOTO 0x510
1609:                      }
1610:                      else if(controlTransferState == CTRL_TRF_TX)
0299  0B6D     DECFSZ controlTransferState, W
029A  0008     RETURN
1611:                      {
1612:                  		BothEP0OutUOWNsSet = FALSE;	//Indicator flag used in USBCtrlTrfOutHandler()
029B  0022     MOVLB 0x2
029C  01AE     CLRF 0x2E
1613:                  
1614:                          //This buffer (when ping pong buffering is enabled on EP0 OUT) receives the
1615:                          //next SETUP packet.
1616:                  		#if((USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG))
1617:                  		pBDTEntryEP0OutCurrent->CNT = USB_EP0_BUFF_SIZE;
029D  0020     MOVLB 0x0
029E  0A6E     INCF pBDTEntryEP0OutCurrent, W
029F  3187     MOVLP 0x7
02A0  271C     CALL 0x71C
02A1  3180     MOVLP 0x0
1618:                  		pBDTEntryEP0OutCurrent->ADR = ConvertToPhysicalAddress(&SetupPkt);
02A2  00D6     MOVWF direction
02A3  01D7     CLRF product
02A4  086E     MOVF pBDTEntryEP0OutCurrent, W
02A5  23C5     CALL 0x3C5
02A6  3180     MOVLP 0x0
1619:                  		pBDTEntryEP0OutCurrent->STAT.Val = _USIE|_BSTALL; //Prepare endpoint to accept a SETUP transaction
02A7  086E     MOVF pBDTEntryEP0OutCurrent, W
02A8  0086     MOVWF FSR1L
02A9  3084     MOVLW 0x84
02AA  0081     MOVWF INDF1
1620:                  		BothEP0OutUOWNsSet = TRUE;	//Indicator flag used in USBCtrlTrfOutHandler()
02AB  0022     MOVLB 0x2
02AC  01AE     CLRF 0x2E
02AD  0AAE     INCF 0x2E, F
1621:                  		#endif
1622:                  
1623:                          //This EP0 OUT buffer receives the 0-byte OUT status stage packet.
1624:                  		pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
02AE  0020     MOVLB 0x0
02AF  0A6F     INCF pBDTEntryEP0OutNext, W
02B0  0086     MOVWF FSR1L
02B1  3008     MOVLW 0x8
02B2  0081     MOVWF INDF1
1625:                  		pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
02B3  3040     MOVLW 0x40
02B4  00D6     MOVWF direction
02B5  01D7     CLRF product
02B6  086F     MOVF pBDTEntryEP0OutNext, W
02B7  23C5     CALL 0x3C5
1626:                  		pBDTEntryEP0OutNext->STAT.Val = _USIE;           // Note: DTSEN is 0
02B8  086F     MOVF pBDTEntryEP0OutNext, W
02B9  0086     MOVWF FSR1L
02BA  3080     MOVLW 0x80
02BB  0081     MOVWF INDF1
02BC  0008     RETURN
1627:                      }
1628:                  }    
1629:              }
1630:          }   
02BD  302D     MOVLW 0x2D
1631:          
1632:          
1633:          /*******************************************************************************
1634:            Function: void USBCtrlEPAllowDataStage(void);
1635:              
1636:            Summary: This function allows the data stage of either a host-to-device or
1637:                      device-to-host control transfer (with data stage) to complete.
1638:                      This function is meant to be used in conjunction with either the
1639:                      USBDeferOUTDataStage() or USBDeferINDataStage().  If the firmware
1640:                      does not call either USBDeferOUTDataStage() or USBDeferINDataStage(),
1641:                      then the firmware does not need to manually call 
1642:                      USBCtrlEPAllowDataStage(), as the USB stack will call this function
1643:                      instead.
1644:               
1645:            Description:
1646:              
1647:            Conditions: A control transfer (with data stage) should already be pending, 
1648:                          if the firmware calls this function.  Additionally, the firmware
1649:                          should have called either USBDeferOUTDataStage() or 
1650:                          USBDeferINDataStage() at the start of the control transfer, if
1651:                          the firmware will be calling this function manually.
1652:          
1653:            Input:
1654:          
1655:            Return:
1656:          
1657:            Remarks: 
1658:            *****************************************************************************/
1659:          void USBCtrlEPAllowDataStage(void)
1660:          {
1661:              USBDeferINDataStagePackets = FALSE;
0474  01B2     CLRF 0x32
1662:              USBDeferOUTDataStagePackets = FALSE;
0475  01B3     CLRF 0x33
1663:          
1664:              if(controlTransferState == CTRL_TRF_RX) //(<setup><out><out>...<out><in>)
0476  0020     MOVLB 0x0
0477  086D     MOVF controlTransferState, W
0478  3A02     XORLW 0x2
0479  1D03     BTFSS STATUS, 0x2
047A  2C8C     GOTO 0x48C
1665:              {
1666:                  //Prepare EP0 OUT to receive the first OUT data packet in the data stage sequence.
1667:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
047B  0A6F     INCF pBDTEntryEP0OutNext, W
047C  0086     MOVWF FSR1L
047D  3008     MOVLW 0x8
047E  0187     CLRF FSR1H
047F  0081     MOVWF INDF1
1668:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
0480  3048     MOVLW 0x48
0481  00D9     MOVWF x
0482  01DA     CLRF i_718
0483  086F     MOVF pBDTEntryEP0OutNext, W
0484  3E02     ADDLW 0x2
0485  0086     MOVWF FSR1L
0486  0859     MOVF x, W
0487  3FC0     MOVWI [0]FSR1
0488  085A     MOVF i_718, W
0489  3FC1     MOVWI [1]FSR1
1669:                  pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
048A  086F     MOVF pBDTEntryEP0OutNext, W
048B  2D10     GOTO 0x510
1670:              }   
1671:              else    //else must be controlTransferState == CTRL_TRF_TX (<setup><in><in>...<in><out>)
1672:              {
1673:                  //Error check the data stage byte count.  Make sure the user specified
1674:                  //value was no greater than the number of bytes the host requested.
1675:          		if(SetupPkt.wLength < inPipes[0].wCount.Val)
048C  0022     MOVLB 0x2
048D  084C     MOVF 0x4C, W
048E  0020     MOVLB 0x0
048F  0247     SUBWF 0x47, W
0490  1D03     BTFSS STATUS, 0x2
0491  2C96     GOTO 0x496
0492  0022     MOVLB 0x2
0493  084B     MOVF 0x4B, W
0494  0020     MOVLB 0x0
0495  0246     SUBWF 0x46, W
0496  1803     BTFSC STATUS, 0x0
0497  2C9F     GOTO 0x49F
1676:          		{
1677:          			inPipes[0].wCount.Val = SetupPkt.wLength;
0498  0847     MOVF 0x47, W
0499  0022     MOVLB 0x2
049A  00CC     MOVWF 0x4C
049B  0020     MOVLB 0x0
049C  0846     MOVF 0x46, W
049D  0022     MOVLB 0x2
049E  00CB     MOVWF 0x4B
1678:          		}
1679:          		USBCtrlTrfTxService();  //Copies one IN data packet worth of data from application buffer
049F  24AE     CALL 0x4AE
04A0  3183     MOVLP 0x3
1680:          		                        //to CtrlTrfData buffer.  Also keeps track of how many bytes remaining.
1681:          
1682:          	    //Cnt should have been initialized by responsible request owner (ex: by
1683:          	    //using the USBEP0SendRAMPtr() or USBEP0SendROMPtr() API function).
1684:          		pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
04A1  3048     MOVLW 0x48
04A2  00D9     MOVWF x
04A3  01DA     CLRF i_718
04A4  086A     MOVF pBDTEntryIn, W
04A5  3E02     ADDLW 0x2
04A6  0086     MOVWF FSR1L
04A7  0187     CLRF FSR1H
04A8  0859     MOVF x, W
04A9  3FC0     MOVWI [0]FSR1
04AA  085A     MOVF i_718, W
04AB  3FC1     MOVWI [1]FSR1
1685:          		pBDTEntryIn[0]->STAT.Val = _USIE|_DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
04AC  086A     MOVF pBDTEntryIn, W
04AD  2D10     GOTO 0x510
1686:              }     
1687:          }    
04AE  3008     MOVLW 0x8
1688:          
1689:          
1690:          /******************************************************************************/
1691:          /** Internal Functions *********************************************************/
1692:          /******************************************************************************/
1693:          
1694:          /********************************************************************
1695:           * Function:        void USBConfigureEndpoint(BYTE EPNum, BYTE direction)
1696:           *
1697:           * PreCondition:    None
1698:           *
1699:           * Input:           BYTE EPNum - the endpoint to be configured
1700:           *                  BYTE direction - the direction to be configured
1701:           *                                   (either OUT_FROM_HOST or IN_TO_HOST)
1702:           *
1703:           * Output:          None
1704:           *
1705:           * Side Effects:    None
1706:           *
1707:           * Overview:        This function will configure the specified 
1708:           *                  endpoint
1709:           *
1710:           * Note:            None
1711:           *******************************************************************/
1712:          static void USBConfigureEndpoint(BYTE EPNum, BYTE direction)
1713:          {
1714:              volatile BDT_ENTRY* handle;
1715:          
1716:              //Compute a pointer to the even BDT entry corresponding to the
1717:              //EPNum and direction values passed to this function.
1718:              handle = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN]; //Get address of start of BDT
0367  00D8     MOVWF p
0368  3020     MOVLW 0x20
0369  00D9     MOVWF x
1719:              handle += EP(EPNum,direction,0u);     //Add in offset to the BDT of interest
036A  0856     MOVF direction, W
036B  00D7     MOVWF product
036C  35D7     LSLF product, F
036D  0858     MOVF p, W
036E  0709     ADDWF WREG, W
036F  0709     ADDWF WREG, W
0370  0757     ADDWF product, W
0371  0709     ADDWF WREG, W
0372  0709     ADDWF WREG, W
0373  07D9     ADDWF x, F
1720:              
1721:              handle->STAT.UOWN = 0;  //mostly redundant, since USBStdSetCfgHandler() 
0374  0859     MOVF x, W
0375  0086     MOVWF FSR1L
0376  0187     CLRF FSR1H
0377  1381     BCF INDF1, 0x7
1722:              //already cleared the entire BDT table
1723:          
1724:              //Make sure our pBDTEntryIn/Out[] pointer is initialized.  Needed later
1725:              //for USBTransferOnePacket() API calls.
1726:              if(direction == OUT_FROM_HOST)
0378  08D6     MOVF direction, F
0379  1D03     BTFSS STATUS, 0x2
037A  2B7F     GOTO 0x37F
1727:              {
1728:                  pBDTEntryOut[EPNum] = handle;
037B  0858     MOVF p, W
037C  23D3     CALL 0x3D3
037D  3180     MOVLP 0x0
037E  2B83     GOTO 0x383
1729:              }
1730:              else
1731:              {
1732:                  pBDTEntryIn[EPNum] = handle;
037F  0858     MOVF p, W
0380  3E6A     ADDLW 0x6A
0381  0086     MOVWF FSR1L
0382  0187     CLRF FSR1H
0383  0859     MOVF x, W
0384  0081     MOVWF INDF1
1733:              }
1734:          
1735:              #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
1736:                  handle->STAT.DTS = 0;
0385  0859     MOVF x, W
0386  0086     MOVWF FSR1L
0387  0187     CLRF FSR1H
0388  1301     BCF INDF1, 0x6
1737:                  (handle+1)->STAT.DTS = 1;
0389  0859     MOVF x, W
038A  3E04     ADDLW 0x4
038B  0086     MOVWF FSR1L
038C  1701     BSF INDF1, 0x6
1738:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
1739:                  //Set DTS to one because the first thing we will do
1740:                  //when transmitting is toggle the bit
1741:                  handle->STAT.DTS = 1;
1742:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
1743:                  if(EPNum != 0)
1744:                  {
1745:                      handle->STAT.DTS = 1;
1746:                  }
1747:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)    
1748:                  if(EPNum != 0)
1749:                  {
1750:                      handle->STAT.DTS = 0;
1751:                      (handle+1)->STAT.DTS = 1;
1752:                  }
1753:              #endif
1754:          }
038D  0008     RETURN
1755:          
1756:          
1757:          /******************************************************************************
1758:           * Function:        void USBCtrlEPServiceComplete(void)
1759:           *
1760:           * PreCondition:    None
1761:           *
1762:           * Input:           None
1763:           *
1764:           * Output:          None
1765:           *
1766:           * Side Effects:    None
1767:           *
1768:           * Overview:        This routine wrap up the remaining tasks in servicing
1769:           *                  a Setup Request. Its main task is to set the endpoint
1770:           *                  controls appropriately for a given situation. See code
1771:           *                  below.
1772:           *                  There are three main scenarios:
1773:           *                  a) There was no handler for the Request, in this case
1774:           *                     a STALL should be sent out.
1775:           *                  b) The host has requested a read control transfer,
1776:           *                     endpoints are required to be setup in a specific way.
1777:           *                  c) The host has requested a write control transfer, or
1778:           *                     a control data stage is not required, endpoints are
1779:           *                     required to be setup in a specific way.
1780:           *
1781:           *                  Packet processing is resumed by clearing PKTDIS bit.
1782:           *
1783:           * Note:            None
1784:           *****************************************************************************/
1785:          static void USBCtrlEPServiceComplete(void)
1786:          {
1787:              /*
1788:               * PKTDIS bit is set when a Setup Transaction is received.
1789:               * Clear to resume packet processing.
1790:               */
1791:              USBPacketDisable = 0;
043D  003D     MOVLB 0x1D
043E  120E     BCF PORTC, 0x4
1792:          
1793:          	//Check the busy bits and the SetupPtk.DataDir variables to determine what type of
1794:          	//control transfer is currently in progress.  We need to know the type of control
1795:          	//transfer that is currently pending, in order to know how to properly arm the 
1796:          	//EP0 IN and EP0 OUT endpoints.
1797:              if(inPipes[0].info.bits.busy == 0)
043F  0022     MOVLB 0x2
0440  1BCA     BTFSC 0x4A, 0x7
0441  2C59     GOTO 0x459
1798:              {
1799:                  if(outPipes[0].info.bits.busy == 1)
0442  1FA2     BTFSS 0x22, 0x7
0443  2C50     GOTO 0x450
1800:                  {
1801:                      controlTransferState = CTRL_TRF_RX;
0444  3002     MOVLW 0x2
0445  0020     MOVLB 0x0
0446  00ED     MOVWF controlTransferState
1802:                      /*
1803:                       * Control Write:
1804:                       * <SETUP[0]><OUT[1]><OUT[0]>...<IN[1]> | <SETUP[0]>
1805:                       */
1806:          
1807:                      //1. Prepare OUT EP to receive data, unless a USB class request handler
1808:                      //   function decided to defer the data stage (ex: because the intended
1809:                      //   RAM buffer wasn't available yet) by calling USBDeferDataStage().
1810:                      //   If it did so, it is then responsible for calling USBCtrlEPAllowDataStage(),
1811:                      //   once it is ready to begin receiving the data.
1812:                      if(USBDeferOUTDataStagePackets == FALSE)
0447  0022     MOVLB 0x2
0448  08B3     MOVF 0x33, F
0449  1D03     BTFSS STATUS, 0x2
044A  2C4C     GOTO 0x44C
1813:                      {
1814:                          USBCtrlEPAllowDataStage();
044B  2474     CALL 0x474
1815:                      }
1816:                      
1817:                      //2.  IN endpoint 0 status stage will be armed by USBCtrlEPAllowStatusStage() 
1818:                      //after all of the OUT data has been received and consumed, or if a timeout occurs.
1819:                      USBStatusStageEnabledFlag2 = FALSE;
044C  0022     MOVLB 0x2
044D  01B7     CLRF 0x37
1820:                      USBStatusStageEnabledFlag1 = FALSE;
044E  01B6     CLRF 0x36
1821:                  }
044F  0008     RETURN
1822:                  else
1823:                  {
1824:                      /*
1825:                       * If no one knows how to service this request then stall.
1826:                       * Must also prepare EP0 to receive the next SETUP transaction.
1827:                       */
1828:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0450  0020     MOVLB 0x0
0451  24ED     CALL 0x4ED
1829:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
1830:                      pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
0452  308C     MOVLW 0x8C
0453  0081     MOVWF INDF1
1831:                      pBDTEntryIn[0]->STAT.Val = _USIE|_BSTALL; 
0454  086A     MOVF pBDTEntryIn, W
0455  0086     MOVWF FSR1L
0456  3084     MOVLW 0x84
0457  0081     MOVWF INDF1
0458  0008     RETURN
1832:                  }
1833:              }
1834:              else    // A module has claimed ownership of the control transfer session.
1835:              {
1836:          		if(SetupPkt.DataDir == USB_SETUP_DEVICE_TO_HOST_BITFIELD)
0459  0020     MOVLB 0x0
045A  1FC0     BTFSS SetupPkt, 0x7
045B  2C6D     GOTO 0x46D
1837:          		{
1838:          			controlTransferState = CTRL_TRF_TX;
045C  01ED     CLRF controlTransferState
045D  0AED     INCF controlTransferState, F
1839:          			/*
1840:          			 * Control Read:
1841:          			 * <SETUP[0]><IN[1]><IN[0]>...<OUT[1]> | <SETUP[0]>
1842:          			 *
1843:          			 * 1. Prepare IN EP to transfer data to the host.  If however the data
1844:          			 *    wasn't ready yet (ex: because the firmware needs to go and read it from
1845:          			 *    some slow/currently unavailable resource, such as an external I2C EEPROM),
1846:          			 *    Then the class request handler reponsible should call the USBDeferDataStage()
1847:          			 *    macro.  In this case, the firmware may wait up to 500ms, before it is required
1848:          			 *    to transmit the first IN data packet.  Once the data is ready, and the firmware
1849:          			 *    is ready to begin sending the data, it should then call the 
1850:          			 *    USBCtrlEPAllowDataStage() function to start the data stage.
1851:          			 */
1852:          			if(USBDeferINDataStagePackets == FALSE)
045E  0022     MOVLB 0x2
045F  08B2     MOVF 0x32, F
0460  1D03     BTFSS STATUS, 0x2
0461  2C64     GOTO 0x464
1853:                      {
1854:                          USBCtrlEPAllowDataStage();
0462  2474     CALL 0x474
0463  3183     MOVLP 0x3
1855:          			}
1856:          
1857:                      // 2. (Optionally) allow the status stage now, to prepare for early termination.
1858:                      //    Note: If a class request handler decided to set USBDeferStatusStagePacket == TRUE,
1859:                      //    then it is responsible for eventually calling USBCtrlEPAllowStatusStage() once it
1860:                      //    is ready.  If the class request handler does this, it needs to be careful to
1861:                      //    be written so that it can handle the early termination scenario.
1862:                      //    Ex: It should call USBCtrlEPAllowStatusStage() when any of the following occurs:
1863:                      //    1.  The desired total number of bytes were sent to the host.
1864:                      //    2.  The number of bytes that the host originally requested (in the SETUP packet that 
1865:                      //        started the control transfer) has been reached.
1866:                      //    3.  Or, if a timeout occurs (ex: <50ms since the last successful EP0 IN transaction), regardless 
1867:                      //        of how many bytes have actually been sent.  This is necessary to prevent a deadlock situation
1868:                      //        (where the control transfer can't complete, due to continuous NAK on status stage) if the
1869:                      //        host performs early termination.  If enabled, the USB_ENABLE_STATUS_STAGE_TIMEOUTS usb_config.h
1870:                      //        option can take care of this for you.
1871:                      //    Note: For this type of control transfer, there is normally no harm in simply arming the
1872:                      //    status stage packet right now, even if the IN data is not ready yet.  This allows for
1873:                      //    immediate early termination, without adding unecessary delay.  Therefore, it is generally not
1874:                      //    recommended for the USB class handler firmware to call USBDeferStatusStage(), for this 
1875:                      //    type of control transfer.  If the USB class handler firmware needs more time to fetch the IN
1876:                      //    data that needs to be sent to the host, it should instead use the USBDeferDataStage() function.
1877:                      USBStatusStageEnabledFlag2 = FALSE;
0464  0022     MOVLB 0x2
0465  01B7     CLRF 0x37
1878:                      USBStatusStageEnabledFlag1 = FALSE;
0466  01B6     CLRF 0x36
1879:                      if(USBDeferStatusStagePacket == FALSE)
0467  0020     MOVLB 0x0
0468  08EC     MOVF USBDeferStatusStagePacket, F
0469  1D03     BTFSS STATUS, 0x2
046A  0008     RETURN
1880:                      {
1881:                          USBCtrlEPAllowStatusStage();
046B  3182     MOVLP 0x2
046C  2A83     GOTO 0x283
1882:                      } 
1883:          		}
1884:          		else   // (SetupPkt.DataDir == USB_SETUP_DIRECTION_HOST_TO_DEVICE)
1885:          		{
1886:          			//This situation occurs for special types of control transfers,
1887:          			//such as that which occurs when the host sends a SET_ADDRESS
1888:          			//control transfer.  Ex:
1889:          			//
1890:          			//<SETUP[0]><IN[1]> | <SETUP[0]>
1891:          				
1892:          			//Although the data direction is HOST_TO_DEVICE, there is no data stage
1893:          			//(hence: outPipes[0].info.bits.busy == 0).  There is however still
1894:          			//an IN status stage.
1895:          
1896:          			controlTransferState = CTRL_TRF_RX;     //Since this is a HOST_TO_DEVICE control transfer
046D  3002     MOVLW 0x2
046E  00ED     MOVWF controlTransferState
046F  24ED     CALL 0x4ED
0470  3183     MOVLP 0x3
1897:          			
1898:          			//1. Prepare OUT EP to receive the next SETUP packet.
1899:          			pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
1900:          			pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
1901:          			pBDTEntryEP0OutNext->STAT.Val = _USIE|_BSTALL;
0471  3084     MOVLW 0x84
0472  0081     MOVWF INDF1
0473  2C64     GOTO 0x464
1902:          				
1903:          			//2. Prepare for IN status stage of the control transfer
1904:                      USBStatusStageEnabledFlag2 = FALSE;
1905:                      USBStatusStageEnabledFlag1 = FALSE;
1906:          			if(USBDeferStatusStagePacket == FALSE)
1907:                      {
1908:                          USBCtrlEPAllowStatusStage();
1909:                      } 
1910:          		}
1911:          
1912:              }//end if(ctrl_trf_session_owner == MUID_NULL)
1913:          
1914:          }//end USBCtrlEPServiceComplete
0474  01B2     CLRF 0x32
1915:          
1916:          
1917:          /******************************************************************************
1918:           * Function:        void USBCtrlTrfTxService(void)
1919:           *
1920:           * PreCondition:    pSrc, wCount, and usb_stat.ctrl_trf_mem are setup properly.
1921:           *
1922:           * Input:           None
1923:           *
1924:           * Output:          None
1925:           *
1926:           * Side Effects:    None
1927:           *
1928:           * Overview:        This routine is used for device to host control transfers 
1929:           *					(IN transactions).  This function takes care of managing a
1930:           *                  transfer over multiple USB transactions.
1931:           *					This routine should be called from only two places.
1932:           *                  One from USBCtrlEPServiceComplete() and one from
1933:           *                  USBCtrlTrfInHandler().
1934:           *
1935:           * Note:            
1936:           *****************************************************************************/
1937:          static void USBCtrlTrfTxService(void)
1938:          {
1939:              BYTE byteToSend;
1940:          
1941:              //Figure out how many bytes of data to send in the next IN transaction.
1942:              //Assume a full size packet, unless otherwise determined below.
1943:              byteToSend = USB_EP0_BUFF_SIZE;         
04AE  3008     MOVLW 0x8
04AF  0020     MOVLB 0x0
04B0  00D8     MOVWF p
1944:              if(inPipes[0].wCount.Val < (BYTE)USB_EP0_BUFF_SIZE)
04B1  3000     MOVLW 0x0
04B2  0022     MOVLB 0x2
04B3  024C     SUBWF 0x4C, W
04B4  3008     MOVLW 0x8
04B5  1903     BTFSC STATUS, 0x2
04B6  024B     SUBWF 0x4B, W
04B7  1803     BTFSC STATUS, 0x0
04B8  2CC7     GOTO 0x4C7
1945:              {
1946:                  byteToSend = inPipes[0].wCount.Val;
04B9  084B     MOVF 0x4B, W
04BA  0020     MOVLB 0x0
04BB  00D8     MOVWF p
1947:          
1948:                  //Keep track of whether or not we have sent a "short packet" yet.
1949:                  //This is useful so that later on, we can configure EP0 IN to STALL,
1950:                  //after we have sent all of the intended data.  This makes sure the
1951:                  //hardware STALLs if the host erroneously tries to send more IN token 
1952:                  //packets, requesting more data than intended in the control transfer.
1953:                  if(shortPacketStatus == SHORT_PKT_NOT_USED)
04BC  0021     MOVLB 0x1
04BD  08EC     MOVF USBDeferStatusStagePacket, F
04BE  1D03     BTFSS STATUS, 0x2
04BF  2CC3     GOTO 0x4C3
1954:                  {
1955:                      shortPacketStatus = SHORT_PKT_PENDING;
04C0  01EC     CLRF USBDeferStatusStagePacket
04C1  0AEC     INCF USBDeferStatusStagePacket, F
1956:                  }
04C2  2CC7     GOTO 0x4C7
1957:                  else if(shortPacketStatus == SHORT_PKT_PENDING)
04C3  0B6C     DECFSZ USBDeferStatusStagePacket, W
04C4  2CC7     GOTO 0x4C7
1958:                  {
1959:                      shortPacketStatus = SHORT_PKT_SENT;
04C5  3002     MOVLW 0x2
04C6  00EC     MOVWF USBDeferStatusStagePacket
1960:                  }
1961:              }
1962:          
1963:              //Keep track of how many bytes remain to be sent in the transfer, by
1964:              //subtracting the number of bytes about to be sent from the total.
1965:              inPipes[0].wCount.Val = inPipes[0].wCount.Val - byteToSend;
04C7  0020     MOVLB 0x0
04C8  0858     MOVF p, W
04C9  00D6     MOVWF direction
04CA  01D7     CLRF product
04CB  0022     MOVLB 0x2
04CC  024B     SUBWF 0x4B, W
04CD  00CB     MOVWF 0x4B
04CE  0020     MOVLB 0x0
04CF  0857     MOVF product, W
04D0  0022     MOVLB 0x2
04D1  3B4C     SUBWFB 0x4C, W
04D2  00CC     MOVWF 0x4C
1966:              
1967:              //Next, load the number of bytes to send to BC7..0 in buffer descriptor.
1968:              //Note: Control endpoints may never have a max packet size of > 64 bytes.
1969:              //Therefore, the BC8 and BC9 bits should always be maintained clear.
1970:              pBDTEntryIn[0]->CNT = byteToSend;
04D3  0020     MOVLB 0x0
04D4  0A6A     INCF pBDTEntryIn, W
04D5  0086     MOVWF FSR1L
04D6  0187     CLRF FSR1H
04D7  0858     MOVF p, W
04D8  0081     MOVWF INDF1
1971:          
1972:              //Now copy the data from the source location, to the CtrlTrfData[] buffer,
1973:              //which we will send to the host.
1974:              pDst = (USB_VOLATILE BYTE*)CtrlTrfData;                // Set destination pointer
04D9  3048     MOVLW 0x48
04DA  0022     MOVLB 0x2
04DB  00BE     MOVWF 0x3E
1975:              if(inPipes[0].info.bits.ctrl_trf_mem == USB_EP0_ROM)   // Determine type of memory source
04DC  1C4A     BTFSS 0x4A, 0x0
04DD  2CE1     GOTO 0x4E1
04DE  2CE8     GOTO 0x4E8
1976:              {
1977:                  while(byteToSend)
04E1  0020     MOVLB 0x0
04E2  08D8     MOVF p, F
04E3  1903     BTFSC STATUS, 0x2
04E4  0008     RETURN
04E5  2CDF     GOTO 0x4DF
04E6  24FF     CALL 0x4FF
04E7  3183     MOVLP 0x3
1978:                  {
1979:                      *pDst++ = *inPipes[0].pSrc.bRom++;
04DF  24FF     CALL 0x4FF
04E0  3183     MOVLP 0x3
1980:                      byteToSend--;
1981:                  }//end while(byte_to_send.Val)
1982:              }
1983:              else  // RAM
1984:              {
1985:                  while(byteToSend)
04E8  0020     MOVLB 0x0
04E9  08D8     MOVF p, F
04EA  1903     BTFSC STATUS, 0x2
04EB  0008     RETURN
04EC  2CE6     GOTO 0x4E6
1986:                  {
1987:                      *pDst++ = *inPipes[0].pSrc.bRam++;
1988:                      byteToSend--;
1989:                  }//end while(byte_to_send.Val)
1990:              }//end if(usb_stat.ctrl_trf_mem == _ROM)
1991:          }//end USBCtrlTrfTxService
04ED  0A6F     INCF pBDTEntryEP0OutNext, W
1992:          
1993:          /******************************************************************************
1994:           * Function:        void USBCtrlTrfRxService(void)
1995:           *
1996:           * PreCondition:    pDst and wCount are setup properly.
1997:           *                  pSrc is always &CtrlTrfData
1998:           *                  usb_stat.ctrl_trf_mem is always USB_EP0_RAM.
1999:           *                  wCount should be set to 0 at the start of each control
2000:           *                  transfer.
2001:           *
2002:           * Input:           None
2003:           *
2004:           * Output:          None
2005:           *
2006:           * Side Effects:    None
2007:           *
2008:           * Overview:        This routine is used for host to device control transfers
2009:           *					(uses OUT transactions).  This function receives the data that arrives
2010:           *					on EP0 OUT, and copies it into the appropriate outPipes[0].pDst.bRam
2011:           *					buffer.  Once the host has sent all the data it was intending
2012:           *					to send, this function will call the appropriate outPipes[0].pFunc()
2013:           *					handler (unless it is NULL), so that it can be used by the
2014:           *					intended target firmware.
2015:           *
2016:           * Note:            None
2017:           *****************************************************************************/
2018:          static void USBCtrlTrfRxService(void)
2019:          {
2020:              BYTE byteToRead;
2021:              BYTE i;
2022:          
2023:              //Load byteToRead with the number of bytes the host just sent us in the 
2024:              //last OUT transaction.
2025:              byteToRead = pBDTEntryEP0OutCurrent->CNT;   
06AF  086E     MOVF pBDTEntryEP0OutCurrent, W
06B0  0086     MOVWF FSR1L
06B1  0187     CLRF FSR1H
06B2  3F41     MOVIW [1]FSR1
06B3  00DB     MOVWF i
2026:          
2027:              //Update the "outPipes[0].wCount.Val", which keeps track of the total number
2028:              //of remaining bytes expected to be received from the host, in the control
2029:              //transfer.  First check to see if the host sent us more bytes than the
2030:              //application firmware was expecting to receive.
2031:              if(byteToRead > outPipes[0].wCount.Val)
06B4  00D8     MOVWF p
06B5  01D9     CLRF x
06B6  0859     MOVF x, W
06B7  0022     MOVLB 0x2
06B8  0224     SUBWF 0x24, W
06B9  1D03     BTFSS STATUS, 0x2
06BA  2EBF     GOTO 0x6BF
06BB  0020     MOVLB 0x0
06BC  0858     MOVF p, W
06BD  0022     MOVLB 0x2
06BE  0223     SUBWF 0x23, W
06BF  1803     BTFSC STATUS, 0x0
06C0  2EC4     GOTO 0x6C4
2032:              {
2033:                  byteToRead = outPipes[0].wCount.Val;
06C1  0823     MOVF 0x23, W
06C2  0020     MOVLB 0x0
06C3  00DB     MOVWF i
2034:              }	
2035:              //Reduce the number of remaining bytes by the number we just received.
2036:          	outPipes[0].wCount.Val = outPipes[0].wCount.Val - byteToRead;   
06C4  0020     MOVLB 0x0
06C5  085B     MOVF i, W
06C6  00D8     MOVWF p
06C7  01D9     CLRF x
06C8  0022     MOVLB 0x2
06C9  0223     SUBWF 0x23, W
06CA  00A3     MOVWF 0x23
06CB  0020     MOVLB 0x0
06CC  0859     MOVF x, W
06CD  0022     MOVLB 0x2
06CE  3B24     SUBWFB 0x24, W
06CF  00A4     MOVWF 0x24
2037:          
2038:              //Copy the OUT DATAx packet bytes that we just received from the host,
2039:              //into the user application buffer space.
2040:              for(i=0;i<byteToRead;i++)
06D0  0020     MOVLB 0x0
06D1  01DA     CLRF i_718
06D2  085B     MOVF i, W
06D3  025A     SUBWF i_718, W
06D4  1803     BTFSC STATUS, 0x0
06D5  2EE6     GOTO 0x6E6
06E3  0020     MOVLB 0x0
06E4  0ADA     INCF i_718, F
06E5  2ED2     GOTO 0x6D2
2041:              {
2042:                  *outPipes[0].pDst.bRam++ = CtrlTrfData[i];
06D6  0022     MOVLB 0x2
06D7  0820     MOVF BDT, W
06D8  0086     MOVWF FSR1L
06D9  0187     CLRF FSR1H
06DA  0020     MOVLB 0x0
06DB  085A     MOVF i_718, W
06DC  3E48     ADDLW 0x48
06DD  0084     MOVWF FSR0L
06DE  0185     CLRF FSR0H
06DF  0800     MOVF INDF0, W
06E0  0081     MOVWF INDF1
06E1  0022     MOVLB 0x2
06E2  0AA0     INCF BDT, F
2043:              }//end while(byteToRead.Val)
2044:          
2045:              //If there is more data to receive, prepare EP0 OUT so that it can receive 
2046:          	//the next packet in the sequence.
2047:              if(outPipes[0].wCount.Val > 0)
06E6  3003     MOVLW 0x3
06E7  3E20     ADDLW 0x20
06E8  0086     MOVWF FSR1L
06E9  3001     MOVLW 0x1
06EA  0087     MOVWF FSR1H
06EB  0016     MOVIW FSR1++
06EC  0401     IORWF INDF1, W
06ED  1903     BTFSC STATUS, 0x2
06EE  2F05     GOTO 0x705
2048:              {
2049:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
06EF  0A6F     INCF pBDTEntryEP0OutNext, W
06F0  0086     MOVWF FSR1L
06F1  3008     MOVLW 0x8
06F2  0187     CLRF FSR1H
06F3  0081     MOVWF INDF1
2050:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
06F4  3048     MOVLW 0x48
06F5  2721     CALL 0x721
06F6  3186     MOVLP 0x6
2051:                  if(pBDTEntryEP0OutCurrent->STAT.DTS == 0)
06F7  086E     MOVF pBDTEntryEP0OutCurrent, W
06F8  0086     MOVWF FSR1L
06FA  1B01     BTFSC INDF1, 0x6
06FB  2F00     GOTO 0x700
2052:                  {
2053:                      pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
06F9  086F     MOVF pBDTEntryEP0OutNext, W
06FC  0086     MOVWF FSR1L
06FD  30C8     MOVLW 0xC8
06FE  0081     MOVWF INDF1
2054:                  }
06FF  0008     RETURN
2055:                  else
2056:                  {
2057:                      pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT0|(_DTSEN & _DTS_CHECKING_ENABLED);
0700  0086     MOVWF FSR1L
0701  3088     MOVLW 0x88
0702  0187     CLRF FSR1H
0703  0081     MOVWF INDF1
0704  0008     RETURN
2058:                  }
2059:              }
2060:              else
2061:              {
2062:          	    //We have received all OUT packets that we were expecting to
2063:          	    //receive for the control transfer.  Prepare EP0 OUT to receive
2064:          		//the next SETUP transaction that may arrive.
2065:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0705  0A6F     INCF pBDTEntryEP0OutNext, W
0706  271C     CALL 0x71C
0707  3186     MOVLP 0x6
0708  2721     CALL 0x721
0709  3186     MOVLP 0x6
2066:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
2067:                  //Configure EP0 OUT to receive the next SETUP transaction for any future
2068:                  //control transfers.  However, set BSTALL in case the host tries to send
2069:                  //more data than it claims it was going to send.
2070:                  pBDTEntryEP0OutNext->STAT.Val = _USIE|_BSTALL;
070A  086F     MOVF pBDTEntryEP0OutNext, W
070B  0086     MOVWF FSR1L
070C  3084     MOVLW 0x84
070D  0081     MOVWF INDF1
2071:          
2072:          		//All data bytes for the host to device control write (OUT) have now been
2073:          		//received successfully.
2074:          		//Go ahead and call the user specified callback function, to use/consume
2075:          		//the control transfer data (ex: if the "void (*function)" parameter 
2076:          		//was non-NULL when USBEP0Receive() was called).
2077:                  if(outPipes[0].pFunc != NULL)
070E  0022     MOVLB 0x2
070F  0825     MOVF 0x25, W
0710  1903     BTFSC STATUS, 0x2
0711  2F15     GOTO 0x715
2078:                  {
2079:                      #if defined(__XC8)
2080:                          //Special pragmas to suppress an expected/harmless warning
2081:                          //message when building with the XC8 compiler
2082:                          #pragma warning push
2083:                          #pragma warning disable 1088
2084:                          outPipes[0].pFunc();    //Call the user's callback function
0712  0825     MOVF 0x25, W
0713  3187     MOVLP 0x7
0714  2F14     GOTO 0x714
2085:                          #pragma warning pop
2086:                      #else
2087:                          outPipes[0].pFunc();    //Call the user's callback function
2088:                      #endif
2089:                  }
2090:                  outPipes[0].info.bits.busy = 0;    
0715  13A2     BCF 0x22, 0x7
2091:          
2092:                  //Ready to arm status stage IN transaction now, if the application
2093:                  //firmware has completed processing the request.  If it is still busy
2094:                  //and needs more time to finish handling the request, then the user
2095:                  //callback (the one called by the outPipes[0].pFunc();) should set the
2096:                  //USBDeferStatusStagePacket to TRUE (by calling USBDeferStatusStage()).  In 
2097:                  //this case, it is the application's firmware responsibility to call 
2098:                  //the USBCtrlEPAllowStatusStage() function, once it is fully done handling the request.
2099:                  //Note: The application firmware must process the request and call
2100:                  //USBCtrlEPAllowStatusStage() in a semi-timely fashion.  "Semi-timely"
2101:                  //means either 50ms, 500ms, or 5 seconds, depending on the type of
2102:                  //control transfer.  See the USB 2.0 specification section 9.2.6 for
2103:                  //more details.
2104:                  if(USBDeferStatusStagePacket == FALSE)
0716  0020     MOVLB 0x0
0717  08EC     MOVF USBDeferStatusStagePacket, F
0718  1D03     BTFSS STATUS, 0x2
0719  0008     RETURN
2105:                  {
2106:                      USBCtrlEPAllowStatusStage();
071A  3182     MOVLP 0x2
071B  2A83     GOTO 0x283
2107:                  }            
2108:              }    
2109:          
2110:          }//end USBCtrlTrfRxService
071C  0086     MOVWF FSR1L
2111:          
2112:          
2113:          /********************************************************************
2114:           * Function:        void USBStdSetCfgHandler(void)
2115:           *
2116:           * PreCondition:    None
2117:           *
2118:           * Input:           None
2119:           *
2120:           * Output:          None
2121:           *
2122:           * Side Effects:    None
2123:           *
2124:           * Overview:        This routine first disables all endpoints by
2125:           *                  clearing UEP registers. It then configures
2126:           *                  (initializes) endpoints by calling the callback
2127:           *                  function USBCBInitEP().
2128:           *
2129:           * Note:            None
2130:           *******************************************************************/
2131:          static void USBStdSetCfgHandler(void)
2132:          {
2133:              BYTE i;
2134:          
2135:              // This will generate a zero length packet
2136:              inPipes[0].info.bits.busy = 1;            
072B  0022     MOVLB 0x2
072D  17CA     BSF 0x4A, 0x7
2137:          
2138:              //Clear all of the endpoint control registers
2139:              DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
072C  300E     MOVLW 0xE
072E  0020     MOVLB 0x0
072F  00E6     MOVWF work
0730  3099     MOVLW 0x99
0731  00E5     MOVWF p
0732  01E7     CLRF n
0733  0865     MOVF p, W
0734  0086     MOVWF FSR1L
0735  0866     MOVF work, W
0736  0087     MOVWF FSR1H
0737  0181     CLRF INDF1
0738  0AE5     INCF p, F
0739  1903     BTFSC STATUS, 0x2
073A  0AE6     INCF work, F
073B  0AE7     INCF n, F
073C  1903     BTFSC STATUS, 0x2
073D  2F33     GOTO 0x733
2140:          
2141:              //Clear all of the BDT entries
2142:              memset((void*)&BDT[0], 0x00, sizeof(BDT));
073E  3020     MOVLW 0x20
073F  01D6     CLRF direction
0740  01D7     CLRF product
0741  00D8     MOVWF p
0742  01D9     CLRF x
0743  2780     CALL 0x780
0744  3187     MOVLP 0x7
2143:          
2144:              // Assert reset request to all of the Ping Pong buffer pointers
2145:              USBPingPongBufferReset = 1;                                   
0745  003D     MOVLB 0x1D
0746  170E     BSF PORTC, 0x6
2146:          
2147:          	//Re-Initialize all ping pong software state bits to 0 (which corresponds to
2148:          	//the EVEN buffer being the next one that will be used), since we are also 
2149:          	//doing a hardware ping pong pointer reset above.
2150:          	for(i = 0; i < (BYTE)(USB_MAX_EP_NUMBER+1u); i++)
0747  0020     MOVLB 0x0
0748  01E8     CLRF i
0752  3002     MOVLW 0x2
0754  0AE8     INCF i, F
0755  0268     SUBWF i, W
0756  1C03     BTFSS STATUS, 0x0
0757  2F49     GOTO 0x749
2151:          	{
2152:          		ep_data_in[i].Val = 0u;
0749  0868     MOVF i, W
074A  3E26     ADDLW 0x26
074B  0086     MOVWF FSR1L
074C  3001     MOVLW 0x1
074D  0087     MOVWF FSR1H
074E  0181     CLRF INDF1
2153:                  ep_data_out[i].Val = 0u;
074F  0868     MOVF i, W
0750  3E28     ADDLW 0x28
0751  0086     MOVWF FSR1L
0753  0181     CLRF INDF1
2154:          	}
2155:          
2156:              //clear the alternate interface settings
2157:              memset((void*)&USBAlternateInterface,0x00,USB_MAX_NUM_INT);
0758  30EE     MOVLW 0xEE
0759  01D6     CLRF direction
075A  01D7     CLRF product
075B  01D8     CLRF p
075C  0AD8     INCF p, F
075D  01D9     CLRF x
075E  2780     CALL 0x780
075F  3187     MOVLP 0x7
2158:          
2159:              //Stop trying to reset ping pong buffer pointers
2160:              USBPingPongBufferReset = 0;
0760  003D     MOVLB 0x1D
0761  130E     BCF PORTC, 0x6
2161:          
2162:              pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
0762  3028     MOVLW 0x28
0763  0020     MOVLB 0x0
0764  00EA     MOVWF pBDTEntryIn
2163:          
2164:          	//Set the next out to the current out packet
2165:              pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN];
0765  3020     MOVLW 0x20
0766  00EE     MOVWF pBDTEntryEP0OutCurrent
2166:              pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
0767  00EF     MOVWF pBDTEntryEP0OutNext
2167:          
2168:              //set the current configuration
2169:              USBActiveConfiguration = SetupPkt.bConfigurationValue;
0768  0842     MOVF 0x42, W
0769  0021     MOVLB 0x1
076A  00ED     MOVWF controlTransferState
2170:          
2171:              //if the configuration value == 0
2172:              if(USBActiveConfiguration == 0)
076B  08ED     MOVF controlTransferState, F
076C  1D03     BTFSS STATUS, 0x2
076D  2F71     GOTO 0x771
2173:              {
2174:                  //Go back to the addressed state
2175:                  USBDeviceState = ADDRESS_STATE;
076E  3010     MOVLW 0x10
076F  00EA     MOVWF pBDTEntryIn
2176:              }
0770  0008     RETURN
2177:              else
2178:              {
2179:                  //initialize the required endpoints
2180:                  USB_SET_CONFIGURATION_HANDLER(EVENT_CONFIGURED,(void*)&USBActiveConfiguration,1);
0771  0020     MOVLB 0x0
0772  30ED     MOVLW 0xED
0773  01E0     CLRF count
0774  0AE0     INCF count, F
0775  01E1     CLRF 0x61
0776  00E2     MOVWF 0x62
0777  01E3     CLRF 0x63
0778  0AE3     INCF 0x63, F
0779  01E4     CLRF 0x64
077A  3181     MOVLP 0x1
077B  21E4     CALL 0x1E4
2181:          
2182:                  //Otherwise go to the configured state.  Update the state variable last,
2183:                  //after performing all of the set configuration related initialization
2184:                  //tasks.
2185:                  USBDeviceState = CONFIGURED_STATE;		
077C  3020     MOVLW 0x20
077D  0021     MOVLB 0x1
077E  00EA     MOVWF pBDTEntryIn
2186:              }//end if(SetupPkt.bConfigurationValue == 0)
2187:          }//end USBStdSetCfgHandler
077F  0008     RETURN
2188:          
2189:          
2190:          /********************************************************************
2191:           * Function:        void USBStdGetDscHandler(void)
2192:           *
2193:           * PreCondition:    None
2194:           *
2195:           * Input:           None
2196:           *
2197:           * Output:          None
2198:           *
2199:           * Side Effects:    None
2200:           *
2201:           * Overview:        This routine handles the standard GET_DESCRIPTOR
2202:           *                  request.
2203:           *
2204:           * Note:            None
2205:           *******************************************************************/
2206:          static void USBStdGetDscHandler(void)
2207:          {
2208:              if(SetupPkt.bmRequestType == 0x80)
0792  0020     MOVLB 0x0
0793  0840     MOVF SetupPkt, W
0794  3A80     XORLW 0x80
0795  1D03     BTFSS STATUS, 0x2
0796  0008     RETURN
2209:              {
2210:                  inPipes[0].info.Val = USB_EP0_ROM | USB_EP0_BUSY | USB_EP0_INCLUDE_ZERO;
0797  30C0     MOVLW 0xC0
0798  0022     MOVLB 0x2
0799  00CA     MOVWF 0x4A
2211:          
2212:                  switch(SetupPkt.bDescriptorType)
079A  2FC9     GOTO 0x7C9
07C9  0020     MOVLB 0x0
07CA  0843     MOVF 0x43, W
07CB  3A01     XORLW 0x1
07CC  1903     BTFSC STATUS, 0x2
07CD  2F9B     GOTO 0x79B
07CE  3A03     XORLW 0x3
07CF  1903     BTFSC STATUS, 0x2
07D0  2FA4     GOTO 0x7A4
07D1  3A01     XORLW 0x1
07D2  1903     BTFSC STATUS, 0x2
07D3  2FB6     GOTO 0x7B6
07D4  2FC6     GOTO 0x7C6
2213:                  {
2214:                      case USB_DESCRIPTOR_DEVICE:
2215:                          #if !defined(USB_USER_DEVICE_DESCRIPTOR)
2216:                              inPipes[0].pSrc.bRom = (ROM BYTE*)&device_dsc;
2217:                          #else
2218:                              inPipes[0].pSrc.bRom = (ROM BYTE*)USB_USER_DEVICE_DESCRIPTOR;
079B  308D     MOVLW 0x8D
079C  0022     MOVLB 0x2
079D  00C8     MOVWF CtrlTrfData
079E  3086     MOVLW 0x86
079F  00C9     MOVWF 0x49
2219:                          #endif
2220:                          inPipes[0].wCount.Val = sizeof(device_dsc);
07A0  3012     MOVLW 0x12
07A1  00CB     MOVWF 0x4B
07A2  01CC     CLRF 0x4C
2221:                          break;
07A3  0008     RETURN
2222:                      case USB_DESCRIPTOR_CONFIGURATION:
2223:                          #if !defined(USB_USER_CONFIG_DESCRIPTOR)
2224:                              inPipes[0].pSrc.bRom = *(USB_CD_Ptr+SetupPkt.bDscIndex);
2225:                          #else
2226:                              inPipes[0].pSrc.bRom = *(USB_USER_CONFIG_DESCRIPTOR+SetupPkt.bDscIndex);
07A4  3004     MOVLW 0x4
07A5  0084     MOVWF FSR0L
07A6  3086     MOVLW 0x86
07A7  27D6     CALL 0x7D6
07A8  3187     MOVLP 0x7
2227:                          #endif
2228:          
2229:                          //This must be loaded using byte addressing.  The source pointer
2230:                          //  may not be word aligned for the 16 or 32 bit machines resulting
2231:                          //  in an address error on the dereference.
2232:                          inPipes[0].wCount.byte.LB = *(inPipes[0].pSrc.bRom+2);
07A9  27E9     CALL 0x7E9
07AA  3187     MOVLP 0x7
07AB  3E02     ADDLW 0x2
07AC  27E1     CALL 0x7E1
07AD  3187     MOVLP 0x7
07AE  00CB     MOVWF 0x4B
2233:                          inPipes[0].wCount.byte.HB = *(inPipes[0].pSrc.bRom+3);
07AF  0849     MOVF 0x49, W
07B0  27E9     CALL 0x7E9
07B1  3187     MOVLP 0x7
07B2  3E03     ADDLW 0x3
07B3  27E1     CALL 0x7E1
07B4  00CC     MOVWF 0x4C
2234:                          break;
07B5  0008     RETURN
2235:                      case USB_DESCRIPTOR_STRING:
2236:                          //USB_NUM_STRING_DESCRIPTORS was introduced as optional in release v2.3.  In v2.4 and
2237:                          //  later it is now manditory.  This should be defined in usb_config.h and should
2238:                          //  indicate the number of string descriptors.
2239:                          if(SetupPkt.bDscIndex<USB_NUM_STRING_DESCRIPTORS)
07B6  3003     MOVLW 0x3
07B7  0242     SUBWF 0x42, W
07B8  1803     BTFSC STATUS, 0x0
07B9  2FC6     GOTO 0x7C6
2240:                          {
2241:                              //Get a pointer to the String descriptor requested
2242:                              inPipes[0].pSrc.bRom = *(USB_SD_Ptr+SetupPkt.bDscIndex);
07BA  3001     MOVLW 0x1
07BB  0084     MOVWF FSR0L
07BC  3086     MOVLW 0x86
07BD  27D6     CALL 0x7D6
2243:                              // Set data count
2244:                              inPipes[0].wCount.Val = *inPipes[0].pSrc.bRom;                    
07BE  0848     MOVF CtrlTrfData, W
07BF  0084     MOVWF FSR0L
07C0  0849     MOVF 0x49, W
07C1  0085     MOVWF FSR0H
07C2  0800     MOVF INDF0, W
07C3  00CB     MOVWF 0x4B
07C4  01CC     CLRF 0x4C
2245:                          }
07C5  0008     RETURN
2246:                          #if defined(IMPLEMENT_MICROSOFT_OS_DESCRIPTOR)
2247:                          else if(SetupPkt.bDscIndex == MICROSOFT_OS_DESCRIPTOR_INDEX)
2248:                          {
2249:                              //Get a pointer to the special MS OS string descriptor requested
2250:                              inPipes[0].pSrc.bRom = (ROM BYTE*)&MSOSDescriptor;
2251:                              // Set data count
2252:                              inPipes[0].wCount.Val = *inPipes[0].pSrc.bRom;                    
2253:                          }    
2254:                          #endif
2255:                          else
2256:                          {
2257:                              inPipes[0].info.Val = 0;
07C6  0022     MOVLB 0x2
07C7  01CA     CLRF 0x4A
07C8  0008     RETURN
2258:                          }
2259:                          break;
2260:                      default:
2261:                          inPipes[0].info.Val = 0;
2262:                          break;
2263:                  }//end switch
2264:              }//end if
2265:          }//end USBStdGetDscHandler
07D5  0008     RETURN
2266:          
2267:          /********************************************************************
2268:           * Function:        void USBStdGetStatusHandler(void)
2269:           *
2270:           * PreCondition:    None
2271:           *
2272:           * Input:           None
2273:           *
2274:           * Output:          None
2275:           *
2276:           * Side Effects:    None
2277:           *
2278:           * Overview:        This routine handles the standard GET_STATUS request
2279:           *
2280:           * Note:            None
2281:           *******************************************************************/
2282:          static void USBStdGetStatusHandler(void)
2283:          {
2284:              CtrlTrfData[0] = 0;                 // Initialize content
17B6  0020     MOVLB 0x0
17B7  01C8     CLRF CtrlTrfData
2285:              CtrlTrfData[1] = 0;
17B8  01C9     CLRF 0x49
2286:          
2287:              switch(SetupPkt.Recipient)
17B9  2FDF     GOTO 0x7DF
17DF  0840     MOVF SetupPkt, W
17E0  391F     ANDLW 0x1F
17E1  1903     BTFSC STATUS, 0x2
17E2  2FBA     GOTO 0x7BA
17E3  3A01     XORLW 0x1
17E4  1903     BTFSC STATUS, 0x2
17E5  2FC4     GOTO 0x7C4
17E6  3A03     XORLW 0x3
17E7  1903     BTFSC STATUS, 0x2
17E8  2FC7     GOTO 0x7C7
17E9  2FEA     GOTO 0x7EA
2288:              {
2289:                  case USB_SETUP_RECIPIENT_DEVICE_BITFIELD:
2290:                      inPipes[0].info.bits.busy = 1;
17BA  0022     MOVLB 0x2
17BB  17CA     BSF 0x4A, 0x7
2291:                      /*
2292:                       * [0]: bit0: Self-Powered Status [0] Bus-Powered [1] Self-Powered
2293:                       *      bit1: RemoteWakeup        [0] Disabled    [1] Enabled
2294:                       */
2295:                      if(self_power == 1) // self_power is defined in HardwareProfile.h
2296:                      {
2297:                          CtrlTrfData[0]|=0x01;
17BC  0020     MOVLB 0x0
17BD  1448     BSF CtrlTrfData, 0x0
2298:                      }
2299:          
2300:                      if(RemoteWakeup == TRUE)
17BE  0022     MOVLB 0x2
17BF  0B2F     DECFSZ 0x2F, W
17C0  2FEA     GOTO 0x7EA
2301:                      {
2302:                          CtrlTrfData[0]|=0x02;
17C1  0020     MOVLB 0x0
17C2  14C8     BSF CtrlTrfData, 0x1
17C3  2FEA     GOTO 0x7EA
2303:                      }
2304:                      break;
2305:                  case USB_SETUP_RECIPIENT_INTERFACE_BITFIELD:
2306:                      inPipes[0].info.bits.busy = 1;     // No data to update
17C4  0022     MOVLB 0x2
17C5  17CA     BSF 0x4A, 0x7
2307:                      break;
17C6  2FEA     GOTO 0x7EA
2308:                  case USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD:
2309:                      inPipes[0].info.bits.busy = 1;
17C7  0022     MOVLB 0x2
17C8  17CA     BSF 0x4A, 0x7
2310:                      /*
2311:                       * [0]: bit0: Halt Status [0] Not Halted [1] Halted
2312:                       */
2313:                      {
2314:                          BDT_ENTRY *p;
2315:          
2316:                          if(SetupPkt.EPDir == 0)
17C9  0020     MOVLB 0x0
17CA  1BC4     BTFSC 0x44, 0x7
17CB  2FD0     GOTO 0x7D0
2317:                          {
2318:                              p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
17CC  0844     MOVF 0x44, W
17CD  27F4     CALL 0x7F4
17CE  3197     MOVLP 0x17
17CF  2FD2     GOTO 0x7D2
17D0  27FA     CALL 0x7FA
17D1  3197     MOVLP 0x17
2319:                          }
2320:                          else
2321:                          {
2322:                              p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
17D2  0801     MOVF INDF1, W
17D3  00D6     MOVWF direction
2323:                          }
2324:          
2325:                          if((p->STAT.UOWN == 1) && (p->STAT.BSTALL == 1))
17D4  0086     MOVWF FSR1L
17D5  0187     CLRF FSR1H
17D6  1F81     BTFSS INDF1, 0x7
17D7  2FEA     GOTO 0x7EA
17D8  0856     MOVF direction, W
17D9  0086     MOVWF FSR1L
17DA  1D01     BTFSS INDF1, 0x2
17DB  2FEA     GOTO 0x7EA
2326:                              CtrlTrfData[0]=0x01;    // Set bit0
17DC  3001     MOVLW 0x1
17DD  00C8     MOVWF CtrlTrfData
17DE  2FEA     GOTO 0x7EA
2327:                          break;
2328:                      }
2329:              }//end switch
2330:          
2331:              if(inPipes[0].info.bits.busy == 1)
17EA  0022     MOVLB 0x2
17EB  1FCA     BTFSS 0x4A, 0x7
17EC  0008     RETURN
2332:              {
2333:                  inPipes[0].pSrc.bRam = (BYTE*)&CtrlTrfData;            // Set Source
17ED  3048     MOVLW 0x48
17EE  00C8     MOVWF CtrlTrfData
17F0  01C9     CLRF 0x49
2334:                  inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
17F1  144A     BSF 0x4A, 0x0
2335:                  inPipes[0].wCount.v[0] = 2;                         // Set data count
17EF  3002     MOVLW 0x2
17F2  00CB     MOVWF 0x4B
2336:              }//end if(...)
2337:          }//end USBStdGetStatusHandler
17F3  0008     RETURN
2338:          
2339:          /********************************************************************
2340:           * Function:        void USBStallHandler(void)
2341:           *
2342:           * PreCondition:    None
2343:           *
2344:           * Input:           None
2345:           *
2346:           * Output:          None
2347:           *
2348:           * Side Effects:    
2349:           *
2350:           * Overview:        This function handles the event of a STALL 
2351:           *                  occuring on the bus
2352:           *
2353:           * Note:            None
2354:           *******************************************************************/
2355:          static void USBStallHandler(void)
2356:          {
2357:              /*
2358:               * Does not really have to do anything here,
2359:               * even for the control endpoint.
2360:               * All BDs of Endpoint 0 are owned by SIE right now,
2361:               * but once a Setup Transaction is received, the ownership
2362:               * for EP0_OUT will be returned to CPU.
2363:               * When the Setup Transaction is serviced, the ownership
2364:               * for EP0_IN will then be forced back to CPU by firmware.
2365:               */
2366:          
2367:              /* v2b fix */
2368:              if(U1EP0bits.EPSTALL == 1)
0311  1C18     BTFSS T1CON, 0x0
2369:              {
2370:                  // UOWN - if 0, owned by CPU, if 1, owned by SIE
2371:                  if((pBDTEntryEP0OutCurrent->STAT.Val == _USIE) && (pBDTEntryIn[0]->STAT.Val == (_USIE|_BSTALL)))
0313  0020     MOVLB 0x0
0314  086E     MOVF pBDTEntryEP0OutCurrent, W
0315  0086     MOVWF FSR1L
0316  0187     CLRF FSR1H
0317  0801     MOVF INDF1, W
0318  3A80     XORLW 0x80
0319  1D03     BTFSS STATUS, 0x2
031A  2B25     GOTO 0x325
031B  086A     MOVF pBDTEntryIn, W
031C  0086     MOVWF FSR1L
031D  0801     MOVF INDF1, W
031E  3A84     XORLW 0x84
031F  1D03     BTFSS STATUS, 0x2
0320  2B25     GOTO 0x325
2372:                  {
2373:                      // Set ep0Bo to stall also
2374:                      pBDTEntryEP0OutCurrent->STAT.Val = _USIE|_DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
0321  086E     MOVF pBDTEntryEP0OutCurrent, W
0322  0086     MOVWF FSR1L
0323  308C     MOVLW 0x8C
0324  0081     MOVWF INDF1
2375:                  }//end if
2376:                  U1EP0bits.EPSTALL = 0;               // Clear stall status
0325  003D     MOVLB 0x1D
0326  1018     BCF T1CON, 0x0
2377:              }//end if
2378:          
2379:              USBClearInterruptFlag(USBStallIFReg,USBStallIFBitNum);
0327  1290     BCF 0x10, 0x5
2380:          }
0328  0008     RETURN
2381:          
2382:          /********************************************************************
2383:           * Function:        void USBSuspend(void)
2384:           *
2385:           * PreCondition:    None
2386:           *
2387:           * Input:           None
2388:           *
2389:           * Output:          None
2390:           *
2391:           * Side Effects:    
2392:           *
2393:           * Overview:        This function handles if the host tries to 
2394:           *                  suspend the device
2395:           *
2396:           * Note:            None
2397:           *******************************************************************/
2398:          static void USBSuspend(void)
2399:          {
2400:              /*
2401:               * NOTE: Do not clear UIRbits.ACTVIF here!
2402:               * Reason:
2403:               * ACTVIF is only generated once an IDLEIF has been generated.
2404:               * This is a 1:1 ratio interrupt generation.
2405:               * For every IDLEIF, there will be only one ACTVIF regardless of
2406:               * the number of subsequent bus transitions.
2407:               *
2408:               * If the ACTIF is cleared here, a problem could occur when:
2409:               * [       IDLE       ][bus activity ->
2410:               * <--- 3 ms ----->     ^
2411:               *                ^     ACTVIF=1
2412:               *                IDLEIF=1
2413:               *  #           #           #           #   (#=Program polling flags)
2414:               *                          ^
2415:               *                          This polling loop will see both
2416:               *                          IDLEIF=1 and ACTVIF=1.
2417:               *                          However, the program services IDLEIF first
2418:               *                          because ACTIVIE=0.
2419:               *                          If this routine clears the only ACTIVIF,
2420:               *                          then it can never get out of the suspend
2421:               *                          mode.
2422:               */
2423:              USBActivityIE = 1;                     // Enable bus activity interrupt
0329  1512     BSF PIR2, 0x2
2424:              USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
032A  1210     BCF 0x10, 0x4
2425:          
2426:              #if defined(__18CXX) || defined(_PIC14E)
2427:                  U1CONbits.SUSPND = 1;                   // Put USB module in power conserve
032B  148E     BSF PORTC, 0x1
2428:                                                          // mode, SIE clock inactive
2429:              #endif
2430:              USBBusIsSuspended = TRUE;
2431:           
2432:              /*
2433:               * At this point the PIC can go into sleep,idle, or
2434:               * switch to a slower clock, etc.  This should be done in the
2435:               * USBCBSuspend() if necessary.
2436:               */
2437:              USB_SUSPEND_HANDLER(EVENT_SUSPEND,0,0);
032C  3075     MOVLW 0x75
032D  23B5     CALL 0x3B5
032E  3180     MOVLP 0x0
032F  29E4     GOTO 0x1E4
2438:          }
2439:          
2440:          /********************************************************************
2441:           * Function:        void USBWakeFromSuspend(void)
2442:           *
2443:           * PreCondition:    None
2444:           *
2445:           * Input:           None
2446:           *
2447:           * Output:          None
2448:           *
2449:           * Side Effects:    None
2450:           *
2451:           * Overview:
2452:           *
2453:           * Note:            None
2454:           *******************************************************************/
2455:          static void USBWakeFromSuspend(void)
2456:          {
2457:              USBBusIsSuspended = FALSE;
2458:          
2459:              /*
2460:               * If using clock switching, the place to restore the original
2461:               * microcontroller core clock frequency is in the USBCBWakeFromSuspend() callback
2462:               */
2463:              USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0);
0330  3074     MOVLW 0x74
0331  23B5     CALL 0x3B5
0332  3180     MOVLP 0x0
0333  21E4     CALL 0x1E4
2464:          
2465:              #if defined(__18CXX) || defined(_PIC14E)
2466:                  //To avoid improperly clocking the USB module, make sure the oscillator
2467:                  //settings are consistant with USB operation before clearing the SUSPND bit.
2468:                  //Make sure the correct oscillator settings are selected in the 
2469:                  //"USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0)" handler.
2470:                  U1CONbits.SUSPND = 0;   // Bring USB module out of power conserve
0334  003D     MOVLB 0x1D
0335  108E     BCF PORTC, 0x1
2471:                                          // mode.
2472:              #endif
2473:          
2474:          
2475:              USBActivityIE = 0;
0336  1112     BCF PIR2, 0x2
2476:          
2477:              /********************************************************************
2478:              Bug Fix: Feb 26, 2007 v2.1
2479:              *********************************************************************
2480:              The ACTVIF bit cannot be cleared immediately after the USB module wakes
2481:              up from Suspend or while the USB module is suspended. A few clock cycles
2482:              are required to synchronize the internal hardware state machine before
2483:              the ACTIVIF bit can be cleared by firmware. Clearing the ACTVIF bit
2484:              before the internal hardware is synchronized may not have an effect on
2485:              the value of ACTVIF. Additonally, if the USB module uses the clock from
2486:              the 96 MHz PLL source, then after clearing the SUSPND bit, the USB
2487:              module may not be immediately operational while waiting for the 96 MHz
2488:              PLL to lock.
2489:              ********************************************************************/
2490:          
2491:              // UIRbits.ACTVIF = 0;                      // Removed
2492:              #if defined(__18CXX)
2493:              while(USBActivityIF)
2494:              #endif
2495:              {
2496:                  USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
0337  1110     BCF 0x10, 0x2
2497:              }  // Added
2498:          
2499:          }//end USBWakeFromSuspend
0338  0008     RETURN
2500:          
2501:          /********************************************************************
2502:           * Function:        void USBCtrlEPService(void)
2503:           *
2504:           * PreCondition:    USTAT is loaded with a valid endpoint address.
2505:           *
2506:           * Input:           None
2507:           *
2508:           * Output:          None
2509:           *
2510:           * Side Effects:    None
2511:           *
2512:           * Overview:        USBCtrlEPService checks for three transaction
2513:           *                  types that it knows how to service and services
2514:           *                  them:
2515:           *                  1. EP0 SETUP
2516:           *                  2. EP0 OUT
2517:           *                  3. EP0 IN
2518:           *                  It ignores all other types (i.e. EP1, EP2, etc.)
2519:           *
2520:           * Note:            None
2521:           *******************************************************************/
2522:          static void USBCtrlEPService(void)
2523:          {
2524:              //If we get to here, that means a successful transaction has just occurred 
2525:              //on EP0.  This means "progress" has occurred in the currently pending 
2526:              //control transfer, so we should re-initialize our timeout counter.
2527:              #if defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)
2528:                  USBStatusStageTimeoutCounter = USB_STATUS_STAGE_TIMEOUT;
02BD  302D     MOVLW 0x2D
02BE  00B8     MOVWF 0x38
2529:              #endif
2530:          	
2531:          	//Check if the last transaction was on EP0 OUT endpoint (of any kind, to either the even or odd buffer if ping pong buffers used)
2532:              if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_OUT_EVEN)
02BF  0021     MOVLB 0x1
02C0  086F     MOVF pBDTEntryEP0OutNext, W
02C1  39FD     ANDLW 0xFD
02C2  1D03     BTFSS STATUS, 0x2
02C3  2B09     GOTO 0x309
2533:              {
2534:          		//Point to the EP0 OUT buffer of the buffer that arrived
2535:                  #if defined (_PIC14E) || defined(__18CXX)
2536:                      pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK)>>1];
02C4  366F     LSRF pBDTEntryEP0OutNext, W
02C5  393F     ANDLW 0x3F
02C6  0709     ADDWF WREG, W
02C7  0709     ADDWF WREG, W
02C8  3E20     ADDLW 0x20
02C9  0020     MOVLB 0x0
02CA  00EE     MOVWF pBDTEntryEP0OutCurrent
2537:                  #elif defined(__C30__) || defined(__C32__) || defined __XC16__
2538:                      pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK)>>2];
2539:                  #else
2540:                      #error "unimplemented"
2541:                  #endif
2542:          
2543:          		//Set the next out to the current out packet
2544:                  pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
02CB  00EF     MOVWF pBDTEntryEP0OutNext
2545:          		//Toggle it to the next ping pong buffer (if applicable)
2546:                  ((BYTE_VAL*)&pBDTEntryEP0OutNext)->Val ^= USB_NEXT_EP0_OUT_PING_PONG;
02CC  3004     MOVLW 0x4
02CD  06EF     XORWF pBDTEntryEP0OutNext, F
2547:          
2548:          		//If the current EP0 OUT buffer has a SETUP packet
2549:                  if(pBDTEntryEP0OutCurrent->STAT.PID == PID_SETUP)
02CE  086E     MOVF pBDTEntryEP0OutCurrent, W
02CF  0086     MOVWF FSR1L
02D0  0187     CLRF FSR1H
02D1  0C01     RRF INDF1, W
02D2  0C89     RRF WREG, F
02D3  390F     ANDLW 0xF
02D4  3A0D     XORLW 0xD
02D5  1D03     BTFSS STATUS, 0x2
02D6  2B08     GOTO 0x308
2550:                  {
2551:                      unsigned char setup_cnt;
2552:          
2553:          	        //The SETUP transaction data may have gone into the the CtrlTrfData 
2554:          	        //buffer, or elsewhere, depending upon how the BDT was prepared
2555:          	        //before the transaction.  Therefore, we should copy the data to the 
2556:          	        //SetupPkt buffer so it can be processed correctly by USBCtrlTrfSetupHandler().		    
2557:                      for(setup_cnt = 0; setup_cnt < 8u; setup_cnt++) //SETUP data packets always contain exactly 8 bytes.
02D7  01E9     CLRF setup_cnt
02F4  3008     MOVLW 0x8
02F5  0AE9     INCF setup_cnt, F
02F6  0269     SUBWF setup_cnt, W
02F7  1C03     BTFSS STATUS, 0x0
02F8  2AD8     GOTO 0x2D8
2558:                      {
2559:                          *(BYTE*)((BYTE*)&SetupPkt + setup_cnt) = *(BYTE*)ConvertToVirtualAddress(pBDTEntryEP0OutCurrent->ADR);
02D8  0869     MOVF setup_cnt, W
02D9  3E40     ADDLW 0x40
02DA  0086     MOVWF FSR1L
02DB  0187     CLRF FSR1H
02DC  086E     MOVF pBDTEntryEP0OutCurrent, W
02DD  3E02     ADDLW 0x2
02DE  0084     MOVWF FSR0L
02DF  0185     CLRF FSR0H
02E0  3F00     MOVIW [0]FSR0
02E1  0021     MOVLB 0x1
02E2  00A4     MOVWF 0x24
02E3  3F01     MOVIW [1]FSR0
02E4  00A5     MOVWF 0x25
02E5  0824     MOVF 0x24, W
02E6  0084     MOVWF FSR0L
02E7  0825     MOVF 0x25, W
02E8  0085     MOVWF FSR0H
02E9  0800     MOVF INDF0, W
02EA  0081     MOVWF INDF1
2560:                          pBDTEntryEP0OutCurrent->ADR++;
02EB  0020     MOVLB 0x0
02EC  086E     MOVF pBDTEntryEP0OutCurrent, W
02ED  3E02     ADDLW 0x2
02EE  0086     MOVWF FSR1L
02EF  3001     MOVLW 0x1
02F0  0781     ADDWF INDF1, F
02F1  3141     ADDFSR 1, 1
02F2  1803     BTFSC STATUS, 0x0
02F3  0A81     INCF INDF1, F
2561:                      }    
2562:                      pBDTEntryEP0OutCurrent->ADR = ConvertToPhysicalAddress(&SetupPkt);
02F9  3040     MOVLW 0x40
02FA  0021     MOVLB 0x1
02FB  00A4     MOVWF 0x24
02FC  01A5     CLRF 0x25
02FD  0020     MOVLB 0x0
02FE  086E     MOVF pBDTEntryEP0OutCurrent, W
02FF  3E02     ADDLW 0x2
0300  0086     MOVWF FSR1L
0301  0187     CLRF FSR1H
0302  0021     MOVLB 0x1
0303  0824     MOVF 0x24, W
0304  3FC0     MOVWI [0]FSR1
0305  0825     MOVF 0x25, W
0306  3FC1     MOVWI [1]FSR1
2563:          
2564:          			//Handle the control transfer (parse the 8-byte SETUP command and figure out what to do)
2565:                      USBCtrlTrfSetupHandler();
0307  2814     GOTO 0x14
2566:                  }
2567:                  else
2568:                  {
2569:          			//Handle the DATA transfer
2570:                      USBCtrlTrfOutHandler();
0308  2B95     GOTO 0x395
2571:                  }
2572:              }
2573:              else if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_IN)
0309  30FD     MOVLW 0xFD
030A  056F     ANDWF pBDTEntryEP0OutNext, W
030B  00A4     MOVWF 0x24
030C  3A04     XORLW 0x4
030D  1D03     BTFSS STATUS, 0x2
030E  0008     RETURN
2574:              {
2575:          		//Otherwise the transmission was and EP0 IN
2576:          		//  so take care of the IN transfer
2577:                  USBCtrlTrfInHandler();
030F  3183     MOVLP 0x3
0310  2BE9     GOTO 0x3E9
2578:              }
2579:          
2580:          }//end USBCtrlEPService
0311  1C18     BTFSS T1CON, 0x0
2581:          
2582:          /********************************************************************
2583:           * Function:        void USBCtrlTrfSetupHandler(void)
2584:           *
2585:           * PreCondition:    SetupPkt buffer is loaded with valid USB Setup Data
2586:           *
2587:           * Input:           None
2588:           *
2589:           * Output:          None
2590:           *
2591:           * Side Effects:    None
2592:           *
2593:           * Overview:        This routine is a task dispatcher and has 3 stages.
2594:           *                  1. It initializes the control transfer state machine.
2595:           *                  2. It calls on each of the module that may know how to
2596:           *                     service the Setup Request from the host.
2597:           *                     Module Example: USBD, HID, CDC, MSD, ...
2598:           *                     A callback function, USBCBCheckOtherReq(),
2599:           *                     is required to call other module handlers.
2600:           *                  3. Once each of the modules has had a chance to check if
2601:           *                     it is responsible for servicing the request, stage 3
2602:           *                     then checks direction of the transfer to determine how
2603:           *                     to prepare EP0 for the control transfer.
2604:           *                     Refer to USBCtrlEPServiceComplete() for more details.
2605:           *
2606:           * Note:            Microchip USB Firmware has three different states for
2607:           *                  the control transfer state machine:
2608:           *                  1. WAIT_SETUP
2609:           *                  2. CTRL_TRF_TX (device sends data to host through IN transactions)
2610:           *                  3. CTRL_TRF_RX (device receives data from host through OUT transactions)
2611:           *                  Refer to firmware manual to find out how one state
2612:           *                  is transitioned to another.
2613:           *
2614:           *                  A Control Transfer is composed of many USB transactions.
2615:           *                  When transferring data over multiple transactions,
2616:           *                  it is important to keep track of data source, data
2617:           *                  destination, and data count. These three parameters are
2618:           *                  stored in pSrc,pDst, and wCount. A flag is used to
2619:           *                  note if the data source is from ROM or RAM.
2620:           *
2621:           *******************************************************************/
2622:          static void USBCtrlTrfSetupHandler(void)
2623:          {
2624:              //--------------------------------------------------------------------------
2625:              //1. Re-initialize state tracking variables related to control transfers.
2626:              //--------------------------------------------------------------------------
2627:              shortPacketStatus = SHORT_PKT_NOT_USED;  
0014  01EC     CLRF USBDeferStatusStagePacket
2628:              USBDeferStatusStagePacket = FALSE;
0015  0020     MOVLB 0x0
0016  01EC     CLRF USBDeferStatusStagePacket
2629:              USBDeferINDataStagePackets = FALSE;
0017  0022     MOVLB 0x2
0018  01B2     CLRF 0x32
2630:              USBDeferOUTDataStagePackets = FALSE;
0019  01B3     CLRF 0x33
2631:              BothEP0OutUOWNsSet = FALSE;    
001A  01AE     CLRF 0x2E
2632:              controlTransferState = WAIT_SETUP;
001B  0020     MOVLB 0x0
001C  01ED     CLRF controlTransferState
2633:          
2634:              //Abandon any previous control transfers that might have been using EP0.
2635:              //Ordinarily, nothing actually needs abandoning, since the previous control
2636:              //transfer would have completed successfully prior to the host sending the next
2637:              //SETUP packet.  However, in a timeout error case, or after an EP0 STALL event,
2638:              //one or more UOWN bits might still be set.  If so, we should clear the UOWN bits,
2639:              //so the EP0 IN/OUT endpoints are in a known inactive state, ready for re-arming
2640:              //by the class request handler that will be called next.
2641:              pBDTEntryIn[0]->STAT.Val &= ~(_USIE);     
001D  086A     MOVF pBDTEntryIn, W
001E  0086     MOVWF FSR1L
0020  0187     CLRF FSR1H
0021  1381     BCF INDF1, 0x7
2642:              ((BYTE_VAL*)&pBDTEntryIn[0])->Val ^= USB_NEXT_EP0_IN_PING_PONG;
001F  3004     MOVLW 0x4
0022  06EA     XORWF pBDTEntryIn, F
2643:              pBDTEntryIn[0]->STAT.Val &= ~(_USIE);      
0023  086A     MOVF pBDTEntryIn, W
0024  0086     MOVWF FSR1L
0026  1381     BCF INDF1, 0x7
2644:              ((BYTE_VAL*)&pBDTEntryIn[0])->Val ^= USB_NEXT_EP0_IN_PING_PONG;
0025  3004     MOVLW 0x4
0027  06EA     XORWF pBDTEntryIn, F
2645:              pBDTEntryEP0OutNext->STAT.Val &= ~(_USIE);         
0028  086F     MOVF pBDTEntryEP0OutNext, W
0029  0086     MOVWF FSR1L
002A  1381     BCF INDF1, 0x7
2646:          
2647:              inPipes[0].info.Val = 0;
002B  0022     MOVLB 0x2
002C  01CA     CLRF 0x4A
2648:              inPipes[0].wCount.Val = 0;
002D  01CB     CLRF 0x4B
002E  01CC     CLRF 0x4C
2649:              outPipes[0].info.Val = 0;
002F  01A2     CLRF 0x22
2650:              outPipes[0].wCount.Val = 0;
0030  01A3     CLRF 0x23
0031  01A4     CLRF 0x24
2651:              
2652:          
2653:              //--------------------------------------------------------------------------
2654:              //2. Now find out what was in the SETUP packet, and begin handling the request.
2655:              //--------------------------------------------------------------------------
2656:              USBCheckStdRequest();                                               //Check for standard USB "Chapter 9" requests.
0032  203A     CALL 0x3A
0033  3180     MOVLP 0x0
2657:              USB_NONSTANDARD_EP0_REQUEST_HANDLER(EVENT_EP0_REQUEST,0,0); //Check for USB device class specific requests
0034  3003     MOVLW 0x3
0035  23B5     CALL 0x3B5
0036  3180     MOVLP 0x0
0037  21E4     CALL 0x1E4
2658:          
2659:          
2660:              //--------------------------------------------------------------------------
2661:              //3. Re-arm EP0 IN and EP0 OUT endpoints, based on the control transfer in 
2662:              //   progress.  If one of the above handlers (in step 2) knew how to process
2663:              //   the request, it will have set one of the inPipes[0].info.bits.busy or
2664:              //   outPipes[0].info.bits.busy flags = 1.  This lets the
2665:              //   USBCtrlEPServiceComplete() function know how and which endpoints to 
2666:              //   arm.  If both info.bits.busy flags are = 0, then no one knew how to
2667:              //   process the request.  In this case, the default behavior will be to
2668:              //   perform protocol STALL on EP0.
2669:              //-------------------------------------------------------------------------- 
2670:              USBCtrlEPServiceComplete();
0038  3184     MOVLP 0x4
0039  2C3D     GOTO 0x43D
2671:          }//end USBCtrlTrfSetupHandler
003A  0020     MOVLB 0x0
2672:          
2673:          
2674:          /******************************************************************************
2675:           * Function:        void USBCtrlTrfOutHandler(void)
2676:           *
2677:           * PreCondition:    None
2678:           *
2679:           * Input:           None
2680:           *
2681:           * Output:          None
2682:           *
2683:           * Side Effects:    None
2684:           *
2685:           * Overview:        This routine handles an OUT transaction according to
2686:           *                  which control transfer state is currently active.
2687:           *
2688:           * Note:            Note that if the the control transfer was from
2689:           *                  host to device, the session owner should be notified
2690:           *                  at the end of each OUT transaction to service the
2691:           *                  received data.
2692:           *
2693:           *****************************************************************************/
2694:          static void USBCtrlTrfOutHandler(void)
2695:          {
2696:              if(controlTransferState == CTRL_TRF_RX)
0395  086D     MOVF controlTransferState, W
0396  3A02     XORLW 0x2
0397  1D03     BTFSS STATUS, 0x2
0398  2B9B     GOTO 0x39B
2697:              {
2698:                  USBCtrlTrfRxService();	//Copies the newly received data into the appropriate buffer and configures EP0 OUT for next transaction.
0399  3186     MOVLP 0x6
039A  2EAF     GOTO 0x6AF
2699:              }
2700:              else //In this case the last OUT transaction must have been a status stage of a CTRL_TRF_TX (<setup><in><in>...<OUT>  <-- this last OUT just occurred as the status stage)
2701:              {
2702:                  //If the status stage is complete, this means we are done with the 
2703:                  //control transfer.  Go back to the idle "WAIT_SETUP" state.
2704:                  controlTransferState = WAIT_SETUP;
039B  01ED     CLRF controlTransferState
2705:          
2706:          	    //Prepare EP0 OUT for the next SETUP transaction, however, it may have
2707:          	    //already been prepared if ping-pong buffering was enabled on EP0 OUT,
2708:          	    //and the last control transfer was of direction: device to host, see
2709:          	    //USBCtrlEPServiceComplete().  If it was already prepared, do not want
2710:          	    //to do anything to the BDT.
2711:          		if(BothEP0OutUOWNsSet == FALSE)
039C  0022     MOVLB 0x2
039D  08AE     MOVF 0x2E, F
039E  1D03     BTFSS STATUS, 0x2
039F  2BB3     GOTO 0x3B3
2712:          		{
2713:          	        pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
03A0  0020     MOVLB 0x0
03A1  0A6F     INCF pBDTEntryEP0OutNext, W
03A2  3187     MOVLP 0x7
03A3  271C     CALL 0x71C
03A4  3180     MOVLP 0x0
2714:          	        pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
03A5  00DC     MOVWF work
03A6  01DD     CLRF y
03A7  086F     MOVF pBDTEntryEP0OutNext, W
03A8  3E02     ADDLW 0x2
03A9  0086     MOVWF FSR1L
03AA  085C     MOVF work, W
03AB  3FC0     MOVWI [0]FSR1
03AC  085D     MOVF y, W
03AD  3FC1     MOVWI [1]FSR1
2715:          	        pBDTEntryEP0OutNext->STAT.Val = _USIE|_DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;			
03AE  086F     MOVF pBDTEntryEP0OutNext, W
03AF  0086     MOVWF FSR1L
03B0  308C     MOVLW 0x8C
03B1  0081     MOVWF INDF1
2716:          		}
03B2  0008     RETURN
2717:          		else
2718:          		{
2719:          			BothEP0OutUOWNsSet = FALSE;
03B3  01AE     CLRF 0x2E
2720:          		}
2721:              }
2722:          }
03B4  0008     RETURN
2723:          
2724:          /******************************************************************************
2725:           * Function:        void USBCtrlTrfInHandler(void)
2726:           *
2727:           * PreCondition:    None
2728:           *
2729:           * Input:           None
2730:           *
2731:           * Output:          None
2732:           *
2733:           * Side Effects:    None
2734:           *
2735:           * Overview:        This routine handles an IN transaction according to
2736:           *                  which control transfer state is currently active.
2737:           *
2738:           * Note:            A Set Address Request must not change the acutal address
2739:           *                  of the device until the completion of the control
2740:           *                  transfer. The end of the control transfer for Set Address
2741:           *                  Request is an IN transaction. Therefore it is necessary
2742:           *                  to service this unique situation when the condition is
2743:           *                  right. Macro mUSBCheckAdrPendingState is defined in
2744:           *                  usb9.h and its function is to specifically service this
2745:           *                  event.
2746:           *****************************************************************************/
2747:          static void USBCtrlTrfInHandler(void)
2748:          {
2749:              BYTE lastDTS;
2750:          
2751:              lastDTS = pBDTEntryIn[0]->STAT.DTS;
03E9  0020     MOVLB 0x0
03EA  086A     MOVF pBDTEntryIn, W
03EB  0086     MOVWF FSR1L
03EC  3000     MOVLW 0x0
03ED  0187     CLRF FSR1H
03EE  1B01     BTFSC INDF1, 0x6
03EF  3001     MOVLW 0x1
03F0  00DB     MOVWF i
2752:          
2753:              //switch to the next ping pong buffer
2754:              ((BYTE_VAL*)&pBDTEntryIn[0])->Val ^= USB_NEXT_EP0_IN_PING_PONG;
03F1  3004     MOVLW 0x4
03F2  06EA     XORWF pBDTEntryIn, F
2755:          
2756:              //Must check if in ADR_PENDING_STATE.  If so, we need to update the address
2757:              //now, since the IN status stage of the (set address) control transfer has 
2758:              //evidently completed successfully.
2759:              if(USBDeviceState == ADR_PENDING_STATE)
03F3  0021     MOVLB 0x1
03F4  086A     MOVF pBDTEntryIn, W
03F5  3A08     XORLW 0x8
03F6  1D03     BTFSS STATUS, 0x2
03F7  2C04     GOTO 0x404
2760:              {
2761:                  U1ADDR = SetupPkt.bDevADR.Val;
03F8  0020     MOVLB 0x0
03F9  0842     MOVF 0x42, W
03FA  003D     MOVLB 0x1D
03FB  0096     MOVWF TMR1L
2762:                  if(U1ADDR != 0u)
03FC  0816     MOVF TMR1L, W
03FD  1903     BTFSC STATUS, 0x2
03FE  2C01     GOTO 0x401
2763:                  {
2764:                      USBDeviceState=ADDRESS_STATE;
03FF  3010     MOVLW 0x10
0400  2C02     GOTO 0x402
2765:                  }
2766:                  else
2767:                  {
2768:                      USBDeviceState=DEFAULT_STATE;
0401  3004     MOVLW 0x4
0402  0021     MOVLB 0x1
0403  00EA     MOVWF pBDTEntryIn
2769:                  }
2770:              }//end if
2771:          
2772:          
2773:              if(controlTransferState == CTRL_TRF_TX)
0404  0020     MOVLB 0x0
0405  0B6D     DECFSZ controlTransferState, W
0406  2C30     GOTO 0x430
2774:              {
2775:                  pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(CtrlTrfData);
0407  3048     MOVLW 0x48
0408  00D9     MOVWF x
0409  01DA     CLRF i_718
040A  086A     MOVF pBDTEntryIn, W
040B  3E02     ADDLW 0x2
040C  0086     MOVWF FSR1L
040D  0187     CLRF FSR1H
040E  0859     MOVF x, W
040F  3FC0     MOVWI [0]FSR1
0410  085A     MOVF i_718, W
0411  3FC1     MOVWI [1]FSR1
2776:                  USBCtrlTrfTxService();
0412  24AE     CALL 0x4AE
0413  3183     MOVLP 0x3
2777:          
2778:                  //Check if we have already sent a short packet.  If so, configure
2779:                  //the endpoint to STALL in response to any further IN tokens (in the
2780:                  //case that the host erroneously tries to receive more data than it
2781:                  //should).
2782:                  if(shortPacketStatus == SHORT_PKT_SENT)
0414  0021     MOVLB 0x1
0415  086C     MOVF USBDeferStatusStagePacket, W
0416  3A02     XORLW 0x2
0417  1D03     BTFSS STATUS, 0x2
0418  2C20     GOTO 0x420
2783:                  {
2784:                      // If a short packet has been sent, don't want to send any more,
2785:                      // stall next time if host is still trying to read.
2786:                      pBDTEntryIn[0]->STAT.Val = _USIE|_BSTALL;
0419  0020     MOVLB 0x0
041A  086A     MOVF pBDTEntryIn, W
041B  0086     MOVWF FSR1L
041C  3084     MOVLW 0x84
041D  0187     CLRF FSR1H
041E  0081     MOVWF INDF1
2787:                  }
041F  0008     RETURN
2788:                  else
2789:                  {
2790:                      if(lastDTS == 0)
0420  0020     MOVLB 0x0
0421  08DB     MOVF i, F
0422  1D03     BTFSS STATUS, 0x2
0423  2C2A     GOTO 0x42A
2791:                      {
2792:                          pBDTEntryIn[0]->STAT.Val = _USIE|_DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
0424  086A     MOVF pBDTEntryIn, W
0425  0086     MOVWF FSR1L
0426  30C8     MOVLW 0xC8
0427  0187     CLRF FSR1H
0428  0081     MOVWF INDF1
2793:                      }
0429  0008     RETURN
2794:                      else
2795:                      {
2796:                          pBDTEntryIn[0]->STAT.Val = _USIE|_DAT0|(_DTSEN & _DTS_CHECKING_ENABLED);
042A  086A     MOVF pBDTEntryIn, W
042B  0086     MOVWF FSR1L
042C  3088     MOVLW 0x88
042D  0187     CLRF FSR1H
042E  0081     MOVWF INDF1
042F  0008     RETURN
2797:                      }
2798:                  }//end if(...)else
2799:              }
2800:          	else // must have been a CTRL_TRF_RX status stage IN packet (<setup><out><out>...<IN>  <-- this last IN just occurred as the status stage)
2801:          	{
2802:                  //if someone is still expecting data from the control transfer
2803:                  //  then make sure to terminate that request and let them know that
2804:                  //  they are done
2805:                  if(outPipes[0].info.bits.busy == 1)
0430  0022     MOVLB 0x2
0431  1FA2     BTFSS 0x22, 0x7
0432  2C3A     GOTO 0x43A
2806:                  {
2807:                      if(outPipes[0].pFunc != NULL)
0433  0825     MOVF 0x25, W
0434  1903     BTFSC STATUS, 0x2
0435  2C39     GOTO 0x439
2808:                      {
2809:                          outPipes[0].pFunc();
0436  0825     MOVF 0x25, W
0437  3184     MOVLP 0x4
0438  2C38     GOTO 0x438
2810:                      }
2811:                      outPipes[0].info.bits.busy = 0;
0439  13A2     BCF 0x22, 0x7
2812:                  }
2813:              	
2814:                  controlTransferState = WAIT_SETUP;
043A  0020     MOVLB 0x0
043B  01ED     CLRF controlTransferState
2815:                  //Don't need to arm EP0 OUT here.  It was already armed by the last <out> that
2816:                  //got processed by the USBCtrlTrfRxService() handler.
2817:          	}	
2818:          
2819:          }
043C  0008     RETURN
2820:          
2821:          
2822:          /********************************************************************
2823:           * Function:        void USBCheckStdRequest(void)
2824:           *
2825:           * PreCondition:    None
2826:           *
2827:           * Input:           None
2828:           *
2829:           * Output:          None
2830:           *
2831:           * Side Effects:    None
2832:           *
2833:           * Overview:        This routine checks the setup data packet to see
2834:           *                  if it knows how to handle it
2835:           *
2836:           * Note:            None
2837:           *******************************************************************/
2838:          static void USBCheckStdRequest(void)
2839:          {
2840:              if(SetupPkt.RequestType != USB_SETUP_TYPE_STANDARD_BITFIELD) return;
003A  0020     MOVLB 0x0
003B  0E40     SWAPF SetupPkt, W
003C  0C89     RRF WREG, F
003D  3903     ANDLW 0x3
003E  1D03     BTFSS STATUS, 0x2
003F  0008     RETURN
2841:          
2842:              switch(SetupPkt.bRequest)
0040  0841     MOVF 0x41, W
0041  0084     MOVWF FSR0L
0042  300D     MOVLW 0xD
0043  0204     SUBWF FSR0L, W
0044  1803     BTFSC STATUS, 0x0
0045  0008     RETURN
0046  3190     MOVLP 0x10
0047  3504     LSLF FSR0L, W
0048  3E00     ADDLW 0x0
0049  0082     MOVWF PCL
1000  3180     MOVLP 0x0
2843:              {
2844:                  case USB_REQUEST_SET_ADDRESS:
2845:                      inPipes[0].info.bits.busy = 1;            // This will generate a zero length packet
004B  0022     MOVLB 0x2
004D  17CA     BSF 0x4A, 0x7
2846:                      USBDeviceState = ADR_PENDING_STATE;       // Update state only
004C  3008     MOVLW 0x8
004E  0021     MOVLB 0x1
004F  00EA     MOVWF pBDTEntryIn
2847:                      /* See USBCtrlTrfInHandler() for the next step */
2848:                      break;
0050  0008     RETURN
2849:                  case USB_REQUEST_GET_DESCRIPTOR:
2850:                      USBStdGetDscHandler();
0051  3187     MOVLP 0x7
0052  2F92     GOTO 0x792
2851:                      break;
2852:                  case USB_REQUEST_SET_CONFIGURATION:
2853:                      USBStdSetCfgHandler();
0053  3187     MOVLP 0x7
0054  2F2B     GOTO 0x72B
2854:                      break;
2855:                  case USB_REQUEST_GET_CONFIGURATION:
2856:                      inPipes[0].pSrc.bRam = (BYTE*)&USBActiveConfiguration;         // Set Source
0055  30ED     MOVLW 0xED
0056  0022     MOVLB 0x2
0057  00C8     MOVWF CtrlTrfData
0058  3000     MOVLW 0x0
0059  01C9     CLRF 0x49
2857:                      inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
005A  144A     BSF 0x4A, 0x0
2858:                      inPipes[0].wCount.v[0] = 1;                         // Set data count
005B  01CB     CLRF 0x4B
005C  0ACB     INCF 0x4B, F
2859:                      inPipes[0].info.bits.busy = 1;
005D  17CA     BSF 0x4A, 0x7
2860:                      break;
005E  0008     RETURN
2861:                  case USB_REQUEST_GET_STATUS:
2862:                      USBStdGetStatusHandler();
005F  3197     MOVLP 0x17
0060  2FB6     GOTO 0x7B6
2863:                      break;
2864:                  case USB_REQUEST_CLEAR_FEATURE:
2865:                  case USB_REQUEST_SET_FEATURE:
2866:                      USBStdFeatureReqHandler();
0061  2876     GOTO 0x76
2867:                      break;
2868:                  case USB_REQUEST_GET_INTERFACE:
2869:                      inPipes[0].pSrc.bRam = (BYTE*)&USBAlternateInterface[SetupPkt.bIntfID];  // Set source
0062  0844     MOVF 0x44, W
0063  3EEE     ADDLW 0xEE
0064  2856     GOTO 0x56
2870:                      inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
2871:                      inPipes[0].wCount.v[0] = 1;                         // Set data count
2872:                      inPipes[0].info.bits.busy = 1;
2873:                      break;
2874:                  case USB_REQUEST_SET_INTERFACE:
2875:                      inPipes[0].info.bits.busy = 1;
0065  0022     MOVLB 0x2
0066  17CA     BSF 0x4A, 0x7
2876:                      USBAlternateInterface[SetupPkt.bIntfID] = SetupPkt.bAltID;
0067  0020     MOVLB 0x0
0068  0844     MOVF 0x44, W
0069  3EEE     ADDLW 0xEE
006A  0086     MOVWF FSR1L
006B  0187     CLRF FSR1H
006C  0842     MOVF 0x42, W
006D  0081     MOVWF INDF1
2877:                      break;
006E  0008     RETURN
2878:                  case USB_REQUEST_SET_DESCRIPTOR:
2879:                      USB_SET_DESCRIPTOR_HANDLER(EVENT_SET_DESCRIPTOR,0,0);
006F  3002     MOVLW 0x2
0070  00E0     MOVWF count
0071  01E1     CLRF 0x61
0072  01E2     CLRF 0x62
0073  01E3     CLRF 0x63
0074  01E4     CLRF 0x64
0075  29E4     GOTO 0x1E4
2880:                      break;
2881:                  case USB_REQUEST_SYNCH_FRAME:
2882:                  default:
2883:                      break;
2884:              }//end switch
2885:          }//end USBCheckStdRequest
004A  0008     RETURN
2886:          
2887:          /********************************************************************
2888:           * Function:        void USBStdFeatureReqHandler(void)
2889:           *
2890:           * PreCondition:    None
2891:           *
2892:           * Input:           None
2893:           *
2894:           * Output:          Can alter BDT entries.  Can also modify USB stack
2895:           *                  Maintained variables.
2896:           *
2897:           * Side Effects:    None
2898:           *
2899:           * Overview:        This routine handles the standard SET & CLEAR
2900:           *                  FEATURES requests
2901:           *
2902:           * Note:            This is a private function, intended for internal 
2903:           *                  use by the USB stack, when processing SET/CLEAR
2904:           *                  feature requests.  
2905:           *******************************************************************/
2906:          static void USBStdFeatureReqHandler(void)
2907:          {
2908:              BDT_ENTRY *p;
2909:              EP_STATUS current_ep_data;
2910:              #if defined(__C32__)
2911:                  DWORD* pUEP;
2912:              #else
2913:                  unsigned char* pUEP;             
2914:              #endif
2915:              
2916:          
2917:              #ifdef	USB_SUPPORT_OTG
2918:              //Check for USB On-The-Go (OTG) specific requests
2919:              if ((SetupPkt.bFeature == OTG_FEATURE_B_HNP_ENABLE)&&
2920:                  (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2921:              {  
2922:                  inPipes[0].info.bits.busy = 1;
2923:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2924:                      USBOTGEnableHnp();
2925:                  else
2926:                      USBOTGDisableHnp();
2927:              }
2928:          
2929:              if ((SetupPkt.bFeature == OTG_FEATURE_A_HNP_SUPPORT)&&
2930:                  (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2931:              {
2932:                  inPipes[0].info.bits.busy = 1;
2933:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2934:                      USBOTGEnableSupportHnp();
2935:                  else
2936:                      USBOTGDisableSupportHnp();
2937:              }
2938:          
2939:              if ((SetupPkt.bFeature == OTG_FEATURE_A_ALT_HNP_SUPPORT)&&
2940:                  (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2941:              {
2942:                  inPipes[0].info.bits.busy = 1;
2943:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2944:                      USBOTGEnableAltHnp();
2945:                  else
2946:                      USBOTGDisableAltHnp();
2947:              }
2948:              #endif   //#ifdef USB_SUPPORT_OTG 
2949:          
2950:              //Check if the host sent a valid SET or CLEAR feature (remote wakeup) request.
2951:              if((SetupPkt.bFeature == USB_FEATURE_DEVICE_REMOTE_WAKEUP)&&
2952:                 (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
0076  0020     MOVLB 0x0
0077  0B42     DECFSZ 0x42, W
0078  288A     GOTO 0x8A
0079  0840     MOVF SetupPkt, W
007A  391F     ANDLW 0x1F
007B  1D03     BTFSS STATUS, 0x2
007C  288A     GOTO 0x8A
2953:              {
2954:                  inPipes[0].info.bits.busy = 1;
007D  0022     MOVLB 0x2
007E  17CA     BSF 0x4A, 0x7
2955:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
007F  0020     MOVLB 0x0
0080  0841     MOVF 0x41, W
0081  3A03     XORLW 0x3
0082  1D03     BTFSS STATUS, 0x2
0083  2888     GOTO 0x88
2956:                      RemoteWakeup = TRUE;
0084  0022     MOVLB 0x2
0085  01AF     CLRF 0x2F
0086  0AAF     INCF 0x2F, F
0087  288A     GOTO 0x8A
2957:                  else
2958:                      RemoteWakeup = FALSE;
0088  0022     MOVLB 0x2
0089  01AF     CLRF 0x2F
2959:              }//end if
2960:          
2961:              //Check if the host sent a valid SET or CLEAR endpoint halt request.
2962:              if((SetupPkt.bFeature == USB_FEATURE_ENDPOINT_HALT)&&
2963:                 (SetupPkt.Recipient == USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD)&&
2964:                 (SetupPkt.EPNum != 0) && (SetupPkt.EPNum <= USB_MAX_EP_NUMBER)&&
2965:                 (USBDeviceState == CONFIGURED_STATE))
008A  0020     MOVLB 0x0
008B  0842     MOVF 0x42, W
008C  1D03     BTFSS STATUS, 0x2
008D  0008     RETURN
008E  0840     MOVF SetupPkt, W
008F  391F     ANDLW 0x1F
0090  3A02     XORLW 0x2
0091  1D03     BTFSS STATUS, 0x2
0092  0008     RETURN
0093  0844     MOVF 0x44, W
0094  390F     ANDLW 0xF
0095  1903     BTFSC STATUS, 0x2
0096  0008     RETURN
0097  0844     MOVF 0x44, W
0098  390F     ANDLW 0xF
0099  00E5     MOVWF p
009A  3002     MOVLW 0x2
009B  0265     SUBWF p, W
009C  1803     BTFSC STATUS, 0x0
009D  0008     RETURN
009E  0021     MOVLB 0x1
009F  086A     MOVF pBDTEntryIn, W
00A0  3A20     XORLW 0x20
00A1  1D03     BTFSS STATUS, 0x2
00A2  0008     RETURN
2966:              {
2967:          		//The request was valid.  Take control of the control transfer and
2968:          		//perform the host requested action.
2969:          		inPipes[0].info.bits.busy = 1;
00A3  0022     MOVLB 0x2
00A4  17CA     BSF 0x4A, 0x7
2970:          
2971:                  //Fetch a pointer to the BDT that the host wants to SET/CLEAR halt on.
2972:                  if(SetupPkt.EPDir == OUT_FROM_HOST)
00A5  0020     MOVLB 0x0
00A6  1BC4     BTFSC 0x44, 0x7
00A7  28B1     GOTO 0xB1
2973:                  {
2974:                      p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
00A8  0844     MOVF 0x44, W
00A9  3197     MOVLP 0x17
00AA  27F4     CALL 0x7F4
00AB  3180     MOVLP 0x0
00AC  23CC     CALL 0x3CC
00AD  3180     MOVLP 0x0
2975:                      current_ep_data.Val = ep_data_out[SetupPkt.EPNum].Val;
00AE  3E28     ADDLW 0x28
00AF  0086     MOVWF FSR1L
00B0  28BA     GOTO 0xBA
2976:                  }
2977:                  else
2978:                  {
2979:                      p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
00B1  3197     MOVLP 0x17
00B2  27FA     CALL 0x7FA
00B3  3180     MOVLP 0x0
00B4  23CC     CALL 0x3CC
00B5  3180     MOVLP 0x0
2980:                      current_ep_data.Val = ep_data_in[SetupPkt.EPNum].Val;
00B6  3E26     ADDLW 0x26
00B7  0086     MOVWF FSR1L
00B8  3001     MOVLW 0x1
00B9  0087     MOVWF FSR1H
00BA  0801     MOVF INDF1, W
00BB  0021     MOVLB 0x1
00BC  00A2     MOVWF 0x22
2981:                  }
2982:          
2983:                  //If ping pong buffering is enabled on the requested endpoint, need 
2984:                  //to point to the one that is the active BDT entry which the SIE will 
2985:                  //use for the next attempted transaction on that EP number.
2986:                  #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
2987:                      if(current_ep_data.bits.ping_pong_state == 0) //Check if even
00BD  1822     BTFSC 0x22, 0x0
00BE  28C1     GOTO 0xC1
2988:                      {
2989:                          USBHALPingPongSetToEven(&p);
00BF  1123     BCF 0x23, 0x2
2990:                      }
00C0  28C2     GOTO 0xC2
2991:                      else //else must have been odd
2992:                      {
2993:                          USBHALPingPongSetToOdd(&p);
00C1  1523     BSF 0x23, 0x2
2994:                      }
2995:                  #endif
2996:                  
2997:                  //Update the BDT pointers with the new, next entry based on the feature
2998:                  //  request
2999:                  if(SetupPkt.EPDir == OUT_FROM_HOST)
00C2  0020     MOVLB 0x0
00C3  1BC4     BTFSC 0x44, 0x7
00C4  28CA     GOTO 0xCA
3000:                  {
3001:                      pBDTEntryOut[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
00C5  0844     MOVF 0x44, W
00C6  3197     MOVLP 0x17
00C7  27F4     CALL 0x7F4
00C8  3180     MOVLP 0x0
00C9  28CD     GOTO 0xCD
00CA  3197     MOVLP 0x17
00CB  27FA     CALL 0x7FA
00CC  3180     MOVLP 0x0
3002:                  }
3003:                  else
3004:                  {
3005:                      pBDTEntryIn[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
00CD  0021     MOVLB 0x1
00CE  0823     MOVF 0x23, W
00CF  0081     MOVWF INDF1
3006:                  }
3007:          
3008:          		//Check if it was a SET_FEATURE endpoint halt request
3009:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
00D0  0020     MOVLB 0x0
00D1  0841     MOVF 0x41, W
00D2  3A03     XORLW 0x3
00D3  1D03     BTFSS STATUS, 0x2
00D4  28F0     GOTO 0xF0
3010:                  {
3011:                      if(p->STAT.UOWN == 1)
00D5  0021     MOVLB 0x1
00D6  0823     MOVF 0x23, W
00D7  0086     MOVWF FSR1L
00D8  0187     CLRF FSR1H
00D9  1F81     BTFSS INDF1, 0x7
00DA  28E9     GOTO 0xE9
3012:                      {
3013:                          //Mark that we are terminating this transfer and that the user
3014:                          //  needs to be notified later
3015:                          if(SetupPkt.EPDir == OUT_FROM_HOST)
00DB  0020     MOVLB 0x0
00DC  1BC4     BTFSC 0x44, 0x7
00DD  28E2     GOTO 0xE2
3016:                          {
3017:                              ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 1;
00DE  0844     MOVF 0x44, W
00DF  390F     ANDLW 0xF
00E0  3E28     ADDLW 0x28
00E1  28E5     GOTO 0xE5
3018:                          }
3019:                          else
3020:                          {
3021:                              ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 1;
00E2  0844     MOVF 0x44, W
00E3  390F     ANDLW 0xF
00E4  3E26     ADDLW 0x26
00E5  0086     MOVWF FSR1L
00E6  3001     MOVLW 0x1
00E7  0087     MOVWF FSR1H
00E8  1481     BSF INDF1, 0x1
3022:                          }
3023:                      }
3024:          
3025:          			//Then STALL the endpoint
3026:                      p->STAT.Val |= _USIE|_BSTALL;
00E9  0021     MOVLB 0x1
00EA  0823     MOVF 0x23, W
00EB  0086     MOVWF FSR1L
00EC  3084     MOVLW 0x84
00ED  0187     CLRF FSR1H
00EE  0481     IORWF INDF1, F
3027:                  }//if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
00EF  0008     RETURN
3028:                  else
3029:                  {
3030:          			//Else the request must have been a CLEAR_FEATURE endpoint halt.
3031:                      #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
3032:                          //toggle over the to the non-active BDT
3033:                          USBAdvancePingPongBuffer(&p);  
00F0  3004     MOVLW 0x4
00F1  0021     MOVLB 0x1
00F2  06A3     XORWF 0x23, F
3034:          
3035:                          if(p->STAT.UOWN == 1)
00F3  0823     MOVF 0x23, W
00F4  0086     MOVWF FSR1L
00F5  0187     CLRF FSR1H
00F7  1F81     BTFSS INDF1, 0x7
00F8  2905     GOTO 0x105
3036:                          {
3037:                              //Clear UOWN and set DTS state so it will be correct the next time
3038:                              //the application firmware uses USBTransferOnePacket() on the EP.
3039:                              p->STAT.Val &= (~_USIE);    //Clear UOWN bit
00F6  0823     MOVF 0x23, W
00F9  0086     MOVWF FSR1L
00FA  1381     BCF INDF1, 0x7
3040:                              p->STAT.Val |= _DAT1;       //Set DTS to DATA1
00FB  0086     MOVWF FSR1L
00FD  1701     BSF INDF1, 0x6
3041:                              USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
00FC  3005     MOVLW 0x5
00FE  0020     MOVLB 0x0
00FF  00E0     MOVWF count
0100  23BC     CALL 0x3BC
0101  3180     MOVLP 0x0
0102  21E4     CALL 0x1E4
0103  3180     MOVLP 0x0
3042:                          }
0104  2908     GOTO 0x108
3043:                          else
3044:                          {
3045:                              //UOWN already clear, but still need to set DTS to DATA1     
3046:          					p->STAT.Val |= _DAT1;
0105  0086     MOVWF FSR1L
0106  0187     CLRF FSR1H
0107  1701     BSF INDF1, 0x6
3047:                          }
3048:          
3049:                          //toggle back to the active BDT (the one the SIE is currently looking at
3050:                          //and will use for the next successful transaction to take place on the EP
3051:                          USBAdvancePingPongBuffer(&p);    
0108  3004     MOVLW 0x4
0109  0021     MOVLB 0x1
010A  06A3     XORWF 0x23, F
3052:                          
3053:                          //Check if we are currently terminating, or have previously terminated
3054:                          //a transaction on the given endpoint.  If so, need to clear UOWN,
3055:                          //set DTS to the proper state, and call the application callback
3056:                          //function.
3057:                          if((current_ep_data.bits.transfer_terminated != 0) || (p->STAT.UOWN == 1))
010B  18A2     BTFSC 0x22, 0x1
010C  2912     GOTO 0x112
010D  0823     MOVF 0x23, W
010E  0086     MOVWF FSR1L
010F  0187     CLRF FSR1H
0110  1F81     BTFSS INDF1, 0x7
0111  292B     GOTO 0x12B
3058:                          {
3059:                              if(SetupPkt.EPDir == OUT_FROM_HOST)
0112  0020     MOVLB 0x0
0113  1BC4     BTFSC 0x44, 0x7
0114  2919     GOTO 0x119
3060:                              {
3061:                                  ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
0115  0844     MOVF 0x44, W
0116  390F     ANDLW 0xF
0117  3E28     ADDLW 0x28
0118  291C     GOTO 0x11C
3062:                              }
3063:                              else
3064:                              {
3065:                                  ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
0119  0844     MOVF 0x44, W
011A  390F     ANDLW 0xF
011B  3E26     ADDLW 0x26
011C  0086     MOVWF FSR1L
011D  3001     MOVLW 0x1
011E  0087     MOVWF FSR1H
011F  1081     BCF INDF1, 0x1
3066:                              }
3067:                              //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition     
3068:                              p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL);  
0120  0021     MOVLB 0x1
0121  23D8     CALL 0x3D8
0122  3180     MOVLP 0x0
3069:                              //Call the application event handler callback function, so it can 
3070:          					//decide if the endpoint should get re-armed again or not.
3071:                              USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
0123  3005     MOVLW 0x5
0124  0020     MOVLB 0x0
0125  00E0     MOVWF count
0126  23BC     CALL 0x3BC
0127  3180     MOVLP 0x0
0128  21E4     CALL 0x1E4
0129  3180     MOVLP 0x0
3072:                          }
012A  292C     GOTO 0x12C
012B  23D8     CALL 0x3D8
3073:                          else
3074:                          {
3075:                              //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition     
3076:                              p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL); 
3077:                          } 
3078:                      #else //else we must not be using ping-pong buffering on the requested endpoint
3079:                          //Check if we need to call the user transfer terminated event callback function.
3080:                          //We should call the callback, if the endpoint was previously terminated,
3081:                          //or the endpoint is currently armed, and the host is performing clear
3082:                          //endpoint halt, even though the endpoint wasn't stalled.
3083:                          if((current_ep_data.bits.transfer_terminated != 0) || (p->STAT.UOWN == 1))
3084:                          {
3085:                              //We are going to call the user transfer terminated callback.
3086:                              //Clear the flag so we know we took care of it and don't need
3087:                              //to call it again later.
3088:                              if(SetupPkt.EPDir == OUT_FROM_HOST)
3089:                              {
3090:                                  ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
3091:                              }
3092:                              else
3093:                              {
3094:                                  ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
3095:                              }
3096:           
3097:                              //Clear UOWN and remove the STALL condition.   
3098:                              //  In this case we also need to set the DTS bit to 1 so that
3099:                              //  it toggles to DATA0 the next time the application firmware
3100:                              //  calls USBTransferOnePacket() (or equivalent macro).  
3101:                              p->STAT.Val &= ~(_USIE | _BSTALL);  
3102:                              p->STAT.Val |= _DAT1;
3103:                              //Let the application firmware know a transaction just
3104:                              //got terminated by the host, and that it is now free to
3105:                              //re-arm the endpoint or do other tasks if desired.                                        
3106:                              USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
3107:                          }
3108:                          else
3109:                          {
3110:                              //Clear UOWN and remove the STALL condition.   
3111:                              //  In this case we also need to set the DTS bit to 1 so that
3112:                              //  it toggles to DATA0 the next time the application firmware
3113:                              //  calls USBTransferOnePacket() (or equivalent macro).  
3114:                              p->STAT.Val &= ~(_USIE | _BSTALL);  
3115:                              p->STAT.Val |= _DAT1;
3116:                          } 
3117:                      #endif //end of #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
3118:                      
3119:          			//Get a pointer to the appropriate UEPn register
3120:                      #if defined(__C32__)
3121:                          pUEP = (DWORD*)(&U1EP0);
3122:                          pUEP += (SetupPkt.EPNum*4);
3123:                      #else
3124:                          pUEP = (unsigned char*)(&U1EP0+SetupPkt.EPNum);
012C  0020     MOVLB 0x0
012D  0844     MOVF 0x44, W
012E  390F     ANDLW 0xF
012F  3E98     ADDLW 0x98
0130  00E5     MOVWF p
0131  300E     MOVLW 0xE
0132  01E6     CLRF work
0133  3DE6     ADDWFC work, F
0134  0865     MOVF p, W
0135  0021     MOVLB 0x1
0136  00A0     MOVWF BDT
0137  0020     MOVLB 0x0
0138  0866     MOVF work, W
0139  0021     MOVLB 0x1
013A  00A1     MOVWF 0x21
3125:                      #endif
3126:          
3127:          			//Clear the STALL bit in the UEP register
3128:                      *pUEP &= ~UEP_STALL;            
013B  0820     MOVF BDT, W
013C  0086     MOVWF FSR1L
013D  0821     MOVF 0x21, W
013E  0087     MOVWF FSR1H
013F  1001     BCF INDF1, 0x0
3129:                  }//end if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
3130:              }//end if (lots of checks for set/clear endpoint halt)
3131:          }//end USBStdFeatureReqHandler
0140  0008     RETURN
3132:          
3133:          
3134:          /** EOF USBDevice.c *****************************************************/
---  /home/chris/Dev/klondike/firmware/Klondike.X/main.c  -----------------------------------------------
1:             /********
2:              * 
3:              *  Klondike ASIC Miner - main.c - firmware USB support and control loop
4:              * 
5:              * (C) Copyright 2013 Chris Savery. 
6:              *
7:              * This program is free software: you can redistribute it and/or modify
8:              * it under the terms of the GNU General Public License as published by
9:              * the Free Software Foundation, either version 3 of the License, or
10:             * (at your option) any later version.
11:             *
12:             * This program is distributed in the hope that it will be useful,
13:             * but WITHOUT ANY WARRANTY; without even the implied warranty of
14:             * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
15:             * GNU General Public License for more details.
16:             *
17:             * You should have received a copy of the GNU General Public License
18:             * along with this program.  If not, see <http://www.gnu.org/licenses/>.
19:             *
20:             * Portions Derived from Microchip LPC Dev Kit and USB stack code 
21:             * are covered under their own license from Microchip and not included
22:             * in the open source license as other source code. 
23:             * 
24:             * Supports only PIC16LF1459 processor.
25:             */
26:            
27:            #include "GenericTypeDefs.h"
28:            #include "Compiler.h"
29:            #include "USB/usb.h"
30:            #include "USB/usb_function_generic.h"
31:            #include "HardwareProfile.h"
32:            #include "klondike.h"
33:            
34:            #if defined (USE_INTERNAL_OSC)  //Definition in the hardware profile
35:                __CONFIG(FOSC_INTOSC & WDTE_OFF & PWRTE_ON & MCLRE_OFF & CP_OFF & BOREN_ON & CLKOUTEN_OFF & IESO_OFF & FCMEN_OFF);
36:                __CONFIG(WRT_OFF & CPUDIV_NOCLKDIV & USBLSCLK_48MHz & PLLMULT_3x & PLLEN_ENABLED & STVREN_ON &  BORV_LO & LPBOR_OFF & LVP_OFF);
37:            #else
38:                __CONFIG(FOSC_HS & WDTE_OFF & PWRTE_ON & MCLRE_OFF & CP_OFF & BOREN_ON & CLKOUTEN_OFF & IESO_OFF & FCMEN_OFF);
39:                __CONFIG(WRT_OFF & CPUDIV_NOCLKDIV & USBLSCLK_48MHz & PLLMULT_4x & PLLEN_ENABLED & STVREN_ON &  BORV_LO & LPBOR_OFF & LVP_OFF);
40:            #endif
41:            
42:            #define IN_DATA_BUFFER_ADDRESS 0x2140
43:            #define OUT_DATA_BUFFER_ADDRESS 0x2190
44:            #define IN_DATA_BUFFER_ADDRESS_TAG @IN_DATA_BUFFER_ADDRESS
45:            #define OUT_DATA_BUFFER_ADDRESS_TAG @OUT_DATA_BUFFER_ADDRESS 
46:            
47:            unsigned char INPacket[USBGEN_EP_SIZE] IN_DATA_BUFFER_ADDRESS_TAG;      //User application buffer for sending IN packets to the host
48:            unsigned char OUTPacket[USBGEN_EP_SIZE] OUT_DATA_BUFFER_ADDRESS_TAG;    //User application buffer for receiving and holding OUT packets sent from the host
49:            
50:            USB_HANDLE USBGenericOutHandle;  //USB handle.  Must be initialized to 0 at startup.
51:            USB_HANDLE USBGenericInHandle;   //USB handle.  Must be initialized to 0 at startup.
52:            
53:            BYTE WQI, WQX;
54:            
55:            extern WORKSTATUS Status;
56:            extern BYTE SlaveAddress;
57:            extern I2CSTATE I2CState;
58:            extern BYTE I2CCount;
59:            
60:            /** P R I V A T E  P R O T O T Y P E S ***************************************/
61:            static void InitializeSystem(void);
62:            void ProcessIO(void);
63:            void USBDeviceTasks(void);
64:            void USBCBSendResume(void);
65:            void UserInit(void);
66:            
67:            void SendCmdReply(char *cmd, BYTE *ReplyBuf, BYTE count);
68:            
69:            void interrupt ISRCode()
70:            {
0004  3180     MOVLP 0x0
0005  0020     MOVLB 0x0
0006  087F     MOVF 0x7F, W
0007  00FD     MOVWF 0x7D
71:                //if(RCIF)
72:                if(IOCBF)
0008  0027     MOVLB 0x7
0009  0816     MOVF TMR1L, W
000A  1903     BTFSC STATUS, 0x2
000B  280E     GOTO 0xE
73:                    ResultRx();
000C  3185     MOVLP 0x5
000D  2514     CALL 0x514
74:                //if(TMR0IF)
75:                //    WorkTick();
76:                //if(RCIF)
77:                //    ResultRx();
78:                //if(TMR1GIF)
79:                //    UpdateFanSpeed();
80:                /*if(BCL1IF) {
81:                    BCL1IF = 0; I2CState.Next = 0;
82:                }
83:                if(SSP1IF) {
84:                    SSP1IF = 0;
85:                    if(I2CState.Slave)
86:                        I2CSlave();
87:                    else if(I2CState.Next < I2C_WRITE) // split because not enough contigous code space
88:                        I2CRead();
89:                    else
90:                        I2CWrite();
91:                }*/
92:                #if defined(USB_INTERRUPT)
93:                    USBDeviceTasks();
94:                #endif
95:            }
000E  087D     MOVF 0x7D, W
96:            
97:            int main(void)
98:            {   
99:                InitializeSystem();
0861  25EA     CALL 0x5EA
100:           
101:               while(1)
102:               {
103:                   #if defined(USB_INTERRUPT)
104:                       //if(USB_BUS_SENSE && (USBGetDeviceState() == DETACHED_STATE))
105:                       //{
106:                           USBDeviceAttach();              
107:                       //}
108:                   #endif
109:           
110:                   /*if(USBDeviceState < CONFIGURED_STATE) {
111:                       if(!I2CState.Slave)
112:                           InitI2CSlave();
113:                       }
114:                   else if(!I2CState.Master)
115:                       InitI2CMaster();*/
116:           
117:                   #if defined(USB_POLLING)
118:               // Check bus status and service USB interrupts.
119:                   USBDeviceTasks(); // Interrupt or polling method.  If using polling, must call
0862  3181     MOVLP 0x1
0863  2141     CALL 0x141
0864  3188     MOVLP 0x8
120:                                     // this function periodically.  This function will take care
121:                                     // of processing and responding to SETUP transactions 
122:                                     // (such as during the enumeration process when you first
123:                                     // plug in).  USB hosts require that USB devices should accept
124:                                     // and process SETUP packets in a timely fashion.  Therefore,
125:                                     // when using polling, this function should be called 
126:                                     // regularly (such as once every 1.8ms or faster** [see 
127:                                     // inline code comments in usb_device.c for explanation when
128:                                     // "or faster" applies])  In most cases, the USBDeviceTasks() 
129:                                     // function does not take very long to execute (ex: <100 
130:                                     // instruction cycles) before it returns.
131:                   #endif
132:                   
133:                   if(TMR0IF)
0865  1D0B     BTFSS INTCON, 0x2
0866  2869     GOTO 0x69
134:                       WorkTick();
0867  2718     CALL 0x718
0868  3188     MOVLP 0x8
135:           
136:                   if(Status.State == 'P'){
0869  0022     MOVLB 0x2
086A  084F     MOVF 0x4F, W
086B  3A50     XORLW 0x50
086C  1D03     BTFSS STATUS, 0x2
086D  2870     GOTO 0x70
137:                       AsicPushWork();
086E  224C     CALL 0x24C
086F  3188     MOVLP 0x8
138:                   }
139:                                 
140:                   ProcessIO();  
0870  2563     CALL 0x563
0871  3188     MOVLP 0x8
0872  2862     GOTO 0x62
141:                         
142:               }//end while
143:           }//end main
0873  00E5     MOVWF p
144:           
145:           static void InitializeSystem(void)
146:           {
147:               // all pins digital mode, except RC2, which has a Thermistor on it
148:               ANSELA = 0x00;
0DEA  0023     MOVLB 0x3
0DEB  018C     CLRF PORTA
149:               ANSELB = 0x00;
0DEC  018D     CLRF PORTB
150:               ANSELC = 0x04;  
0DED  3004     MOVLW 0x4
0DEE  008E     MOVWF PORTC
151:           
152:               #if defined (USE_INTERNAL_OSC)
153:                   OSCTUNE = 0;
0DEF  0021     MOVLB 0x1
0DF0  0198     CLRF T1CON
154:                   OSCCON = 0xFC;          //16MHz HFINTOSC with 3x PLL enabled (48MHz operation)
0DF1  30FC     MOVLW 0xFC
0DF2  0099     MOVWF T1GCON
155:                   ACTCON = 0x90;          //Enable active clock tuning with USB
0DF3  3090     MOVLW 0x90
0DF4  0027     MOVLB 0x7
0DF5  009B     MOVWF PR2
156:               #endif
157:           
158:               USBGenericOutHandle = 0;
0DF6  0022     MOVLB 0x2
0DF7  01B5     CLRF 0x35
159:               USBGenericInHandle = 0;
0DF8  01B4     CLRF 0x34
160:               WQI = WQX = 0;
0DF9  01BA     CLRF 0x3A
0DFA  01B9     CLRF 0x39
161:               
162:               UserInit();
0DFB  25FE     CALL 0x5FE
163:           
164:               USBDeviceInit();    //usb_device.c.  Initializes USB module SFRs and firmware
0DFC  3182     MOVLP 0x2
0DFD  2A13     GOTO 0x213
165:                                   //variables to known states.
166:           }//end InitializeSystem
167:           
168:           
169:           void UserInit(void)
170:           {
171:               InitLED();
0DFE  0021     MOVLB 0x1
0DFF  128C     BCF PORTA, 0x5
0E00  0022     MOVLB 0x2
0E01  168C     BSF PORTA, 0x5
172:               InitTempSensor();
0E02  2707     CALL 0x707
0E03  3188     MOVLP 0x8
173:               //InitFAN();
174:               InitWorkTick();
0E04  2609     CALL 0x609
0E05  3188     MOVLP 0x8
175:               //InitI2CMaster();
176:               InitResultRx();
0E06  274B     CALL 0x74B
0E07  3188     MOVLP 0x8
177:               DetectAsics();
0E08  2F5C     GOTO 0x75C
178:           
179:           }//end UserInit
0E09  1295     BCF TMR0, 0x5
180:           
181:           void ProcessIO(void)
182:           {   
183:             
184:               if((USBDeviceState < CONFIGURED_STATE)||(USBSuspendControl==1)) return;
0D63  3020     MOVLW 0x20
0D64  0021     MOVLB 0x1
0D65  026A     SUBWF pBDTEntryIn, W
0D66  1C03     BTFSS STATUS, 0x0
0D67  0008     RETURN
0D68  003D     MOVLB 0x1D
0D69  188E     BTFSC PORTC, 0x1
0D6A  0008     RETURN
185:           
186:               /*if(USBGetDeviceState() == DETACHED_STATE) {
187:                   if(I2CCount > 0) {
188:                       ProcessCmd(OUTPacket);
189:                       I2CCount = 0;
190:                       }
191:               }
192:               else*/
193:               if(!USBHandleBusy(USBGenericOutHandle)) {
0D6B  0022     MOVLB 0x2
0D6C  0835     MOVF 0x35, W
0D6D  1903     BTFSC STATUS, 0x2
0D6E  2D74     GOTO 0x574
0D6F  0835     MOVF 0x35, W
0D70  26F0     CALL 0x6F0
0D71  3188     MOVLP 0x8
0D72  00E6     MOVWF work
0D73  2D76     GOTO 0x576
0D74  0021     MOVLB 0x1
0D75  01E6     CLRF work
0D76  01E7     CLRF n
0D77  0867     MOVF n, W
0D78  0466     IORWF work, W
0D79  1D03     BTFSS STATUS, 0x2
0D7A  2D89     GOTO 0x589
194:                   //if( OUTPacket[1] != MASTER_ADDRESS )
195:                   //    I2CRelay(OUTPacket, USBGEN_EP_SIZE);
196:                   //else
197:                       ProcessCmd(OUTPacket);
0D7B  30A0     MOVLW 0xA0
0D7C  2073     CALL 0x73
0D7D  3188     MOVLP 0x8
198:               USBGenericOutHandle = USBGenRead(USBGEN_EP_NUM, (BYTE*)&OUTPacket, USBGEN_EP_SIZE);
0D7E  0020     MOVLB 0x0
0D7F  30A0     MOVLW 0xA0
0D80  01D9     CLRF x
0D81  00DA     MOVWF i_718
0D82  3040     MOVLW 0x40
0D83  00DB     MOVWF i
0D84  3001     MOVLW 0x1
0D85  25B2     CALL 0x5B2
0D86  3188     MOVLP 0x8
0D87  0022     MOVLB 0x2
0D88  00B5     MOVWF 0x35
199:               }
200:           
201:               if(WQI != WQX && !USBHandleBusy(USBGenericInHandle)) {
0D89  0022     MOVLB 0x2
0D8A  0839     MOVF 0x39, W
0D8B  063A     XORWF 0x3A, W
0D8C  1903     BTFSC STATUS, 0x2
0D8D  0008     RETURN
0D8E  0834     MOVF 0x34, W
0D8F  1903     BTFSC STATUS, 0x2
0D90  2D96     GOTO 0x596
0D91  0834     MOVF 0x34, W
0D92  26F0     CALL 0x6F0
0D93  3188     MOVLP 0x8
0D94  00E8     MOVWF i
0D95  2D98     GOTO 0x598
0D96  0021     MOVLB 0x1
0D97  01E8     CLRF i
0D98  01E9     CLRF setup_cnt
0D99  0869     MOVF setup_cnt, W
0D9A  0468     IORWF i, W
0D9B  1D03     BTFSS STATUS, 0x2
0D9C  0008     RETURN
202:                   USBGenericInHandle = USBGenWrite(USBGEN_EP_NUM, (BYTE*)&INPacket[WQX*USB_RECORD_SIZE], USB_RECORD_SIZE);
0D9D  0020     MOVLB 0x0
0D9E  300F     MOVLW 0xF
0D9F  01D9     CLRF x
0DA0  0AD9     INCF x, F
0DA1  00D6     MOVWF direction
0DA2  0022     MOVLB 0x2
0DA3  083A     MOVF 0x3A, W
0DA4  2521     CALL 0x521
0DA5  3188     MOVLP 0x8
0DA6  3E20     ADDLW 0x20
0DA7  00DA     MOVWF i_718
0DA8  300F     MOVLW 0xF
0DA9  00DB     MOVWF i
0DAA  3001     MOVLW 0x1
0DAB  25B2     CALL 0x5B2
0DAC  0022     MOVLB 0x2
0DAD  00B4     MOVWF 0x34
203:                   WQX = (WQX+1) & 3;
0DAE  3003     MOVLW 0x3
0DAF  0ABA     INCF 0x3A, F
0DB0  05BA     ANDWF 0x3A, F
204:               }
205:           } //end ProcessIO
0DB1  0008     RETURN
206:           
207:           void SendCmdReply(char *cmd, BYTE *data, BYTE count)
208:           {
209:               if(WQI*USB_RECORD_SIZE + count + 2 < USBGEN_EP_SIZE) {
0557  087A     MOVF count, W
0558  0020     MOVLB 0x0
0559  00D0     MOVWF 0x50
055A  01D1     CLRF 0x51
055B  0022     MOVLB 0x2
055C  0839     MOVF 0x39, W
055D  00F0     MOVWF multiplicand
055E  300F     MOVLW 0xF
055F  01F1     CLRF 0x71
0560  00F2     MOVWF product
0561  01F3     CLRF 0x73
0562  25CB     CALL 0x5CB
0563  3185     MOVLP 0x5
0564  0020     MOVLB 0x0
0565  0850     MOVF 0x50, W
0566  0770     ADDWF multiplicand, W
0567  00D2     MOVWF 0x52
0568  0851     MOVF 0x51, W
0569  3D71     ADDWFC 0x71, W
056A  00D3     MOVWF 0x53
056B  0852     MOVF 0x52, W
056C  3E02     ADDLW 0x2
056D  00D4     MOVWF 0x54
056E  3000     MOVLW 0x0
056F  3D53     ADDWFC 0x53, W
0570  00D5     MOVWF 0x55
0571  3A80     XORLW 0x80
0572  00FF     MOVWF 0x7F
0573  3080     MOVLW 0x80
0574  027F     SUBWF 0x7F, W
0575  1D03     BTFSS STATUS, 0x2
0576  2D79     GOTO 0x579
0577  3040     MOVLW 0x40
0578  0254     SUBWF 0x54, W
0579  1803     BTFSC STATUS, 0x0
057A  0008     RETURN
09A8  0860     MOVF count, W
09A9  00E1     MOVWF 0x61
09AA  01E2     CLRF 0x62
09AB  0022     MOVLB 0x2
09AC  0839     MOVF 0x39, W
09AD  0020     MOVLB 0x0
09AE  00D6     MOVWF direction
09AF  300F     MOVLW 0xF
09B0  01D7     CLRF product
09B1  00D8     MOVWF p
09B2  01D9     CLRF x
09B3  2212     CALL 0x212
09B4  3188     MOVLP 0x8
09B5  0861     MOVF 0x61, W
09B6  0756     ADDWF direction, W
09B7  00E3     MOVWF 0x63
09B8  0862     MOVF 0x62, W
09B9  3D57     ADDWFC product, W
09BA  00E4     MOVWF 0x64
09BB  0863     MOVF 0x63, W
09BC  3E02     ADDLW 0x2
09BD  00E5     MOVWF p
09BE  3000     MOVLW 0x0
09BF  3D64     ADDWFC 0x64, W
09C0  00E6     MOVWF work
09C1  3A80     XORLW 0x80
09C2  00FF     MOVWF 0x7F
09C3  3080     MOVLW 0x80
09C4  027F     SUBWF 0x7F, W
09C5  1D03     BTFSS STATUS, 0x2
09C6  29C9     GOTO 0x1C9
09C7  3040     MOVLW 0x40
09C8  0265     SUBWF p, W
09C9  1803     BTFSC STATUS, 0x0
09CA  0008     RETURN
210:                   INPacket[WQI*USB_RECORD_SIZE] = cmd[0];
057B  300F     MOVLW 0xF
057C  00F0     MOVWF multiplicand
057D  0022     MOVLB 0x2
057E  0839     MOVF 0x39, W
057F  25BF     CALL 0x5BF
0580  3185     MOVLP 0x5
0581  3E20     ADDLW 0x20
0582  0086     MOVWF FSR1L
0583  3002     MOVLW 0x2
0584  0087     MOVWF FSR1H
0585  0876     MOVF cmd, W
0586  0084     MOVWF FSR0L
0587  0877     MOVF 0x77, W
0588  0085     MOVWF FSR0H
0589  0800     MOVF INDF0, W
058A  0081     MOVWF INDF1
09CB  300F     MOVLW 0xF
09CC  0020     MOVLB 0x0
09CD  00D6     MOVWF direction
09CE  0022     MOVLB 0x2
09CF  0839     MOVF 0x39, W
09D0  2521     CALL 0x521
09D1  3188     MOVLP 0x8
09D2  3E20     ADDLW 0x20
09D3  0086     MOVWF FSR1L
09D4  3002     MOVLW 0x2
09D5  0087     MOVWF FSR1H
09D6  085C     MOVF work, W
09D7  0084     MOVWF FSR0L
09D8  085D     MOVF y, W
09D9  0085     MOVWF FSR0H
09DA  0800     MOVF INDF0, W
09DB  0081     MOVWF INDF1
211:                   INPacket[WQI*USB_RECORD_SIZE + 1] = SlaveAddress;
058B  300F     MOVLW 0xF
058C  00F0     MOVWF multiplicand
058D  0839     MOVF 0x39, W
058E  25BF     CALL 0x5BF
058F  3185     MOVLP 0x5
0590  3E21     ADDLW 0x21
0591  0086     MOVWF FSR1L
0592  3002     MOVLW 0x2
0593  0087     MOVWF FSR1H
0594  0830     MOVF 0x30, W
0595  0081     MOVWF INDF1
09DC  300F     MOVLW 0xF
09DD  00D6     MOVWF direction
09DE  0022     MOVLB 0x2
09DF  0839     MOVF 0x39, W
09E0  2521     CALL 0x521
09E1  3188     MOVLP 0x8
09E2  3E21     ADDLW 0x21
09E3  0086     MOVWF FSR1L
09E4  3002     MOVLW 0x2
09E5  0087     MOVWF FSR1H
09E6  0022     MOVLB 0x2
09E7  0830     MOVF 0x30, W
09E8  0081     MOVWF INDF1
212:                   for(BYTE n=0; n < count; n++)
0596  01FB     CLRF n
0597  087A     MOVF count, W
0598  027B     SUBWF n, W
0599  1803     BTFSC STATUS, 0x0
059A  2DBA     GOTO 0x5BA
05B8  0AFB     INCF n, F
05B9  2D97     GOTO 0x597
09E9  0020     MOVLB 0x0
09EA  01E7     CLRF n
09EB  0860     MOVF count, W
09EC  0267     SUBWF n, W
09ED  1803     BTFSC STATUS, 0x0
09EE  2A0D     GOTO 0x20D
0A0B  0AE7     INCF n, F
0A0C  29EB     GOTO 0x1EB
213:                       INPacket[WQI*USB_RECORD_SIZE + n + 2] = data[n];
059B  300F     MOVLW 0xF
059C  00F0     MOVWF multiplicand
059D  0022     MOVLB 0x2
059E  0839     MOVF 0x39, W
059F  25BF     CALL 0x5BF
05A0  3185     MOVLP 0x5
05A1  0020     MOVLB 0x0
05A2  00D0     MOVWF 0x50
05A3  3E22     ADDLW 0x22
05A4  00D1     MOVWF 0x51
05A5  087B     MOVF n, W
05A6  0751     ADDWF 0x51, W
05A7  00D2     MOVWF 0x52
05A8  0086     MOVWF FSR1L
05A9  3002     MOVLW 0x2
05AA  0087     MOVWF FSR1H
05AB  0879     MOVF 0x79, W
05AC  00D4     MOVWF 0x54
05AD  0878     MOVF data, W
05AE  00D3     MOVWF 0x53
05AF  087B     MOVF n, W
05B0  0753     ADDWF 0x53, W
05B1  0084     MOVWF FSR0L
05B2  0854     MOVF 0x54, W
05B3  1803     BTFSC STATUS, 0x0
05B4  0A54     INCF 0x54, W
05B5  0085     MOVWF FSR0H
05B6  0800     MOVF INDF0, W
05B7  0081     MOVWF INDF1
09EF  300F     MOVLW 0xF
09F0  00D6     MOVWF direction
09F1  0022     MOVLB 0x2
09F2  0839     MOVF 0x39, W
09F3  2521     CALL 0x521
09F4  3188     MOVLP 0x8
09F5  00E1     MOVWF 0x61
09F6  3E22     ADDLW 0x22
09F7  00E2     MOVWF 0x62
09F8  0867     MOVF n, W
09F9  0762     ADDWF 0x62, W
09FA  00E3     MOVWF 0x63
09FB  0086     MOVWF FSR1L
09FC  3002     MOVLW 0x2
09FD  0087     MOVWF FSR1H
09FE  085F     MOVF handle, W
09FF  00E5     MOVWF p
0A00  085E     MOVF data, W
0A01  00E4     MOVWF 0x64
0A02  0867     MOVF n, W
0A03  0764     ADDWF 0x64, W
0A04  0084     MOVWF FSR0L
0A05  0865     MOVF p, W
0A06  1803     BTFSC STATUS, 0x0
0A07  0A65     INCF p, W
0A08  0085     MOVWF FSR0H
0A09  0800     MOVF INDF0, W
0A0A  0081     MOVWF INDF1
214:                   WQI = (WQI+1) & 3;
05BA  0022     MOVLB 0x2
05BB  3003     MOVLW 0x3
05BC  0AB9     INCF 0x39, F
05BD  05B9     ANDWF 0x39, F
0A0D  0022     MOVLB 0x2
0A0E  3003     MOVLW 0x3
0A0F  0AB9     INCF 0x39, F
0A10  05B9     ANDWF 0x39, F
215:               }
216:           
217:               //if(USBDeviceState < CONFIGURED_STATE) {
218:               //    I2CCount = count+2;
219:               //}
220:               //else
221:           
222:           
223:           }
05BE  0008     RETURN
0A11  0008     RETURN
224:           
225:           
226:           // ******************************************************************************************************
227:           // ************** USB Callback Functions ****************************************************************
228:           // ******************************************************************************************************
229:           // The USB firmware stack will call the callback functions USBCBxxx() in response to certain USB related
230:           // events.  For example, if the host PC is powering down, it will stop sending out Start of Frame (SOF)
231:           // packets to your device.  In response to this, all USB devices are supposed to decrease their power
232:           // consumption from the USB Vbus to <2.5mA each.  The USB module detects this condition (which according
233:           // to the USB specifications is 3+ms of no bus activity/SOF packets) and then calls the USBCBSuspend()
234:           // function.  You should modify these callback functions to take appropriate actions for each of these
235:           // conditions.  For example, in the USBCBSuspend(), you may wish to add code that will decrease power
236:           // consumption from Vbus to <2.5mA (such as by clock switching, turning off LEDs, putting the
237:           // microcontroller to sleep, etc.).  Then, in the USBCBWakeFromSuspend() function, you may then wish to
238:           // add code that undoes the power saving things done in the USBCBSuspend() function.
239:           
240:           // The USBCBSendResume() function is special, in that the USB stack will not automatically call this
241:           // function.  This function is meant to be called from the application firmware instead.  See the
242:           // additional comments near the function.
243:           
244:           // Note *: The "usb_20.pdf" specs indicate 500uA or 2.5mA, depending upon device classification. However,
245:           // the USB-IF has officially issued an ECN (engineering change notice) changing this to 2.5mA for all 
246:           // devices.  Make sure to re-download the latest specifications to get all of the newest ECNs.
247:           
248:           /******************************************************************************
249:            * Function:        void USBCBSuspend(void)
250:            *
251:            * PreCondition:    None
252:            *
253:            * Input:           None
254:            *
255:            * Output:          None
256:            *
257:            * Side Effects:    None
258:            *
259:            * Overview:        Call back that is invoked when a USB suspend is detected
260:            *
261:            * Note:            None
262:            *****************************************************************************/
263:           void USBCBSuspend(void)
264:           {
265:               //Example power saving code.  Insert appropriate code here for the desired
266:               //application behavior.  If the microcontroller will be put to sleep, a
267:               //process similar to that shown below may be used:
268:               
269:               //ConfigureIOPinsForLowPower();
270:               //SaveStateOfAllInterruptEnableBits();
271:               //DisableAllInterruptEnableBits();
272:               //EnableOnlyTheInterruptsWhichWillBeUsedToWakeTheMicro();   //should enable at least USBActivityIF as a wake source
273:               //Sleep();
274:               //RestoreStateOfAllPreviouslySavedInterruptEnableBits();    //Preferrably, this should be done in the USBCBWakeFromSuspend() function instead.
275:               //RestoreIOPinsToNormal();                                  //Preferrably, this should be done in the USBCBWakeFromSuspend() function instead.
276:           
277:               //IMPORTANT NOTE: Do not clear the USBActivityIF (ACTVIF) bit here.  This bit is 
278:               //cleared inside the usb_device.c file.  Clearing USBActivityIF here will cause 
279:               //things to not work as intended.   
280:               
281:           }
0394  0008     RETURN
282:           
283:           /******************************************************************************
284:            * Function:        void USBCBWakeFromSuspend(void)
285:            *
286:            * PreCondition:    None
287:            *
288:            * Input:           None
289:            *
290:            * Output:          None
291:            *
292:            * Side Effects:    None
293:            *
294:            * Overview:        The host may put USB peripheral devices in low power
295:            *                  suspend mode (by "sending" 3+ms of idle).  Once in suspend
296:            *                  mode, the host may wake the device back up by sending non-
297:            *                  idle state signalling.
298:            *                  
299:            *                  This call back is invoked when a wakeup from USB suspend 
300:            *                  is detected.
301:            *
302:            * Note:            None
303:            *****************************************************************************/
304:           void USBCBWakeFromSuspend(void)
305:           {
306:               // If clock switching or other power savings measures were taken when
307:               // executing the USBCBSuspend() function, now would be a good time to
308:               // switch back to normal full power run mode conditions.  The host allows
309:               // a few milliseconds of wakeup time, after which the device must be 
310:               // fully back to normal, and capable of receiving and processing USB
311:               // packets.  In order to do this, the USB module must receive proper
312:               // clocking (IE: 48MHz clock must be available to SIE for full speed USB
313:               // operation).
314:           }
0393  0008     RETURN
315:           
316:           /********************************************************************
317:            * Function:        void USBCB_SOF_Handler(void)
318:            *
319:            * PreCondition:    None
320:            *
321:            * Input:           None
322:            *
323:            * Output:          None
324:            *
325:            * Side Effects:    None
326:            *
327:            * Overview:        The USB host sends out a SOF packet to full-speed
328:            *                  devices every 1 ms. This interrupt may be useful
329:            *                  for isochronous pipes. End designers should
330:            *                  implement callback routine as necessary.
331:            *
332:            * Note:            None
333:            *******************************************************************/
334:           void USBCB_SOF_Handler(void)
335:           {
336:               // No need to clear UIRbits.SOFIF to 0 here.
337:               // Callback caller is already doing that.
338:           }
0392  0008     RETURN
339:           
340:           /*******************************************************************
341:            * Function:        void USBCBErrorHandler(void)
342:            *
343:            * PreCondition:    None
344:            *
345:            * Input:           None
346:            *
347:            * Output:          None
348:            *
349:            * Side Effects:    None
350:            *
351:            * Overview:        The purpose of this callback is mainly for
352:            *                  debugging during development. Check UEIR to see
353:            *                  which error causes the interrupt.
354:            *
355:            * Note:            None
356:            *******************************************************************/
357:           void USBCBErrorHandler(void)
358:           {
359:               // No need to clear UEIR to 0 here.
360:               // Callback caller is already doing that.
361:           
362:               // Typically, user firmware does not need to do anything special
363:               // if a USB error occurs.  For example, if the host sends an OUT
364:               // packet to your device, but the packet gets corrupted (ex:
365:               // because of a bad connection, or the user unplugs the
366:               // USB cable during the transmission) this will typically set
367:               // one or more USB error interrupt flags.  Nothing specific
368:               // needs to be done however, since the SIE will automatically
369:               // send a "NAK" packet to the host.  In response to this, the
370:               // host will normally retry to send the packet again, and no
371:               // data loss occurs.  The system will typically recover
372:               // automatically, without the need for application firmware
373:               // intervention.
374:               
375:               // Nevertheless, this callback function is provided, such as
376:               // for debugging purposes.
377:           }
0391  0008     RETURN
378:           
379:           
380:           /*******************************************************************
381:            * Function:        void USBCBCheckOtherReq(void)
382:            *
383:            * PreCondition:    None
384:            *
385:            * Input:           None
386:            *
387:            * Output:          None
388:            *
389:            * Side Effects:    None
390:            *
391:            * Overview:        When SETUP packets arrive from the host, some
392:            *                  firmware must process the request and respond
393:            *                  appropriately to fulfill the request.  Some of
394:            *                  the SETUP packets will be for standard
395:            *                  USB "chapter 9" (as in, fulfilling chapter 9 of
396:            *                  the official USB specifications) requests, while
397:            *                  others may be specific to the USB device class
398:            *                  that is being implemented.  For example, a HID
399:            *                  class device needs to be able to respond to
400:            *                  "GET REPORT" type of requests.  This
401:            *                  is not a standard USB chapter 9 request, and 
402:            *                  therefore not handled by usb_device.c.  Instead
403:            *                  this request should be handled by class specific 
404:            *                  firmware, such as that contained in usb_function_hid.c.
405:            *
406:            * Note:            None
407:            *****************************************************************************/
408:           void USBCBCheckOtherReq(void)
409:           {
410:               USBCheckVendorRequest();
038F  2B90     GOTO 0x390
411:           }//end
0390  0008     RETURN
412:           
413:           
414:           /*******************************************************************
415:            * Function:        void USBCBStdSetDscHandler(void)
416:            *
417:            * PreCondition:    None
418:            *
419:            * Input:           None
420:            *
421:            * Output:          None
422:            *
423:            * Side Effects:    None
424:            *
425:            * Overview:        The USBCBStdSetDscHandler() callback function is
426:            *                  called when a SETUP, bRequest: SET_DESCRIPTOR request
427:            *                  arrives.  Typically SET_DESCRIPTOR requests are
428:            *                  not used in most applications, and it is
429:            *                  optional to support this type of request.
430:            *
431:            * Note:            None
432:            *****************************************************************************/
433:           void USBCBStdSetDscHandler(void)
434:           {
435:               // Must claim session ownership if supporting this request
436:           }//end
038E  0008     RETURN
437:           
438:           
439:           /******************************************************************************
440:            * Function:        void USBCBInitEP(void)
441:            *
442:            * PreCondition:    None
443:            *
444:            * Input:           None
445:            *
446:            * Output:          None
447:            *
448:            * Side Effects:    None
449:            *
450:            * Overview:        This function is called when the device becomes
451:            *                  initialized, which occurs after the host sends a
452:            *                  SET_CONFIGURATION (wValue not = 0) request.  This 
453:            *                  callback function should initialize the endpoints 
454:            *                  for the device's usage according to the current 
455:            *                  configuration.
456:            *
457:            * Note:            None
458:            *****************************************************************************/
459:           void USBCBInitEP(void)
460:           {
461:               //Enable the application endpoints
462:               USBEnableEndpoint(USBGEN_EP_NUM,USB_OUT_ENABLED|USB_IN_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
0339  301E     MOVLW 0x1E
033A  00DA     MOVWF i_718
033B  3001     MOVLW 0x1
033C  2348     CALL 0x348
463:               //Arm the application OUT endpoint, so it can receive a packet from the host
464:               USBGenericOutHandle = USBGenRead(USBGEN_EP_NUM,(BYTE*)&OUTPacket,USBGEN_EP_SIZE);
033D  30A0     MOVLW 0xA0
033E  01D9     CLRF x
033F  00DA     MOVWF i_718
0340  3040     MOVLW 0x40
0341  00DB     MOVWF i
0342  3001     MOVLW 0x1
0343  318D     MOVLP 0xD
0344  25B2     CALL 0x5B2
0345  0022     MOVLB 0x2
0346  00B5     MOVWF 0x35
465:           }
0347  0008     RETURN
466:           
467:           /********************************************************************
468:            * Function:        void USBCBSendResume(void)
469:            *
470:            * PreCondition:    None
471:            *
472:            * Input:           None
473:            *
474:            * Output:          None
475:            *
476:            * Side Effects:    None
477:            *
478:            * Overview:        The USB specifications allow some types of USB
479:            *                  peripheral devices to wake up a host PC (such
480:            *                  as if it is in a low power suspend to RAM state).
481:            *                  This can be a very useful feature in some
482:            *                  USB applications, such as an Infrared remote
483:            *                  control receiver.  If a user presses the "power"
484:            *                  button on a remote control, it is nice that the
485:            *                  IR receiver can detect this signalling, and then
486:            *                  send a USB "command" to the PC to wake up.
487:            *                  
488:            *                  The USBCBSendResume() "callback" function is used
489:            *                  to send this special USB signalling which wakes 
490:            *                  up the PC.  This function may be called by
491:            *                  application firmware to wake up the PC.  This
492:            *                  function will only be able to wake up the host if
493:            *                  all of the below are true:
494:            *                  
495:            *                  1.  The USB driver used on the host PC supports
496:            *                      the remote wakeup capability.
497:            *                  2.  The USB configuration descriptor indicates
498:            *                      the device is remote wakeup capable in the
499:            *                      bmAttributes field.
500:            *                  3.  The USB host PC is currently sleeping,
501:            *                      and has previously sent your device a SET 
502:            *                      FEATURE setup packet which "armed" the
503:            *                      remote wakeup capability.   
504:            *
505:            *                  If the host has not armed the device to perform remote wakeup,
506:            *                  then this function will return without actually performing a
507:            *                  remote wakeup sequence.  This is the required behavior, 
508:            *                  as a USB device that has not been armed to perform remote 
509:            *                  wakeup must not drive remote wakeup signalling onto the bus;
510:            *                  doing so will cause USB compliance testing failure.
511:            *                  
512:            *                  This callback should send a RESUME signal that
513:            *                  has the period of 1-15ms.
514:            *
515:            * Note:            This function does nothing and returns quickly, if the USB
516:            *                  bus and host are not in a suspended condition, or are 
517:            *                  otherwise not in a remote wakeup ready state.  Therefore, it
518:            *                  is safe to optionally call this function regularly, ex: 
519:            *                  anytime application stimulus occurs, as the function will
520:            *                  have no effect, until the bus really is in a state ready
521:            *                  to accept remote wakeup. 
522:            *
523:            *                  When this function executes, it may perform clock switching,
524:            *                  depending upon the application specific code in 
525:            *                  USBCBWakeFromSuspend().  This is needed, since the USB
526:            *                  bus will no longer be suspended by the time this function
527:            *                  returns.  Therefore, the USB module will need to be ready
528:            *                  to receive traffic from the host.
529:            *
530:            *                  The modifiable section in this routine may be changed
531:            *                  to meet the application needs. Current implementation
532:            *                  temporary blocks other functions from executing for a
533:            *                  period of ~3-15 ms depending on the core frequency.
534:            *
535:            *                  According to USB 2.0 specification section 7.1.7.7,
536:            *                  "The remote wakeup device must hold the resume signaling
537:            *                  for at least 1 ms but for no more than 15 ms."
538:            *                  The idea here is to use a delay counter loop, using a
539:            *                  common value that would work over a wide range of core
540:            *                  frequencies.
541:            *                  That value selected is 1800. See table below:
542:            *                  ==========================================================
543:            *                  Core Freq(MHz)      MIP         RESUME Signal Period (ms)
544:            *                  ==========================================================
545:            *                      48              12          1.05
546:            *                       4              1           12.6
547:            *                  ==========================================================
548:            *                  * These timing could be incorrect when using code
549:            *                    optimization or extended instruction mode,
550:            *                    or when having other interrupts enabled.
551:            *                    Make sure to verify using the MPLAB SIM's Stopwatch
552:            *                    and verify the actual signal on an oscilloscope.
553:            *******************************************************************/
554:           void USBCBSendResume(void)
555:           {
556:               static WORD delay_count;
557:               
558:               //First verify that the host has armed us to perform remote wakeup.
559:               //It does this by sending a SET_FEATURE request to enable remote wakeup,
560:               //usually just before the host goes to standby mode (note: it will only
561:               //send this SET_FEATURE request if the configuration descriptor declares
562:               //the device as remote wakeup capable, AND, if the feature is enabled
563:               //on the host (ex: on Windows based hosts, in the device manager 
564:               //properties page for the USB device, power management tab, the 
565:               //"Allow this device to bring the computer out of standby." checkbox 
566:               //should be checked).
567:               if(USBGetRemoteWakeupStatus() == TRUE) 
568:               {
569:                   //Verify that the USB bus is in fact suspended, before we send
570:                   //remote wakeup signalling.
571:                   if(USBIsBusSuspended() == TRUE)
572:                   {
573:                       USBMaskInterrupts();
574:                       
575:                       //Clock switch to settings consistent with normal USB operation.
576:                       USBCBWakeFromSuspend();
577:                       USBSuspendControl = 0; 
578:                       USBBusIsSuspended = FALSE;  //So we don't execute this code again, 
579:                                                   //until a new suspend condition is detected.
580:           
581:                       //Section 7.1.7.7 of the USB 2.0 specifications indicates a USB
582:                       //device must continuously see 5ms+ of idle on the bus, before it sends
583:                       //remote wakeup signalling.  One way to be certain that this parameter
584:                       //gets met, is to add a 2ms+ blocking delay here (2ms plus at 
585:                       //least 3ms from bus idle to USBIsBusSuspended() == TRUE, yeilds
586:                       //5ms+ total delay since start of idle).
587:                       delay_count = 3600U;        
588:                       do
589:                       {
590:                           delay_count--;
591:                       }while(delay_count);
592:                       
593:                       //Now drive the resume K-state signalling onto the USB bus.
594:                       USBResumeControl = 1;       // Start RESUME signaling
595:                       delay_count = 1800U;        // Set RESUME line for 1-13 ms
596:                       do
597:                       {
598:                           delay_count--;
599:                       }while(delay_count);
600:                       USBResumeControl = 0;       //Finished driving resume signalling
601:           
602:                       USBUnmaskInterrupts();
603:                   }
604:               }
605:           }
606:           
607:           
608:           /*******************************************************************
609:            * Function:        BOOL USER_USB_CALLBACK_EVENT_HANDLER(
610:            *                        int event, void *pdata, WORD size)
611:            *
612:            * PreCondition:    None
613:            *
614:            * Input:           int event - the type of event
615:            *                  void *pdata - pointer to the event data
616:            *                  WORD size - size of the event data
617:            *
618:            * Output:          None
619:            *
620:            * Side Effects:    None
621:            *
622:            * Overview:        This function is called from the USB stack to
623:            *                  notify a user application that a USB event
624:            *                  occured.  This callback is in interrupt context
625:            *                  when the USB_INTERRUPT option is selected.
626:            *
627:            * Note:            None
628:            *******************************************************************/
629:           BOOL USER_USB_CALLBACK_EVENT_HANDLER(int event, void *pdata, WORD size)
630:           {
631:               switch( event )
01E4  0861     MOVF 0x61, W
01F3  0860     MOVF count, W
01F4  3A01     XORLW 0x1
01F5  1903     BTFSC STATUS, 0x2
01F6  29EF     GOTO 0x1EF
01F7  3A03     XORLW 0x3
01F8  1903     BTFSC STATUS, 0x2
01F9  29F0     GOTO 0x1F0
01FA  3A01     XORLW 0x1
01FB  1903     BTFSC STATUS, 0x2
01FC  29F1     GOTO 0x1F1
01FD  3A06     XORLW 0x6
01FE  1903     BTFSC STATUS, 0x2
01FF  2A12     GOTO 0x212
0200  3A77     XORLW 0x77
0201  1903     BTFSC STATUS, 0x2
0202  2A12     GOTO 0x212
0203  3A01     XORLW 0x1
0204  1903     BTFSC STATUS, 0x2
0205  29EC     GOTO 0x1EC
0206  3A07     XORLW 0x7
0207  1903     BTFSC STATUS, 0x2
0208  29EE     GOTO 0x1EE
0209  3A01     XORLW 0x1
020A  1903     BTFSC STATUS, 0x2
020B  29ED     GOTO 0x1ED
020C  2A12     GOTO 0x212
020D  0860     MOVF count, W
020E  3AFF     XORLW 0xFF
020F  1903     BTFSC STATUS, 0x2
0210  29F2     GOTO 0x1F2
0211  2A12     GOTO 0x212
632:               {
633:                   case EVENT_TRANSFER:
634:                       //Add application specific callback task or callback function here if desired.
635:                       break;
636:                   case EVENT_SOF:
637:                       USBCB_SOF_Handler();
01EC  2B92     GOTO 0x392
638:                       break;
639:                   case EVENT_SUSPEND:
640:                       USBCBSuspend();
01ED  2B94     GOTO 0x394
641:                       break;
642:                   case EVENT_RESUME:
643:                       USBCBWakeFromSuspend();
01EE  2B93     GOTO 0x393
644:                       break;
645:                   case EVENT_CONFIGURED: 
646:                       USBCBInitEP();
01EF  2B39     GOTO 0x339
647:                       break;
648:                   case EVENT_SET_DESCRIPTOR:
649:                       USBCBStdSetDscHandler();
01F0  2B8E     GOTO 0x38E
650:                       break;
651:                   case EVENT_EP0_REQUEST:
652:                       USBCBCheckOtherReq();
01F1  2B90     GOTO 0x390
653:                       break;
654:                   case EVENT_BUS_ERROR:
655:                       USBCBErrorHandler();
01F2  2B91     GOTO 0x391
656:                       break;
657:                   case EVENT_TRANSFER_TERMINATED:
658:                       //Add application specific callback task or callback function here if desired.
659:                       //The EVENT_TRANSFER_TERMINATED event occurs when the host performs a CLEAR
660:                       //FEATURE (endpoint halt) request on an application endpoint which was 
661:                       //previously armed (UOWN was = 1).  Here would be a good place to:
662:                       //1.  Determine which endpoint the transaction that just got terminated was 
663:                       //      on, by checking the handle value in the *pdata.
664:                       //2.  Re-arm the endpoint if desired (typically would be the case for OUT 
665:                       //      endpoints).
666:                       break;
667:                   default:
668:                       break;
669:               }      
670:               return TRUE; 
671:           }
0212  0008     RETURN
672:           /** EOF main.c ***************************************************************/
673:           
---  /home/chris/Dev/klondike/firmware/Klondike.X/klondike.c  -------------------------------------------
1:             /********
2:              * Klondike ASIC Miner - klondike.c - cmd processing and host protocol support 
3:              * 
4:              * (C) Copyright 2013 Chris Savery. 
5:              *
6:              * This program is free software: you can redistribute it and/or modify
7:              * it under the terms of the GNU General Public License as published by
8:              * the Free Software Foundation, either version 3 of the License, or
9:              * (at your option) any later version.
10:             *
11:             * This program is distributed in the hope that it will be useful,
12:             * but WITHOUT ANY WARRANTY; without even the implied warranty of
13:             * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
14:             * GNU General Public License for more details.
15:             *
16:             * You should have received a copy of the GNU General Public License
17:             * along with this program.  If not, see <http://www.gnu.org/licenses/>.
18:             *
19:             */
20:            #include "GenericTypeDefs.h"
21:            #include "Compiler.h"
22:            #include <xc.h>
23:            #include "klondike.h"
24:            
25:            const IDENTITY ID = { 0x10, "K16", 0xDEADBEEF };
26:            
27:            DWORD BankRanges[8] = { 0, 0x40000000, 0x2aaaaaaa, 0x20000000, 0x19999999, 0x15555555, 0x12492492, 0x10000000 };
28:            BYTE WorkNow, BankSize, ResultQC, SlowTick;
29:            BYTE SlaveAddress = MASTER_ADDRESS;
30:            BYTE HashTime = 256 - ((WORD)TICK_TOTAL/DEFAULT_HASHCLOCK);
31:            volatile WORKSTATUS Status = {'I',0,0,0,0,0,0,0,0, WORK_TICKS, 0 };
32:            WORKCFG Cfg = { DEFAULT_HASHCLOCK, DEFAULT_TEMP_TARGET, DEFAULT_TEMP_CRITICAL, DEFAULT_FAN_TARGET, 0 };
33:            WORKTASK WorkQue[MAX_WORK_COUNT];
34:            volatile BYTE ResultQue[MAX_RESULT_COUNT*4];
35:            DWORD ClockCfg[2] = { (((DWORD)DEFAULT_HASHCLOCK) << 18) | CLOCK_LOW_CHG, CLOCK_HIGH_CFG };
36:            
37:            DWORD NonceRanges[8];
38:            
39:            extern I2CSTATE I2CState;
40:            extern DWORD PrecalcHashes[6];
41:            
42:            void ProcessCmd(char *cmd)
43:            {
0873  00E5     MOVWF p
44:                // cmd is one char, dest address 1 byte, data follows
45:                // we already know address is ours here
46:                switch(cmd[0]) {
0874  298A     GOTO 0x18A
098A  0865     MOVF p, W
098B  0086     MOVWF FSR1L
098C  3002     MOVLW 0x2
098D  0087     MOVWF FSR1H
098E  0801     MOVF INDF1, W
098F  3A41     XORLW 0x41
0990  1903     BTFSC STATUS, 0x2
0991  28CF     GOTO 0xCF
0992  3A02     XORLW 0x2
0993  1903     BTFSC STATUS, 0x2
0994  28DF     GOTO 0xDF
0995  3A07     XORLW 0x7
0996  1903     BTFSC STATUS, 0x2
0997  297F     GOTO 0x17F
0998  3A01     XORLW 0x1
0999  1903     BTFSC STATUS, 0x2
099A  295E     GOTO 0x15E
099B  3A0C     XORLW 0xC
099C  1903     BTFSC STATUS, 0x2
099D  28D4     GOTO 0xD4
099E  3A1A     XORLW 0x1A
099F  1903     BTFSC STATUS, 0x2
09A0  28C3     GOTO 0xC3
09A1  3A04     XORLW 0x4
09A2  1903     BTFSC STATUS, 0x2
09A3  2875     GOTO 0x75
09A4  29A5     GOTO 0x1A5
47:                    case 'W': // queue new work
48:                        if( Status.WorkQC < MAX_WORK_COUNT-1 ) {
0875  3003     MOVLW 0x3
0876  0022     MOVLB 0x2
0877  0252     SUBWF 0x52, W
0878  1803     BTFSC STATUS, 0x0
0879  28C3     GOTO 0xC3
49:                            WorkQue[ (WorkNow + Status.WorkQC++) & WORKMASK ] = *(WORKTASK *)(cmd+2);
087A  0021     MOVLB 0x1
087B  26EA     CALL 0x6EA
087C  3188     MOVLP 0x8
087D  086B     MOVF 0x6B, W
087E  0020     MOVLB 0x0
087F  00D6     MOVWF direction
0880  01D7     CLRF product
0881  0022     MOVLB 0x2
0882  0852     MOVF 0x52, W
0883  0020     MOVLB 0x0
0884  07D6     ADDWF direction, F
0885  1803     BTFSC STATUS, 0x0
0886  0AD7     INCF product, F
0887  3003     MOVLW 0x3
0888  05D6     ANDWF direction, F
0889  302D     MOVLW 0x2D
088A  01D7     CLRF product
088B  00D8     MOVWF p
088C  01D9     CLRF x
088D  2212     CALL 0x212
088E  3188     MOVLP 0x8
088F  303C     MOVLW 0x3C
0890  0021     MOVLB 0x1
0891  00E1     MOVWF 0x61
0892  3023     MOVLW 0x23
0893  00E2     MOVWF 0x62
0894  0020     MOVLB 0x0
0895  0856     MOVF direction, W
0896  0021     MOVLB 0x1
0897  0761     ADDWF 0x61, W
0898  0084     MOVWF FSR0L
0899  0020     MOVLB 0x0
089A  0857     MOVF product, W
089B  0021     MOVLB 0x1
089C  3D62     ADDWFC 0x62, W
089D  0085     MOVWF FSR0H
089E  302D     MOVLW 0x2D
089F  00FF     MOVWF 0x7F
08A0  0016     MOVIW FSR1++
08A1  001A     MOVWI FSR0++
08A2  0BFF     DECFSZ 0x7F, F
08A3  28A0     GOTO 0xA0
08A4  0022     MOVLB 0x2
08A5  0AD2     INCF 0x52, F
50:                            if(Status.State == 'R') {
08A6  084F     MOVF 0x4F, W
08A7  3A52     XORLW 0x52
08A8  1D03     BTFSS STATUS, 0x2
08A9  28C3     GOTO 0xC3
51:                                AsicPreCalc(&WorkQue[WorkNow]);
08AA  303C     MOVLW 0x3C
08AB  26B6     CALL 0x6B6
08AC  3188     MOVLP 0x8
08AD  268E     CALL 0x68E
08AE  3188     MOVLP 0x8
08AF  2212     CALL 0x212
08B0  3188     MOVLP 0x8
08B1  0856     MOVF direction, W
08B2  0021     MOVLB 0x1
08B3  00E1     MOVWF 0x61
08B4  0020     MOVLB 0x0
08B5  0857     MOVF product, W
08B6  0021     MOVLB 0x1
08B7  00E2     MOVWF 0x62
08B8  0861     MOVF 0x61, W
08B9  0020     MOVLB 0x0
08BA  07E6     ADDWF work, F
08BB  0021     MOVLB 0x1
08BC  0862     MOVF 0x62, W
08BD  0020     MOVLB 0x0
08BE  3DE7     ADDWFC n, F
08BF  237E     CALL 0x37E
08C0  3188     MOVLP 0x8
52:                                AsicPushWork();
08C1  224C     CALL 0x24C
08C2  3188     MOVLP 0x8
53:                            }
54:                        }
55:                        SendCmdReply(cmd, (char *)&Status, sizeof(Status));
08C3  0021     MOVLB 0x1
08C4  26D4     CALL 0x6D4
08C5  3188     MOVLP 0x8
08C6  304F     MOVLW 0x4F
08C7  00DE     MOVWF data
08C8  3001     MOVLW 0x1
08C9  00DF     MOVWF handle
08CA  300D     MOVLW 0xD
08CB  00E0     MOVWF count
08CC  21A8     CALL 0x1A8
08CD  3188     MOVLP 0x8
56:                        break;
08CE  29A5     GOTO 0x1A5
57:                    case 'A': // abort work, reply status has hash completed count
58:                        Status.WorkQC = WorkNow = 0;
08CF  01EB     CLRF 0x6B
08D0  0022     MOVLB 0x2
08D1  01D2     CLRF 0x52
59:                        Status.State = 'R';
08D2  3052     MOVLW 0x52
08D3  297D     GOTO 0x17D
08D4  26D4     CALL 0x6D4
08D5  3188     MOVLP 0x8
60:                        SendCmdReply(cmd, (char *)&Status, sizeof(Status));
61:                        break;
62:                    case 'I': // return identity 
63:                        SendCmdReply(cmd, (char *)&ID, sizeof(ID));
08D6  309F     MOVLW 0x9F
08D7  00DE     MOVWF data
08D8  3086     MOVLW 0x86
08D9  00DF     MOVWF handle
08DA  300C     MOVLW 0xC
08DB  00E0     MOVWF count
08DC  21A8     CALL 0x1A8
08DD  3188     MOVLP 0x8
64:                        break;
08DE  29A5     GOTO 0x1A5
08DF  26EA     CALL 0x6EA
08E0  3188     MOVLP 0x8
65:                    case 'S': // return status 
66:                        SendCmdReply(cmd, (char *)&Status, sizeof(Status)); 
67:                        break;
68:                    case 'C': // set config values 
69:                        if( *(WORD *)&cmd[2] != 0 ) {
08E1  0016     MOVIW FSR1++
08E2  0401     IORWF INDF1, W
08E3  1903     BTFSC STATUS, 0x2
08E4  2952     GOTO 0x152
70:                            Cfg = *(WORKCFG *)(cmd+2);
08E5  0865     MOVF p, W
08E6  3E02     ADDLW 0x2
08E7  0086     MOVWF FSR1L
08E8  3002     MOVLW 0x2
08E9  0087     MOVWF FSR1H
08EA  3064     MOVLW 0x64
08EB  0084     MOVWF FSR0L
08EC  3001     MOVLW 0x1
08ED  0085     MOVWF FSR0H
08EE  3006     MOVLW 0x6
08EF  00FF     MOVWF 0x7F
08F0  0016     MOVIW FSR1++
08F1  001A     MOVWI FSR0++
08F2  0BFF     DECFSZ 0x7F, F
08F3  28F0     GOTO 0xF0
71:                            if(Cfg.HashClock < MIN_HASH_CLOCK)
08F4  3000     MOVLW 0x0
08F5  0022     MOVLB 0x2
08F6  0265     SUBWF p, W
08F7  3080     MOVLW 0x80
08F8  1903     BTFSC STATUS, 0x2
08F9  0264     SUBWF 0x64, W
08FA  1803     BTFSC STATUS, 0x0
08FB  28FF     GOTO 0xFF
72:                                Cfg.HashClock = MIN_HASH_CLOCK;
08FC  3080     MOVLW 0x80
08FD  00E4     MOVWF 0x64
08FE  01E5     CLRF p
73:                            if(Cfg.HashClock <= HALF_HASH_CLOCK && Cfg.HashClock >= MAX_HASH_CLOCK/2)
08FF  3000     MOVLW 0x0
0900  0265     SUBWF p, W
0901  30FB     MOVLW 0xFB
0902  1903     BTFSC STATUS, 0x2
0903  0264     SUBWF 0x64, W
0904  1803     BTFSC STATUS, 0x0
0905  2910     GOTO 0x110
0906  3000     MOVLW 0x0
0907  0265     SUBWF p, W
0908  30E1     MOVLW 0xE1
0909  1903     BTFSC STATUS, 0x2
090A  0264     SUBWF 0x64, W
090B  1C03     BTFSS STATUS, 0x0
090C  2910     GOTO 0x110
74:                                Cfg.HashClock = MAX_HASH_CLOCK/2-1;
090D  30E0     MOVLW 0xE0
090E  00E4     MOVWF 0x64
090F  01E5     CLRF p
75:                            if(Cfg.HashClock >= MAX_HASH_CLOCK)
0910  3001     MOVLW 0x1
0911  0265     SUBWF p, W
0912  30C2     MOVLW 0xC2
0913  1903     BTFSC STATUS, 0x2
0914  0264     SUBWF 0x64, W
0915  1C03     BTFSS STATUS, 0x0
0916  291B     GOTO 0x11B
76:                                Cfg.HashClock = MAX_HASH_CLOCK-1;
0917  30C1     MOVLW 0xC1
0918  00E4     MOVWF 0x64
0919  3001     MOVLW 0x1
091A  00E5     MOVWF p
77:                            if(Cfg.HashClock <= HALF_HASH_CLOCK)
091B  3000     MOVLW 0x0
091C  0265     SUBWF p, W
091D  30FB     MOVLW 0xFB
091E  1903     BTFSC STATUS, 0x2
091F  0264     SUBWF 0x64, W
0926  1803     BTFSC STATUS, 0x0
0927  292F     GOTO 0x12F
78:                                ClockCfg[0] = (((DWORD)Cfg.HashClock*2) << 18) | CLOCK_HALF_CHG;
0920  0864     MOVF 0x64, W
0921  00DC     MOVWF work
0922  0865     MOVF p, W
0923  00DD     MOVWF y
0924  01DE     CLRF data
0925  01DF     CLRF handle
0928  3013     MOVLW 0x13
0929  2702     CALL 0x702
092A  3188     MOVLP 0x8
092B  0B89     DECFSZ WREG, F
092C  2929     GOTO 0x129
092D  3017     MOVLW 0x17
092E  2935     GOTO 0x135
79:                            else
80:                                ClockCfg[0] = ((DWORD)Cfg.HashClock << 18) | CLOCK_LOW_CHG;
092F  3012     MOVLW 0x12
0930  2702     CALL 0x702
0931  3188     MOVLP 0x8
0932  0B89     DECFSZ WREG, F
0933  2930     GOTO 0x130
0934  3007     MOVLW 0x7
0935  04DC     IORWF work, F
0936  3000     MOVLW 0x0
0937  04DD     IORWF y, F
0938  3003     MOVLW 0x3
0939  04DE     IORWF data, F
093A  3000     MOVLW 0x0
093B  04DF     IORWF handle, F
81:                            HashTime = 256 - ((WORD)TICK_TOTAL/Cfg.HashClock);
093C  0865     MOVF p, W
093D  0020     MOVLB 0x0
093E  00D7     MOVWF product
093F  0022     MOVLB 0x2
0940  0864     MOVF 0x64, W
0941  0020     MOVLB 0x0
0942  00D6     MOVWF direction
0943  30E0     MOVLW 0xE0
0944  00D8     MOVWF p
0945  302E     MOVLW 0x2E
0946  00D9     MOVWF x
0947  2227     CALL 0x227
0948  3188     MOVLP 0x8
0949  0856     MOVF direction, W
094A  3C00     SUBLW 0x0
094B  0022     MOVLB 0x2
094C  00CE     MOVWF 0x4E
82:                            PWM1DCH = Cfg.FanTarget;
094D  0868     MOVF i, W
094E  002C     MOVLB 0xC
094F  0092     MOVWF PIR2
83:                            Status.ErrorCount = 0;
0950  0022     MOVLB 0x2
0951  01D6     CLRF direction
84:                        }
85:                        SendCmdReply(cmd, (char *)&Cfg, sizeof(Cfg));
0952  0021     MOVLB 0x1
0953  26D4     CALL 0x6D4
0954  3188     MOVLP 0x8
0955  3064     MOVLW 0x64
0956  00DE     MOVWF data
0957  3001     MOVLW 0x1
0958  00DF     MOVWF handle
0959  3006     MOVLW 0x6
095A  00E0     MOVWF count
095B  21A8     CALL 0x1A8
095C  3188     MOVLP 0x8
86:                        break;
095D  29A5     GOTO 0x1A5
095E  26EA     CALL 0x6EA
095F  3188     MOVLP 0x8
87:                    case 'E': // enable/disable work
88:                        HASH_CLK_EN = (cmd[2] == '1');
0960  0801     MOVF INDF1, W
0961  3A31     XORLW 0x31
0962  3000     MOVLW 0x0
0963  1903     BTFSC STATUS, 0x2
0964  3001     MOVLW 0x1
0965  00E1     MOVWF 0x61
0966  0EE1     SWAPF 0x61, F
0967  0022     MOVLB 0x2
0968  080C     MOVF PORTA, W
0969  0021     MOVLB 0x1
096A  0661     XORWF 0x61, W
096B  39EF     ANDLW 0xEF
096C  0661     XORWF 0x61, W
096D  0022     MOVLB 0x2
096E  008C     MOVWF PORTA
89:                        Status.State = (cmd[2] == '1') ? 'R' : 'D';
096F  0021     MOVLB 0x1
0970  0865     MOVF p, W
0971  3E02     ADDLW 0x2
0972  0086     MOVWF FSR1L
0973  0801     MOVF INDF1, W
0974  3A31     XORLW 0x31
0975  1903     BTFSC STATUS, 0x2
0976  2979     GOTO 0x179
0977  3044     MOVLW 0x44
0978  297A     GOTO 0x17A
0979  3052     MOVLW 0x52
097A  00E3     MOVWF 0x63
097B  01E4     CLRF 0x64
097C  0022     MOVLB 0x2
097D  00CF     MOVWF 0x4F
097E  28C3     GOTO 0xC3
097F  26D4     CALL 0x6D4
0980  3188     MOVLP 0x8
90:                        SendCmdReply(cmd, (char *)&Status, sizeof(Status));
91:                        break;
92:                    case 'D':
93:                        SendCmdReply(cmd, (char *)&ResultQC, sizeof(ResultQC));
0981  304D     MOVLW 0x4D
0982  00DE     MOVWF data
0983  3001     MOVLW 0x1
0984  00DF     MOVWF handle
0985  01E0     CLRF count
0986  0AE0     INCF count, F
0987  21A8     CALL 0x1A8
0988  3188     MOVLP 0x8
0989  29A5     GOTO 0x1A5
94:                    default:
95:                        break;
96:                    }
97:                LED_On();
09A5  0022     MOVLB 0x2
09A6  168C     BSF PORTA, 0x5
98:            }
09A7  0008     RETURN
99:            
100:           void AsicPushWork(void)
101:           {
102:               Status.WorkID = WorkQue[WorkNow].WorkID;
0A4E  2212     CALL 0x212
0A4F  3188     MOVLP 0x8
0A50  303C     MOVLW 0x3C
0A51  00E8     MOVWF i
0A52  3023     MOVLW 0x23
0A53  00E9     MOVWF setup_cnt
0A54  0856     MOVF direction, W
0A55  0768     ADDWF i, W
0A56  0086     MOVWF FSR1L
0A57  0857     MOVF product, W
0A58  3D69     ADDWFC setup_cnt, W
0A59  0087     MOVWF FSR1H
0A5A  0801     MOVF INDF1, W
0A5B  0022     MOVLB 0x2
0A5C  00D3     MOVWF 0x53
103:               SendAsicData(&WorkQue[WorkNow], DATA_SPLIT);
0A5D  303C     MOVLW 0x3C
0A5E  0020     MOVLB 0x0
0A5F  00DC     MOVWF work
0A60  3023     MOVLW 0x23
0A61  00DD     MOVWF y
0A62  268E     CALL 0x68E
0A63  3188     MOVLP 0x8
0A64  2212     CALL 0x212
0A65  3188     MOVLP 0x8
0A66  26FC     CALL 0x6FC
0A67  3188     MOVLP 0x8
0A68  07DC     ADDWF work, F
0A69  0869     MOVF setup_cnt, W
0A6A  3DDD     ADDWFC y, F
0A6B  3050     MOVLW 0x50
0A6C  00DE     MOVWF data
0A6D  228C     CALL 0x28C
0A6E  3188     MOVLP 0x8
104:               WorkNow = (WorkNow+1) & WORKMASK;
0A6F  0021     MOVLB 0x1
0A70  3003     MOVLW 0x3
0A71  0AEB     INCF 0x6B, F
0A72  05EB     ANDWF 0x6B, F
105:               Status.HashCount = 0;
0A73  0022     MOVLB 0x2
0A74  01D7     CLRF product
0A75  01D8     CLRF p
106:               TMR0 = HashTime;
0A76  084E     MOVF 0x4E, W
0A77  0020     MOVLB 0x0
0A78  0095     MOVWF TMR0
107:               Status.State ='W';
0A79  3057     MOVLW 0x57
0A7A  0022     MOVLB 0x2
0A7B  00CF     MOVWF 0x4F
108:               if(--Status.WorkQC > 0)
0A7C  03D2     DECF 0x52, F
0A7D  1903     BTFSC STATUS, 0x2
0A7E  0008     RETURN
109:                   AsicPreCalc(&WorkQue[WorkNow]);
0A7F  303C     MOVLW 0x3C
0A80  26B6     CALL 0x6B6
0A81  3188     MOVLP 0x8
0A82  268E     CALL 0x68E
0A83  3188     MOVLP 0x8
0A84  2212     CALL 0x212
0A85  3188     MOVLP 0x8
0A86  26FC     CALL 0x6FC
0A87  3188     MOVLP 0x8
0A88  07E6     ADDWF work, F
0A89  0869     MOVF setup_cnt, W
0A8A  3DE7     ADDWFC n, F
0A8B  2B7E     GOTO 0x37E
110:           }
0A8C  138B     BCF INTCON, 0x7
111:           
112:           // Housekeeping functons
113:           
114:           void CheckFanSpeed(void)
115:           {
116:               if(PWM1OE == 0) { // failed read attempt, abort
117:                   FAN_PWM = 0;
118:                   PWM1OE = 1;
119:                   Status.FanSpeed = 0;
120:               }
121:               else if( IOCAF3 == 1) { // only check if NegEdge else no Tach present
122:                   IOCAF3 = 0; // reset Tach detection
123:                   FAN_PWM = 1; // force PWM fan output to ON
124:                   PWM1OE=0;
125:                   T1CONbits.TMR1CS = 0;
126:                   T1CONbits.T1CKPS = 3;
127:                   T1CONbits.TMR1ON = TMR1GE = 1;
128:                   T1GCONbits.T1GPOL = 1;
129:                   T1GCONbits.T1GSS = T1GCONbits.T1GTM = 0;
130:                   T1GSPM = 1;
131:                   TMR1H = TMR1L = 0;
132:                   TMR1ON = 1;
133:                   TMR1GIE = TMR1IE = 1;
134:                   T1GCONbits.T1GGO_nDONE = 1;
135:               }
136:           }
137:           
138:           void DetectAsics(void)
139:           {
140:           /* disabled for now, not fully worked out yet
141:              const WORKTASK TestWork = { 0xFF, GOOD_MIDSTATE, GOOD_DATA };
142:               const DWORD GoodNonce = GOOD_NONCE;
143:               const DWORD StartNonce = (GOOD_NONCE - DETECT_DELAY_COUNT);
144:               BankSize = 8;
145:               Status.ChipCount = 0;
146:               for(BYTE x = 0; x < BankSize; x++)
147:                   NonceRanges[x] = StartNonce;
148:               WorkQue[0] = TestWork;
149:               AsicPreCalc(&WorkQue[0]);
150:               
151:               //SendAsicData(&WorkQue[0], (StartNonce & 0x80000000) ? DATA_ONE : DATA_ZERO);
152:               // wait for "push work time" for results to return and be counted*/
153:               
154:               Status.ChipCount = 4; // just for testing
0F5C  3004     MOVLW 0x4
0F5D  0022     MOVLB 0x2
0F5E  00D0     MOVWF 0x50
155:               
156:               // pre-calc nonce range values
157:               BankSize = Status.ChipCount; //(Status.ChipCount+1)/2;
0F5F  0850     MOVF 0x50, W
0F60  00EA     MOVWF pBDTEntryIn
158:               Status.MaxCount = WORK_TICKS / BankSize;
0F61  0020     MOVLB 0x0
0F62  00D6     MOVWF direction
0F63  3040     MOVLW 0x40
0F64  01D7     CLRF product
0F65  01D8     CLRF p
0F66  00D9     MOVWF x
0F67  27C0     CALL 0x7C0
0F68  3188     MOVLP 0x8
0F69  0857     MOVF product, W
0F6A  0022     MOVLB 0x2
0F6B  00DA     MOVWF i_718
0F6C  0020     MOVLB 0x0
0F6D  0856     MOVF direction, W
0F6E  0022     MOVLB 0x2
0F6F  00D9     MOVWF x
159:               NonceRanges[0] = 0;
0F70  0023     MOVLB 0x3
0F71  01A0     CLRF BDT
0F72  01A1     CLRF 0x21
0F73  01A2     CLRF 0x22
0F74  01A3     CLRF 0x23
160:               for(BYTE x = 1; x < BankSize; x++)
0F75  0020     MOVLB 0x0
0F76  01E6     CLRF work
0F77  0AE6     INCF work, F
0F78  0022     MOVLB 0x2
0F79  086A     MOVF pBDTEntryIn, W
0F7A  0020     MOVLB 0x0
0F7B  0266     SUBWF work, W
0F7C  1803     BTFSC STATUS, 0x0
0F7D  2FBA     GOTO 0x7BA
0FB9  2F77     GOTO 0x777
161:                   NonceRanges[x] = NonceRanges[x-1] + 2*BankRanges[BankSize-1];  // single bank, double range size
0F7E  0866     MOVF work, W
0F7F  0709     ADDWF WREG, W
0F80  0709     ADDWF WREG, W
0F81  3E9C     ADDLW 0x9C
0F82  0086     MOVWF FSR1L
0F83  3001     MOVLW 0x1
0F84  0087     MOVWF FSR1H
0F85  3F40     MOVIW [0]FSR1
0F86  00DE     MOVWF data
0F87  3F41     MOVIW [1]FSR1
0F88  00DF     MOVWF handle
0F89  3F42     MOVIW [2]FSR1
0F8A  00E0     MOVWF count
0F8B  3F43     MOVIW [3]FSR1
0F8C  00E1     MOVWF 0x61
0F8D  0022     MOVLB 0x2
0F8E  086A     MOVF pBDTEntryIn, W
0F8F  0709     ADDWF WREG, W
0F90  0709     ADDWF WREG, W
0F91  3E1C     ADDLW 0x1C
0F92  0086     MOVWF FSR1L
0F93  3003     MOVLW 0x3
0F94  0087     MOVWF FSR1H
0F95  3F40     MOVIW [0]FSR1
0F96  0020     MOVLB 0x0
0F97  00E2     MOVWF 0x62
0F98  3F41     MOVIW [1]FSR1
0F99  00E3     MOVWF 0x63
0F9A  3F42     MOVIW [2]FSR1
0F9B  00E4     MOVWF 0x64
0F9C  3F43     MOVIW [3]FSR1
0F9D  00E5     MOVWF p
0F9E  35E2     LSLF 0x62, F
0F9F  0DE3     RLF 0x63, F
0FA0  0DE4     RLF 0x64, F
0FA1  0DE5     RLF p, F
0FA2  0862     MOVF 0x62, W
0FA3  07DE     ADDWF data, F
0FA4  0863     MOVF 0x63, W
0FA5  3DDF     ADDWFC handle, F
0FA6  0864     MOVF 0x64, W
0FA7  3DE0     ADDWFC count, F
0FA8  0865     MOVF p, W
0FA9  3DE1     ADDWFC 0x61, F
0FAA  0866     MOVF work, W
0FAB  0709     ADDWF WREG, W
0FAC  0709     ADDWF WREG, W
0FAD  3EA0     ADDLW 0xA0
0FAE  0086     MOVWF FSR1L
0FAF  3001     MOVLW 0x1
0FB0  0087     MOVWF FSR1H
0FB1  085E     MOVF data, W
0FB2  3FC0     MOVWI [0]FSR1
0FB3  085F     MOVF handle, W
0FB4  3FC1     MOVWI [1]FSR1
0FB5  0860     MOVF count, W
0FB6  3FC2     MOVWI [2]FSR1
0FB7  0861     MOVF 0x61, W
0FB8  3FC3     MOVWI [3]FSR1
162:               Status.State ='R';
0FBA  3052     MOVLW 0x52
0FBB  0022     MOVLB 0x2
0FBC  00CF     MOVWF 0x4F
163:               Status.HashCount = 0;
0FBD  01D7     CLRF product
0FBE  01D8     CLRF p
164:           }
0FBF  0008     RETURN
165:           
166:           // ISR functions
167:           
168:           void WorkTick(void)
169:           {
170:               TMR0 += HashTime;
0F18  0022     MOVLB 0x2
0F19  084E     MOVF 0x4E, W
0F1A  0020     MOVLB 0x0
0F1B  0795     ADDWF TMR0, F
171:               TMR0IF = 0;
0F1C  110B     BCF INTCON, 0x2
172:               //RCREG = 0xFF;
173:               if(RCSTAbits.SPEN == 0) {
0F1D  0023     MOVLB 0x3
0F1E  1B9D     BTFSC 0x1D, 0x7
0F1F  2F23     GOTO 0x723
174:                   RCSTAbits.SPEN = 1; // renable Rx
0F20  179D     BSF 0x1D, 0x7
175:                   ResultQC = 0;       // resync Rx
0F21  0022     MOVLB 0x2
0F22  01CD     CLRF 0x4D
176:               }
177:               if((Status.State == 'W') && (++Status.HashCount == Status.MaxCount)) {
0F23  0022     MOVLB 0x2
0F24  084F     MOVF 0x4F, W
0F25  3A57     XORLW 0x57
0F26  1D03     BTFSS STATUS, 0x2
0F27  2F41     GOTO 0x741
0F28  3057     MOVLW 0x57
0F29  0086     MOVWF FSR1L
0F2A  3001     MOVLW 0x1
0F2B  0087     MOVWF FSR1H
0F2C  0781     ADDWF INDF1, F
0F2D  3141     ADDFSR 1, 1
0F2E  1803     BTFSC STATUS, 0x0
0F2F  0A81     INCF INDF1, F
0F30  317F     ADDFSR 1, -1
0F31  3F40     MOVIW [0]FSR1
0F32  0659     XORWF x, W
0F33  1D03     BTFSS STATUS, 0x2
0F34  2F37     GOTO 0x737
0F35  3F41     MOVIW [1]FSR1
0F36  065A     XORWF i_718, W
0F37  1D03     BTFSS STATUS, 0x2
0F38  2F41     GOTO 0x741
178:                   if(Status.WorkQC > 0) {
0F39  0852     MOVF 0x52, W
0F3A  1903     BTFSC STATUS, 0x2
0F3B  2F3F     GOTO 0x73F
179:                       Status.State = 'P'; // set state to push data and do asap
0F3C  3050     MOVLW 0x50
0F3D  00CF     MOVWF 0x4F
0F3E  0008     RETURN
180:                       return;
181:                   }
182:                   else
183:                       Status.State = 'R';
0F3F  3052     MOVLW 0x52
0F40  00CF     MOVWF 0x4F
184:               }
185:           
186:              if(++SlowTick == 0) {
0F41  0FB1     INCFSZ 0x31, F
0F42  0008     RETURN
187:                   LED_Off();
0F43  128C     BCF PORTA, 0x5
188:                   Status.Temp = ADRESH;
0F44  0021     MOVLB 0x1
0F45  081C     MOVF T2CON, W
0F46  0022     MOVLB 0x2
0F47  00D4     MOVWF 0x54
189:                   // todo: adjust fan speed for target temperature
190:                   ADCON0bits.GO_nDONE = 1;
0F48  0021     MOVLB 0x1
0F49  149D     BSF 0x1D, 0x1
191:                   //CheckFanSpeed();
192:               }
193:              //if((SlowTick & 3) == 0)
194:              //I2CPoll();
195:           }
0F4A  0008     RETURN
196:           
197:           void ResultRx(void)
198:           {
199:               //ResultQue[2+ResultQC++] = ~RCREG;
200:               BYTE TimeOut = 0;
0514  01FC     CLRF TimeOut
201:               ResultQC = 0;
0515  0022     MOVLB 0x2
0516  01CD     CLRF 0x4D
202:               while(ResultQC < 4) {
0517  3004     MOVLW 0x4
0518  0022     MOVLB 0x2
0519  024D     SUBWF 0x4D, W
051A  1803     BTFSC STATUS, 0x0
051B  2D3E     GOTO 0x53E
203:           
204:                   if(RCIF) {
051C  0020     MOVLB 0x0
051D  1E91     BTFSS PIR1, 0x5
051E  2D2B     GOTO 0x52B
205:                       ResultQue[2+ResultQC++] = ~RCREG;
051F  0022     MOVLB 0x2
0520  084D     MOVF 0x4D, W
0521  3E42     ADDLW 0x42
0522  0086     MOVWF FSR1L
0523  3001     MOVLW 0x1
0524  0087     MOVWF FSR1H
0525  0023     MOVLB 0x3
0526  0919     COMF T1GCON, W
0527  0081     MOVWF INDF1
0528  0022     MOVLB 0x2
0529  0ACD     INCF 0x4D, F
206:                       TimeOut = 0;
052A  01FC     CLRF TimeOut
207:                   }
208:                   if(TimeOut++ > 32 ) {
052B  3022     MOVLW 0x22
052C  0AFC     INCF TimeOut, F
052D  027C     SUBWF TimeOut, W
052E  1C03     BTFSS STATUS, 0x0
052F  2D33     GOTO 0x533
209:                       Status.Noise++;
0530  0022     MOVLB 0x2
0531  0ADB     INCF i, F
210:                       goto outrx;
0532  2D51     GOTO 0x551
211:                   }
212:           
213:                   if(RCSTAbits.OERR) { // error occured, either overun or no more bits
0533  0023     MOVLB 0x3
0534  1C9D     BTFSS 0x1D, 0x1
0535  2D17     GOTO 0x517
214:                       if(Status.State == 'W')
0536  0022     MOVLB 0x2
0537  084F     MOVF 0x4F, W
0538  3A57     XORLW 0x57
0539  1903     BTFSC STATUS, 0x2
215:                           Status.ErrorCount++;
053A  0AD6     INCF direction, F
216:                       RCSTAbits.SPEN = 0; // clear error, don't re-enable until next tick TMR0, 21.3uS
053B  0023     MOVLB 0x3
053C  139D     BCF 0x1D, 0x7
217:                       goto outrx;
053D  2D51     GOTO 0x551
218:                   }
219:               }
220:               
221:               if(Status.State == 'W') {
053E  084F     MOVF 0x4F, W
053F  3A57     XORLW 0x57
0540  1D03     BTFSS STATUS, 0x2
0541  2D51     GOTO 0x551
222:                   ResultQue[0] = '=';
0542  303D     MOVLW 0x3D
0543  00C0     MOVWF SetupPkt
223:                   ResultQue[1] = Status.WorkID;
0544  0853     MOVF 0x53, W
0545  00C1     MOVWF 0x41
224:                   SendCmdReply(&ResultQue, &ResultQue+1, sizeof(ResultQue)-1);
0546  3040     MOVLW 0x40
0547  00F6     MOVWF cmd
0548  3001     MOVLW 0x1
0549  00F7     MOVWF 0x77
054A  3041     MOVLW 0x41
054B  00F8     MOVWF data
054C  3001     MOVLW 0x1
054D  00F9     MOVWF 0x79
054E  3007     MOVLW 0x7
054F  00FA     MOVWF count
0550  2557     CALL 0x557
225:               }
226:           outrx:
227:               RCREG = 0xFF; //RCSTAbits.SPEN = 0; RCSTAbits.SPEN = 1;
0551  30FF     MOVLW 0xFF
0552  0023     MOVLB 0x3
0553  0099     MOVWF T1GCON
228:               IOCBF = 0;
0554  0027     MOVLB 0x7
0555  0196     CLRF TMR1L
229:           }
0556  0008     RETURN
230:           
231:           void UpdateFanSpeed(void)
232:           {
233:               TMR1GIF = TMR1IF = 0;
234:               IOCAF3 = 0; // skip one cycle
235:               TMR1ON = 0;
236:               Status.FanSpeed = TMR1H; // rollover below 330 rpm, not measured
237:               FAN_PWM = 0; // re-enable PWM fan output
238:               PWM1OE=1;
239:           }
240:           
241:           // Init functions
242:           
243:           void InitFAN(void)
244:           {
245:               FAN_TRIS = 1;
246:               PWM1CON = 0;
247:               PR2 = 0xFF;
248:               PWM1CON = 0xC0;
249:               PWM1DCH = DEFAULT_FAN_TARGET;
250:               PWM1DCL = 0;
251:               TMR2IF = 0;
252:               T2CONbits.T2CKPS = 0;
253:               TMR2ON = 1;
254:               FAN_TRIS = 0;
255:               PWM1OE=1;
256:           
257:               // for Fan Tach reading
258:               T1GSEL = 1;
259:               IOCAN3 = 1;
260:               IOCAF3 = 0;
261:           }
262:           
263:           void InitTempSensor(void)
264:           { 
265:               THERM_TRIS=1;
0F07  0021     MOVLB 0x1
0F08  150E     BSF PORTC, 0x2
266:               //TEMP_INIT;
267:               //FVREN = 1;
268:               ADCON0bits.CHS = TEMP_THERMISTOR;
0F09  081D     MOVF 0x1D, W
0F0A  3983     ANDLW 0x83
0F0B  3818     IORLW 0x18
0F0C  009D     MOVWF 0x1D
269:               ADCON0bits.ADON = 1;
0F0D  141D     BSF 0x1D, 0x0
270:               ADCON1bits.ADFM = 0;
0F0E  139E     BCF 0x1E, 0x7
271:               ADCON1bits.ADCS = 6;
0F0F  081E     MOVF 0x1E, W
0F10  398F     ANDLW 0x8F
0F11  3860     IORLW 0x60
0F12  009E     MOVWF 0x1E
272:               ADCON1bits.ADPREF = 0;
0F13  30FC     MOVLW 0xFC
0F14  059E     ANDWF 0x1E, F
273:               ADCON2bits.TRIGSEL = 0;
0F15  308F     MOVLW 0x8F
0F16  059F     ANDWF 0x1F, F
274:           }
0F17  0008     RETURN
275:           
276:           void InitWorkTick(void)
277:           {
278:               TMR0CS = 0;
0E09  1295     BCF TMR0, 0x5
279:               OPTION_REGbits.PSA = 0;
0E0A  1195     BCF TMR0, 0x3
280:               OPTION_REGbits.PS = 7;
0E0B  3007     MOVLW 0x7
0E0C  0495     IORWF TMR0, F
281:               TMR0 = HashTime;
0E0D  0022     MOVLB 0x2
0E0E  084E     MOVF 0x4E, W
0E0F  0020     MOVLB 0x0
0E10  0095     MOVWF TMR0
282:               //TMR0IE = 1;
283:           
284:               HASH_TRIS_0P = 0;
0E11  0021     MOVLB 0x1
0E12  138E     BCF PORTC, 0x7
285:               HASH_TRIS_0N = 0;
0E13  130E     BCF PORTC, 0x6
286:               HASH_TRIS_1P = 0;
0E14  120E     BCF PORTC, 0x4
287:               HASH_TRIS_1N = 0;
0E15  118E     BCF PORTC, 0x3
288:               HASH_IDLE();
0E16  30D8     MOVLW 0xD8
0E17  0022     MOVLB 0x2
0E18  008E     MOVWF PORTC
289:               HASH_CLK_TRIS = 0;
0E19  0021     MOVLB 0x1
0E1A  120C     BCF PORTA, 0x4
290:               HASH_CLK_EN = 1;
0E1B  0022     MOVLB 0x2
0E1C  160C     BSF PORTA, 0x4
291:           }
0E1D  0008     RETURN
292:           
293:           void InitResultRx(void)
294:           {
295:               ResultQC = 0;
0F4B  01CD     CLRF 0x4D
296:               TXSTAbits.SYNC = 1;
0F4C  0023     MOVLB 0x3
0F4D  161E     BSF 0x1E, 0x4
297:               RCSTAbits.SPEN = 1;
0F4E  179D     BSF 0x1D, 0x7
298:               TXSTAbits.CSRC = 0;
0F4F  139E     BCF 0x1E, 0x7
299:               BAUDCONbits.SCKP = 1;
0F50  161F     BSF 0x1F, 0x4
300:               ANSELBbits.ANSB5 = 0;
0F51  128D     BCF PORTB, 0x5
301:               //PIE1bits.RCIE = 1;
302:               IOCBPbits.IOCBP7 = 1;
0F52  0027     MOVLB 0x7
0F53  1794     BSF 0x14, 0x7
303:               INTCONbits.IOCIE = 1;
0F54  158B     BSF INTCON, 0x3
304:               IOCBF = 0;
0F55  0196     CLRF TMR1L
305:               //INTCONbits.PEIE = 1;
306:               INTCONbits.GIE = 1;
0F56  178B     BSF INTCON, 0x7
307:               RCSTAbits.CREN = 1;
0F57  0023     MOVLB 0x3
0F58  161D     BSF 0x1D, 0x4
308:               RCREG = 0xFF;
0F59  30FF     MOVLW 0xFF
0F5A  0099     MOVWF T1GCON
309:           }
0F5B  0008     RETURN
---  /home/chris/Dev/klondike/firmware/Klondike.X/asic.c  -----------------------------------------------
1:             /********
2:              * Klondike ASIC Miner - asic.c - ASIC serial data shifting support
3:              * 
4:              * (C) Copyright 2013 Chris Savery. 
5:              *
6:              * This program is free software: you can redistribute it and/or modify
7:              * it under the terms of the GNU General Public License as published by
8:              * the Free Software Foundation, either version 3 of the License, or
9:              * (at your option) any later version.
10:             *
11:             * This program is distributed in the hope that it will be useful,
12:             * but WITHOUT ANY WARRANTY; without even the implied warranty of
13:             * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
14:             * GNU General Public License for more details.
15:             *
16:             * You should have received a copy of the GNU General Public License
17:             * along with this program.  If not, see <http://www.gnu.org/licenses/>.
18:             *
19:             */
20:            #include "GenericTypeDefs.h"
21:            #include "Compiler.h"
22:            #include <xc.h>
23:            #include "klondike.h"
24:            
25:            extern BYTE BankSize;
26:            extern DWORD ClockCfg[2];
27:            extern DWORD NonceRanges[8];
28:            
29:            DWORD PrecalcHashes[6];
30:            
31:            bank2 WORD send32_data; // place in same bank as latc registers!
32:            bank2 BYTE send32_count; // count DWORDS
33:            bank2 BYTE last_bit0, last_bit1;
34:            
35:            void SendAsicData(WORKTASK *work, BYTE split)
36:            {
37:                GIE = 0;
0A8C  138B     BCF INTCON, 0x7
38:                last_bit0 = DATA_ZERO; last_bit1 = DATA_ONE;
0A8D  3048     MOVLW 0x48
0A8E  0022     MOVLB 0x2
0A8F  00BC     MOVWF 0x3C
0A90  3090     MOVLW 0x90
0A91  00BD     MOVWF 0x3D
39:                send32_data = (WORD)&ClockCfg; send32_count = 2;
0A92  305C     MOVLW 0x5C
0A93  00AC     MOVWF 0x2C
0A94  3001     MOVLW 0x1
0A95  00AD     MOVWF 0x2D
0A96  3002     MOVLW 0x2
0A97  00BF     MOVWF 0x3F
40:                Send32();
0A98  22D2     CALL 0x2D2
0A99  3188     MOVLP 0x8
41:                send32_data = (WORD)&work->Merkle; send32_count = 3;
0A9A  26CB     CALL 0x6CB
0A9B  3188     MOVLP 0x8
0A9C  3021     MOVLW 0x21
0A9D  07AC     ADDWF 0x2C, F
0A9E  1803     BTFSC STATUS, 0x0
0A9F  0AAD     INCF 0x2D, F
0AA0  3003     MOVLW 0x3
0AA1  00BF     MOVWF 0x3F
42:                Send32();
0AA2  22D2     CALL 0x2D2
0AA3  3188     MOVLP 0x8
43:                send32_data = (WORD)&PrecalcHashes[1]; send32_count = 5;
0AA4  30C4     MOVLW 0xC4
0AA5  0022     MOVLB 0x2
0AA6  00AC     MOVWF 0x2C
0AA7  3001     MOVLW 0x1
0AA8  00AD     MOVWF 0x2D
0AA9  3005     MOVLW 0x5
0AAA  00BF     MOVWF 0x3F
44:                Send32();
0AAB  22D2     CALL 0x2D2
0AAC  3188     MOVLP 0x8
0AAD  26CB     CALL 0x6CB
0AAE  3188     MOVLP 0x8
45:                send32_data = (WORD)&work->MidState; send32_count = 8;
0AAF  0AAC     INCF 0x2C, F
0AB0  1903     BTFSC STATUS, 0x2
0AB1  0AAD     INCF 0x2D, F
0AB2  3008     MOVLW 0x8
0AB3  00BF     MOVWF 0x3F
46:                Send32();
0AB4  22D2     CALL 0x2D2
0AB5  3188     MOVLP 0x8
47:                send32_data = (WORD)&PrecalcHashes; send32_count = 1;
0AB6  30C0     MOVLW 0xC0
0AB7  0022     MOVLB 0x2
0AB8  00AC     MOVWF 0x2C
0AB9  3001     MOVLW 0x1
0ABA  00AD     MOVWF 0x2D
0ABB  01BF     CLRF 0x3F
0ABC  0ABF     INCF 0x3F, F
48:                Send32();
0ABD  22D2     CALL 0x2D2
0ABE  3188     MOVLP 0x8
49:                // disable for single bank last_bit0 = last_bit1 = split;
50:                send32_data = (WORD)&NonceRanges; send32_count = BankSize;
0ABF  30A0     MOVLW 0xA0
0AC0  0022     MOVLB 0x2
0AC1  00AC     MOVWF 0x2C
0AC2  3001     MOVLW 0x1
0AC3  00AD     MOVWF 0x2D
0AC4  086A     MOVF pBDTEntryIn, W
0AC5  00BF     MOVWF 0x3F
51:                Send32();
0AC6  22D2     CALL 0x2D2
52:                HASH_IDLE();
0AC7  30D8     MOVLW 0xD8
0AC8  0022     MOVLB 0x2
0AC9  008E     MOVWF PORTC
53:                GIE = 1;
0ACA  178B     BSF INTCON, 0x7
54:                ClockCfg[0] = ClockCfg[0] & ~CLOCK_NOCHG_MASK;
0ACB  30FD     MOVLW 0xFD
0ACC  05DC     ANDWF work, F
0ACD  30FF     MOVLW 0xFF
0ACE  05DD     ANDWF y, F
0ACF  05DE     ANDWF data, F
0AD0  05DF     ANDWF handle, F
55:            }
0AD1  0008     RETURN
56:            
57:            void Send32(void)
58:            {
59:                #asm
60:                BANKSEL(LATC) 
0AD2  0022     MOVLB 0x2
61:                MOVF (_send32_data) & 0x7F, W
0AD3  082C     MOVF 0x2C, W
62:                MOVWF FSR1L
0AD4  0086     MOVWF FSR1L
63:                MOVF (_send32_data+1) & 0x7F, W
0AD5  082D     MOVF 0x2D, W
64:                MOVWF FSR1H
0AD6  0087     MOVWF FSR1H
65:            
66:            next_word:
67:                // bit 0
68:                MOVLW DATA_ZERO
0AD7  3048     MOVLW 0x48
69:                CLRF LATC & 0x7F
0AD8  018E     CLRF PORTC
70:                BTFSC INDF1,0
0AD9  1801     BTFSC INDF1, 0x0
71:                MOVLW DATA_ONE
0ADA  3090     MOVLW 0x90
72:                MOVWF LATC & 0x7F
0ADB  008E     MOVWF PORTC
73:            
74:                // bit 1
75:                MOVLW DATA_ZERO
0ADC  3048     MOVLW 0x48
76:                CLRF LATC & 0x7F
0ADD  018E     CLRF PORTC
77:                BTFSC INDF1,1
0ADE  1881     BTFSC INDF1, 0x1
78:                MOVLW DATA_ONE
0ADF  3090     MOVLW 0x90
79:                MOVWF LATC & 0x7F
0AE0  008E     MOVWF PORTC
80:            
81:                // bit 2
82:                MOVLW DATA_ZERO
0AE1  3048     MOVLW 0x48
83:                CLRF LATC & 0x7F
0AE2  018E     CLRF PORTC
84:                BTFSC INDF1,2
0AE3  1901     BTFSC INDF1, 0x2
85:                MOVLW DATA_ONE
0AE4  3090     MOVLW 0x90
86:                MOVWF LATC & 0x7F
0AE5  008E     MOVWF PORTC
87:            
88:                // bit 3
89:                MOVLW DATA_ZERO
0AE6  3048     MOVLW 0x48
90:                CLRF LATC & 0x7F
0AE7  018E     CLRF PORTC
91:                BTFSC INDF1,3
0AE8  1981     BTFSC INDF1, 0x3
92:                MOVLW DATA_ONE
0AE9  3090     MOVLW 0x90
93:                MOVWF LATC & 0x7F
0AEA  008E     MOVWF PORTC
94:            
95:                // bit 4
96:                MOVLW DATA_ZERO
0AEB  3048     MOVLW 0x48
97:                CLRF LATC & 0x7F
0AEC  018E     CLRF PORTC
98:                BTFSC INDF1,4
0AED  1A01     BTFSC INDF1, 0x4
99:                MOVLW DATA_ONE
0AEE  3090     MOVLW 0x90
100:               MOVWF LATC & 0x7F
0AEF  008E     MOVWF PORTC
101:           
102:               // bit 5
103:               MOVLW DATA_ZERO
0AF0  3048     MOVLW 0x48
104:               CLRF LATC & 0x7F
0AF1  018E     CLRF PORTC
105:               BTFSC INDF1,5
0AF2  1A81     BTFSC INDF1, 0x5
106:               MOVLW DATA_ONE
0AF3  3090     MOVLW 0x90
107:               MOVWF LATC & 0x7F
0AF4  008E     MOVWF PORTC
108:           
109:               // bit 6
110:               MOVLW DATA_ZERO
0AF5  3048     MOVLW 0x48
111:               CLRF LATC & 0x7F
0AF6  018E     CLRF PORTC
112:               BTFSC INDF1,6
0AF7  1B01     BTFSC INDF1, 0x6
113:               MOVLW DATA_ONE
0AF8  3090     MOVLW 0x90
114:               MOVWF LATC & 0x7F
0AF9  008E     MOVWF PORTC
115:           
116:               // bit 7
117:               MOVLW DATA_ZERO
0AFA  3048     MOVLW 0x48
118:               CLRF LATC & 0x7F
0AFB  018E     CLRF PORTC
119:               BTFSC INDF1,7
0AFC  1B81     BTFSC INDF1, 0x7
120:               MOVLW DATA_ONE
0AFD  3090     MOVLW 0x90
121:               MOVWF LATC & 0x7F
0AFE  008E     MOVWF PORTC
122:           
123:               // select next byte
124:               ADDFSR FSR1, 0x01 & 0x3F
0AFF  3141     ADDFSR 1, 1
125:           
126:               // bit 8
127:               MOVLW DATA_ZERO
0B00  3048     MOVLW 0x48
128:               CLRF LATC & 0x7F
0B01  018E     CLRF PORTC
129:               BTFSC INDF1,0
0B02  1801     BTFSC INDF1, 0x0
130:               MOVLW DATA_ONE
0B03  3090     MOVLW 0x90
131:               MOVWF LATC & 0x7F
0B04  008E     MOVWF PORTC
132:           
133:               // bit 9
134:               MOVLW DATA_ZERO
0B05  3048     MOVLW 0x48
135:               CLRF LATC & 0x7F
0B06  018E     CLRF PORTC
136:               BTFSC INDF1,1
0B07  1881     BTFSC INDF1, 0x1
137:               MOVLW DATA_ONE
0B08  3090     MOVLW 0x90
138:               MOVWF LATC & 0x7F
0B09  008E     MOVWF PORTC
139:           
140:               // bit 10
141:               MOVLW DATA_ZERO
0B0A  3048     MOVLW 0x48
142:               CLRF LATC & 0x7F
0B0B  018E     CLRF PORTC
143:               BTFSC INDF1,2
0B0C  1901     BTFSC INDF1, 0x2
144:               MOVLW DATA_ONE
0B0D  3090     MOVLW 0x90
145:               MOVWF LATC & 0x7F
0B0E  008E     MOVWF PORTC
146:           
147:               // bit 11
148:               MOVLW DATA_ZERO
0B0F  3048     MOVLW 0x48
149:               CLRF LATC & 0x7F
0B10  018E     CLRF PORTC
150:               BTFSC INDF1,3
0B11  1981     BTFSC INDF1, 0x3
151:               MOVLW DATA_ONE
0B12  3090     MOVLW 0x90
152:               MOVWF LATC & 0x7F
0B13  008E     MOVWF PORTC
153:           
154:               // bit 12
155:               MOVLW DATA_ZERO
0B14  3048     MOVLW 0x48
156:               CLRF LATC & 0x7F
0B15  018E     CLRF PORTC
157:               BTFSC INDF1,4
0B16  1A01     BTFSC INDF1, 0x4
158:               MOVLW DATA_ONE
0B17  3090     MOVLW 0x90
159:               MOVWF LATC & 0x7F
0B18  008E     MOVWF PORTC
160:           
161:               // bit 13
162:               MOVLW DATA_ZERO
0B19  3048     MOVLW 0x48
163:               CLRF LATC & 0x7F
0B1A  018E     CLRF PORTC
164:               BTFSC INDF1,5
0B1B  1A81     BTFSC INDF1, 0x5
165:               MOVLW DATA_ONE
0B1C  3090     MOVLW 0x90
166:               MOVWF LATC & 0x7F
0B1D  008E     MOVWF PORTC
167:           
168:               // bit 14
169:               MOVLW DATA_ZERO
0B1E  3048     MOVLW 0x48
170:               CLRF LATC & 0x7F
0B1F  018E     CLRF PORTC
171:               BTFSC INDF1,6
0B20  1B01     BTFSC INDF1, 0x6
172:               MOVLW DATA_ONE
0B21  3090     MOVLW 0x90
173:               MOVWF LATC & 0x7F
0B22  008E     MOVWF PORTC
174:           
175:               // bit 15
176:               MOVLW DATA_ZERO
0B23  3048     MOVLW 0x48
177:               CLRF LATC & 0x7F
0B24  018E     CLRF PORTC
178:               BTFSC INDF1,7
0B25  1B81     BTFSC INDF1, 0x7
179:               MOVLW DATA_ONE
0B26  3090     MOVLW 0x90
180:               MOVWF LATC & 0x7F
0B27  008E     MOVWF PORTC
181:           
182:               // select next byte
183:               ADDFSR FSR1, 0x01 & 0x3F
0B28  3141     ADDFSR 1, 1
184:           
185:               // bit 16
186:               MOVLW DATA_ZERO
0B29  3048     MOVLW 0x48
187:               CLRF LATC & 0x7F
0B2A  018E     CLRF PORTC
188:               BTFSC INDF1,0
0B2B  1801     BTFSC INDF1, 0x0
189:               MOVLW DATA_ONE
0B2C  3090     MOVLW 0x90
190:               MOVWF LATC & 0x7F
0B2D  008E     MOVWF PORTC
191:           
192:               // bit 17
193:               MOVLW DATA_ZERO
0B2E  3048     MOVLW 0x48
194:               CLRF LATC & 0x7F
0B2F  018E     CLRF PORTC
195:               BTFSC INDF1,1
0B30  1881     BTFSC INDF1, 0x1
196:               MOVLW DATA_ONE
0B31  3090     MOVLW 0x90
197:               MOVWF LATC & 0x7F
0B32  008E     MOVWF PORTC
198:           
199:               // bit 18
200:               MOVLW DATA_ZERO
0B33  3048     MOVLW 0x48
201:               CLRF LATC & 0x7F
0B34  018E     CLRF PORTC
202:               BTFSC INDF1,2
0B35  1901     BTFSC INDF1, 0x2
203:               MOVLW DATA_ONE
0B36  3090     MOVLW 0x90
204:               MOVWF LATC & 0x7F
0B37  008E     MOVWF PORTC
205:           
206:               // bit 19
207:               MOVLW DATA_ZERO
0B38  3048     MOVLW 0x48
208:               CLRF LATC & 0x7F
0B39  018E     CLRF PORTC
209:               BTFSC INDF1,3
0B3A  1981     BTFSC INDF1, 0x3
210:               MOVLW DATA_ONE
0B3B  3090     MOVLW 0x90
211:               MOVWF LATC & 0x7F
0B3C  008E     MOVWF PORTC
212:           
213:               // bit 20
214:               MOVLW DATA_ZERO
0B3D  3048     MOVLW 0x48
215:               CLRF LATC & 0x7F
0B3E  018E     CLRF PORTC
216:               BTFSC INDF1,4
0B3F  1A01     BTFSC INDF1, 0x4
217:               MOVLW DATA_ONE
0B40  3090     MOVLW 0x90
218:               MOVWF LATC & 0x7F
0B41  008E     MOVWF PORTC
219:           
220:               // bit 21
221:               MOVLW DATA_ZERO
0B42  3048     MOVLW 0x48
222:               CLRF LATC & 0x7F
0B43  018E     CLRF PORTC
223:               BTFSC INDF1,5
0B44  1A81     BTFSC INDF1, 0x5
224:               MOVLW DATA_ONE
0B45  3090     MOVLW 0x90
225:               MOVWF LATC & 0x7F
0B46  008E     MOVWF PORTC
226:           
227:               // bit 22
228:               MOVLW DATA_ZERO
0B47  3048     MOVLW 0x48
229:               CLRF LATC & 0x7F
0B48  018E     CLRF PORTC
230:               BTFSC INDF1,6
0B49  1B01     BTFSC INDF1, 0x6
231:               MOVLW DATA_ONE
0B4A  3090     MOVLW 0x90
232:               MOVWF LATC & 0x7F
0B4B  008E     MOVWF PORTC
233:           
234:               // bit 23
235:               MOVLW DATA_ZERO
0B4C  3048     MOVLW 0x48
236:               CLRF LATC & 0x7F
0B4D  018E     CLRF PORTC
237:               BTFSC INDF1,7
0B4E  1B81     BTFSC INDF1, 0x7
238:               MOVLW DATA_ONE
0B4F  3090     MOVLW 0x90
239:               MOVWF LATC & 0x7F
0B50  008E     MOVWF PORTC
240:           
241:               // select next byte
242:               ADDFSR FSR1, 0x01 & 0x3F
0B51  3141     ADDFSR 1, 1
243:           
244:               // bit 24
245:               MOVLW DATA_ZERO
0B52  3048     MOVLW 0x48
246:               CLRF LATC & 0x7F
0B53  018E     CLRF PORTC
247:               BTFSC INDF1,0
0B54  1801     BTFSC INDF1, 0x0
248:               MOVLW DATA_ONE
0B55  3090     MOVLW 0x90
249:               MOVWF LATC & 0x7F
0B56  008E     MOVWF PORTC
250:           
251:               // bit 25
252:               MOVLW DATA_ZERO
0B57  3048     MOVLW 0x48
253:               CLRF LATC & 0x7F
0B58  018E     CLRF PORTC
254:               BTFSC INDF1,1
0B59  1881     BTFSC INDF1, 0x1
255:               MOVLW DATA_ONE
0B5A  3090     MOVLW 0x90
256:               MOVWF LATC & 0x7F
0B5B  008E     MOVWF PORTC
257:           
258:               // bit 26
259:               MOVLW DATA_ZERO
0B5C  3048     MOVLW 0x48
260:               CLRF LATC & 0x7F
0B5D  018E     CLRF PORTC
261:               BTFSC INDF1,2
0B5E  1901     BTFSC INDF1, 0x2
262:               MOVLW DATA_ONE
0B5F  3090     MOVLW 0x90
263:               MOVWF LATC & 0x7F
0B60  008E     MOVWF PORTC
264:           
265:               // bit 27
266:               MOVLW DATA_ZERO
0B61  3048     MOVLW 0x48
267:               CLRF LATC & 0x7F
0B62  018E     CLRF PORTC
268:               BTFSC INDF1,3
0B63  1981     BTFSC INDF1, 0x3
269:               MOVLW DATA_ONE
0B64  3090     MOVLW 0x90
270:               MOVWF LATC & 0x7F
0B65  008E     MOVWF PORTC
271:           
272:               // bit 28
273:               MOVLW DATA_ZERO
0B66  3048     MOVLW 0x48
274:               CLRF LATC & 0x7F
0B67  018E     CLRF PORTC
275:               BTFSC INDF1,4
0B68  1A01     BTFSC INDF1, 0x4
276:               MOVLW DATA_ONE
0B69  3090     MOVLW 0x90
277:               MOVWF LATC & 0x7F
0B6A  008E     MOVWF PORTC
278:           
279:               // bit 29
280:               MOVLW DATA_ZERO
0B6B  3048     MOVLW 0x48
281:               CLRF LATC & 0x7F
0B6C  018E     CLRF PORTC
282:               BTFSC INDF1,5
0B6D  1A81     BTFSC INDF1, 0x5
283:               MOVLW DATA_ONE
0B6E  3090     MOVLW 0x90
284:               MOVWF LATC & 0x7F
0B6F  008E     MOVWF PORTC
285:           
286:               // bit 30
287:               MOVLW DATA_ZERO
0B70  3048     MOVLW 0x48
288:               CLRF LATC & 0x7F
0B71  018E     CLRF PORTC
289:               BTFSC INDF1,6
0B72  1B01     BTFSC INDF1, 0x6
290:               MOVLW DATA_ONE
0B73  3090     MOVLW 0x90
291:               MOVWF LATC & 0x7F
0B74  008E     MOVWF PORTC
292:           
293:               // bit 31
294:               MOVF _last_bit0 & 0x7F,W
0B75  083C     MOVF 0x3C, W
295:               CLRF LATC & 0x7F
0B76  018E     CLRF PORTC
296:               BTFSC INDF1,7
0B77  1B81     BTFSC INDF1, 0x7
297:               MOVF _last_bit1 & 0x7F,W
0B78  083D     MOVF 0x3D, W
298:               MOVWF LATC & 0x7F
0B79  008E     MOVWF PORTC
299:           
300:               // select next byte
301:               ADDFSR FSR1, 0x01 & 0x3F
0B7A  3141     ADDFSR 1, 1
302:           
303:               // check if done
304:               DECFSZ _send32_count & 0x7F, F
0B7B  0BBF     DECFSZ 0x3F, F
305:               GOTO next_word
0B7C  2AD7     GOTO 0x2D7
306:               #endasm
307:               
308:           }
0B7D  0008     RETURN
309:           
310:           #define r(x) ((x-n)&7)
311:           
312:           DWORD rotate(DWORD x, BYTE y)
313:           {
314:               return ((x<<y) | (x>>(32-y)));
0D2E  0859     MOVF x, W
0D2F  00DE     MOVWF data
0D30  085A     MOVF i_718, W
0D31  00DF     MOVWF handle
0D32  085B     MOVF i, W
0D33  00E0     MOVWF count
0D34  085C     MOVF work, W
0D35  00E1     MOVWF 0x61
0D36  085D     MOVF y, W
0D37  3C20     SUBLW 0x20
0D38  0A89     INCF WREG, F
0D39  2D3F     GOTO 0x53F
0D3A  1003     BCF STATUS, 0x0
0D3B  0CE1     RRF 0x61, F
0D3C  0CE0     RRF count, F
0D3D  0CDF     RRF handle, F
0D3E  0CDE     RRF data, F
0D3F  3EFF     ADDLW 0xFF
0D40  1D03     BTFSS STATUS, 0x2
0D41  2D3A     GOTO 0x53A
0D42  0859     MOVF x, W
0D43  00E2     MOVWF 0x62
0D44  085A     MOVF i_718, W
0D45  00E3     MOVWF 0x63
0D46  085B     MOVF i, W
0D47  00E4     MOVWF 0x64
0D48  085C     MOVF work, W
0D49  00E5     MOVWF p
0D4A  0A5D     INCF y, W
0D4B  2D50     GOTO 0x550
0D4C  35E2     LSLF 0x62, F
0D4D  0DE3     RLF 0x63, F
0D4E  0DE4     RLF 0x64, F
0D4F  0DE5     RLF p, F
0D50  0B89     DECFSZ WREG, F
0D51  2D4C     GOTO 0x54C
0D52  0862     MOVF 0x62, W
0D53  04DE     IORWF data, F
0D54  0863     MOVF 0x63, W
0D55  04DF     IORWF handle, F
0D56  0864     MOVF 0x64, W
0D57  04E0     IORWF count, F
0D58  0865     MOVF p, W
0D59  04E1     IORWF 0x61, F
0D5A  0861     MOVF 0x61, W
0D5B  00DC     MOVWF work
0D5C  0860     MOVF count, W
0D5D  00DB     MOVWF i
0D5E  085F     MOVF handle, W
0D5F  00DA     MOVWF i_718
0D60  085E     MOVF data, W
0D61  00D9     MOVWF x
315:           }
0D62  0008     RETURN
316:           
317:           void AsicPreCalc(WORKTASK *work)
318:           {
319:               DWORD K[3] = { 0x428a2f98, 0x71374491, 0xb5c0fbcf };
07F0  3498     RETLW 0x98
07F1  342F     RETLW 0x2F
07F2  348A     RETLW 0x8A
07F3  3442     RETLW 0x42
07F4  3491     RETLW 0x91
07F5  3444     RETLW 0x44
07F6  3437     RETLW 0x37
07F7  3471     RETLW 0x71
07F8  34CF     RETLW 0xCF
07F9  34FB     RETLW 0xFB
07FA  34C0     RETLW 0xC0
07FB  34B5     RETLW 0xB5
07FC  3FFF     MOVWI [-1]FSR1
07FD  3FFF     MOVWI [-1]FSR1
07FE  3FFF     MOVWI [-1]FSR1
07FF  3FFF     MOVWI [-1]FSR1
0800  3FFF     MOVWI [-1]FSR1
0801  3FFF     MOVWI [-1]FSR1
0802  3FFF     MOVWI [-1]FSR1
0803  3FFF     MOVWI [-1]FSR1
0804  3FFF     MOVWI [-1]FSR1
0805  3FFF     MOVWI [-1]FSR1
0806  3FFF     MOVWI [-1]FSR1
0B7E  30D8     MOVLW 0xD8
0B7F  0086     MOVWF FSR1L
0B80  3001     MOVLW 0x1
0B81  0087     MOVWF FSR1H
0B82  30A8     MOVLW 0xA8
0B83  0084     MOVWF FSR0L
0B84  3000     MOVLW 0x0
0B85  0085     MOVWF FSR0H
0B86  300C     MOVLW 0xC
0B87  00FF     MOVWF 0x7F
0B88  0016     MOVIW FSR1++
0B89  001A     MOVWI FSR0++
0B8A  0BFF     DECFSZ 0x7F, F
0B8B  2B88     GOTO 0x388
320:               DWORD x, y, z;
321:               DWORD m[8];
322:               BYTE n;
323:               
324:               for(n = 0; n < 8; n++)
0B8C  0021     MOVLB 0x1
0B8D  01E0     CLRF count
0BA4  3008     MOVLW 0x8
0BA5  0AE0     INCF count, F
0BA6  0260     SUBWF count, W
0BA7  1C03     BTFSS STATUS, 0x0
0BA8  2B8E     GOTO 0x38E
325:                   m[n] = work->MidState[n];
0B8E  2673     CALL 0x673
0B8F  3188     MOVLP 0x8
0B90  0086     MOVWF FSR1L
0B91  0823     MOVF 0x23, W
0B92  0087     MOVWF FSR1H
0B93  3141     ADDFSR 1, 1
0B94  26AD     CALL 0x6AD
0B95  3188     MOVLP 0x8
0B96  0860     MOVF count, W
0B97  0709     ADDWF WREG, W
0B98  0709     ADDWF WREG, W
0B99  3EB8     ADDLW 0xB8
0B9A  0086     MOVWF FSR1L
0B9B  0187     CLRF FSR1H
0B9C  0824     MOVF 0x24, W
0B9D  3FC0     MOVWI [0]FSR1
0B9E  0825     MOVF 0x25, W
0B9F  3FC1     MOVWI [1]FSR1
0BA0  0826     MOVF 0x26, W
0BA1  3FC2     MOVWI [2]FSR1
0BA2  0827     MOVF 0x27, W
0BA3  3FC3     MOVWI [3]FSR1
326:           
327:               for(n = 0; n < 3; n++) {
0BA9  01E0     CLRF count
0D1B  3003     MOVLW 0x3
0D1C  0AE0     INCF count, F
0D1D  0260     SUBWF count, W
0D1E  1803     BTFSC STATUS, 0x0
0D1F  0008     RETURN
0D20  2BAA     GOTO 0x3AA
328:           
329:                   x = m[5-n] ^ m[6-n];
0BAA  2645     CALL 0x645
0BAB  3188     MOVLP 0x8
0BAC  2521     CALL 0x521
0BAD  3188     MOVLP 0x8
0BAE  3E18     ADDLW 0x18
0BAF  261E     CALL 0x61E
0BB0  3188     MOVLP 0x8
0BB1  2521     CALL 0x521
0BB2  3188     MOVLP 0x8
0BB3  3E14     ADDLW 0x14
0BB4  3EB8     ADDLW 0xB8
0BB5  0086     MOVWF FSR1L
0BB6  0187     CLRF FSR1H
0BB7  3F40     MOVIW [0]FSR1
0BB8  0021     MOVLB 0x1
0BB9  00A4     MOVWF 0x24
0BBA  3F41     MOVIW [1]FSR1
0BBB  00A5     MOVWF 0x25
0BBC  3F42     MOVIW [2]FSR1
0BBD  00A6     MOVWF 0x26
0BBE  3F43     MOVIW [3]FSR1
0BBF  00A7     MOVWF 0x27
0BC0  0820     MOVF BDT, W
0BC1  0624     XORWF 0x24, W
0BC2  00DC     MOVWF work
0BC3  0821     MOVF 0x21, W
0BC4  0625     XORWF 0x25, W
0BC5  00DD     MOVWF y
0BC6  0822     MOVF 0x22, W
0BC7  0626     XORWF 0x26, W
0BC8  00DE     MOVWF data
0BC9  0823     MOVF 0x23, W
0BCA  0627     XORWF 0x27, W
0BCB  00DF     MOVWF handle
0BCC  2645     CALL 0x645
0BCD  3188     MOVLP 0x8
330:                   x = x & m[4-n];
0BCE  2521     CALL 0x521
0BCF  3188     MOVLP 0x8
0BD0  3E10     ADDLW 0x10
0BD1  3EB8     ADDLW 0xB8
0BD2  2630     CALL 0x630
0BD3  3188     MOVLP 0x8
0BD4  26E2     CALL 0x6E2
0BD5  3188     MOVLP 0x8
0BD6  2645     CALL 0x645
0BD7  3188     MOVLP 0x8
331:                   x = m[6-n] ^ x;
0BD8  2521     CALL 0x521
0BD9  3188     MOVLP 0x8
0BDA  3E18     ADDLW 0x18
0BDB  3EB8     ADDLW 0xB8
0BDC  2630     CALL 0x630
0BDD  3188     MOVLP 0x8
0BDE  06DC     XORWF work, F
0BDF  0821     MOVF 0x21, W
0BE0  06DD     XORWF y, F
0BE1  0822     MOVF 0x22, W
0BE2  06DE     XORWF data, F
0BE3  0823     MOVF 0x23, W
0BE4  06DF     XORWF handle, F
332:                   x += K[n];
0BE5  0860     MOVF count, W
0BE6  0709     ADDWF WREG, W
0BE7  0709     ADDWF WREG, W
0BE8  3EA8     ADDLW 0xA8
0BE9  0086     MOVWF FSR1L
0BEA  3F40     MOVIW [0]FSR1
0BEB  26BB     CALL 0x6BB
0BEC  3188     MOVLP 0x8
0BED  2673     CALL 0x673
0BEE  3188     MOVLP 0x8
333:                   x += work->Merkle[n];
0BEF  3E21     ADDLW 0x21
0BF0  0086     MOVWF FSR1L
0BF1  3000     MOVLW 0x0
0BF2  3D23     ADDWFC 0x23, W
0BF3  0087     MOVWF FSR1H
0BF4  3F40     MOVIW [0]FSR1
0BF5  26BB     CALL 0x6BB
0BF6  3188     MOVLP 0x8
0BF7  2645     CALL 0x645
0BF8  3188     MOVLP 0x8
334:                   x += m[7-n];
0BF9  2521     CALL 0x521
0BFA  3188     MOVLP 0x8
0BFB  3E1C     ADDLW 0x1C
0BFC  3EB8     ADDLW 0xB8
0BFD  0086     MOVWF FSR1L
0BFE  0187     CLRF FSR1H
0BFF  3F40     MOVIW [0]FSR1
0C00  0021     MOVLB 0x1
0C01  26BB     CALL 0x6BB
0C02  3188     MOVLP 0x8
0C03  2645     CALL 0x645
0C04  3188     MOVLP 0x8
335:                   y = rotate(m[4-n], 26);
0C05  2521     CALL 0x521
0C06  3188     MOVLP 0x8
0C07  2663     CALL 0x663
0C08  3188     MOVLP 0x8
0C09  265B     CALL 0x65B
0C0A  3188     MOVLP 0x8
0C0B  301A     MOVLW 0x1A
0C0C  00DD     MOVWF y
0C0D  252E     CALL 0x52E
0C0E  3188     MOVLP 0x8
0C0F  264B     CALL 0x64B
0C10  3188     MOVLP 0x8
0C11  2645     CALL 0x645
0C12  3188     MOVLP 0x8
336:                   z = rotate(m[4-n], 21);
0C13  2521     CALL 0x521
0C14  3188     MOVLP 0x8
0C15  2663     CALL 0x663
0C16  3188     MOVLP 0x8
0C17  265B     CALL 0x65B
0C18  3188     MOVLP 0x8
0C19  3015     MOVLW 0x15
0C1A  00DD     MOVWF y
0C1B  252E     CALL 0x52E
0C1C  3188     MOVLP 0x8
0C1D  085C     MOVF work, W
0C1E  0021     MOVLB 0x1
0C1F  00B7     MOVWF 0x37
0C20  0020     MOVLB 0x0
0C21  085B     MOVF i, W
0C22  0021     MOVLB 0x1
0C23  00B6     MOVWF 0x36
0C24  0020     MOVLB 0x0
0C25  085A     MOVF i_718, W
0C26  0021     MOVLB 0x1
0C27  00B5     MOVWF 0x35
0C28  0020     MOVLB 0x0
0C29  0859     MOVF x, W
0C2A  0021     MOVLB 0x1
0C2B  00B4     MOVWF 0x34
337:                   z = y^z;
0C2C  0858     MOVF p, W
0C2D  26DA     CALL 0x6DA
0C2E  3188     MOVLP 0x8
0C2F  2645     CALL 0x645
0C30  3188     MOVLP 0x8
338:                   y = rotate(m[4-n], 7);
0C31  2521     CALL 0x521
0C32  3188     MOVLP 0x8
0C33  2663     CALL 0x663
0C34  3188     MOVLP 0x8
0C35  265B     CALL 0x65B
0C36  3188     MOVLP 0x8
0C37  3007     MOVLW 0x7
0C38  00DD     MOVWF y
0C39  252E     CALL 0x52E
0C3A  3188     MOVLP 0x8
0C3B  264B     CALL 0x64B
0C3C  3188     MOVLP 0x8
0C3D  26DA     CALL 0x6DA
0C3E  3188     MOVLP 0x8
339:                   z = y^z;
340:                   m[7-n] = z+x;
0C3F  0834     MOVF 0x34, W
0C40  075C     ADDWF work, W
0C41  00A0     MOVWF BDT
0C42  0835     MOVF 0x35, W
0C43  3D5D     ADDWFC y, W
0C44  00A1     MOVWF 0x21
0C45  0836     MOVF 0x36, W
0C46  3D5E     ADDWFC data, W
0C47  00A2     MOVWF 0x22
0C48  0837     MOVF 0x37, W
0C49  3D5F     ADDWFC handle, W
0C4A  00A3     MOVWF 0x23
0C4B  2645     CALL 0x645
0C4C  3188     MOVLP 0x8
0C4D  2521     CALL 0x521
0C4E  3188     MOVLP 0x8
0C4F  26F7     CALL 0x6F7
0C50  3188     MOVLP 0x8
0C51  2669     CALL 0x669
0C52  3188     MOVLP 0x8
0C53  2645     CALL 0x645
0C54  3188     MOVLP 0x8
341:                   m[3-n] = m[3-n] + m[7-n];
0C55  2521     CALL 0x521
0C56  3188     MOVLP 0x8
0C57  3E1C     ADDLW 0x1C
0C58  261E     CALL 0x61E
0C59  3188     MOVLP 0x8
0C5A  2521     CALL 0x521
0C5B  3188     MOVLP 0x8
0C5C  3E0C     ADDLW 0xC
0C5D  3EB8     ADDLW 0xB8
0C5E  0086     MOVWF FSR1L
0C5F  0187     CLRF FSR1H
0C60  3F40     MOVIW [0]FSR1
0C61  0021     MOVLB 0x1
0C62  07A0     ADDWF BDT, F
0C63  3F41     MOVIW [1]FSR1
0C64  3DA1     ADDWFC 0x21, F
0C65  3F42     MOVIW [2]FSR1
0C66  3DA2     ADDWFC 0x22, F
0C67  3F43     MOVIW [3]FSR1
0C68  3DA3     ADDWFC 0x23, F
0C69  2645     CALL 0x645
0C6A  3188     MOVLP 0x8
0C6B  2521     CALL 0x521
0C6C  3188     MOVLP 0x8
0C6D  3E0C     ADDLW 0xC
0C6E  3EB8     ADDLW 0xB8
0C6F  0086     MOVWF FSR1L
0C70  0187     CLRF FSR1H
0C71  2669     CALL 0x669
0C72  3188     MOVLP 0x8
342:                   x = rotate(m[r(0)], 30);
0C73  2686     CALL 0x686
0C74  3188     MOVLP 0x8
0C75  3F40     MOVIW [0]FSR1
0C76  0020     MOVLB 0x0
0C77  265B     CALL 0x65B
0C78  3188     MOVLP 0x8
0C79  301E     MOVLW 0x1E
0C7A  00DD     MOVWF y
0C7B  252E     CALL 0x52E
0C7C  3188     MOVLP 0x8
0C7D  2697     CALL 0x697
0C7E  3188     MOVLP 0x8
0C7F  2686     CALL 0x686
0C80  3188     MOVLP 0x8
343:                   y = rotate(m[r(0)], 19);
0C81  0187     CLRF FSR1H
0C82  3F40     MOVIW [0]FSR1
0C83  0020     MOVLB 0x0
0C84  265B     CALL 0x65B
0C85  3188     MOVLP 0x8
0C86  3013     MOVLW 0x13
0C87  00DD     MOVWF y
0C88  252E     CALL 0x52E
0C89  3188     MOVLP 0x8
0C8A  264B     CALL 0x64B
0C8B  3188     MOVLP 0x8
344:                   y = y^x;
0C8C  085C     MOVF work, W
0C8D  26C3     CALL 0x6C3
0C8E  3188     MOVLP 0x8
0C8F  2686     CALL 0x686
0C90  3188     MOVLP 0x8
345:                   x = rotate(m[r(0)], 10);
0C91  0187     CLRF FSR1H
0C92  3F40     MOVIW [0]FSR1
0C93  0020     MOVLB 0x0
0C94  265B     CALL 0x65B
0C95  3188     MOVLP 0x8
0C96  300A     MOVLW 0xA
0C97  00DD     MOVWF y
0C98  252E     CALL 0x52E
0C99  3188     MOVLP 0x8
0C9A  2697     CALL 0x697
0C9B  3188     MOVLP 0x8
0C9C  26C3     CALL 0x6C3
0C9D  3188     MOVLP 0x8
346:                   y = x^y;
347:                   x = m[r(0)] | m[r(1)];
0C9E  0860     MOVF count, W
0C9F  3C01     SUBLW 0x1
0CA0  26A7     CALL 0x6A7
0CA1  3188     MOVLP 0x8
0CA2  0187     CLRF FSR1H
0CA3  3F40     MOVIW [0]FSR1
0CA4  263D     CALL 0x63D
0CA5  3188     MOVLP 0x8
0CA6  2686     CALL 0x686
0CA7  3188     MOVLP 0x8
0CA8  26AD     CALL 0x6AD
0CA9  3188     MOVLP 0x8
0CAA  0820     MOVF BDT, W
0CAB  0424     IORWF 0x24, W
0CAC  00DC     MOVWF work
0CAD  0821     MOVF 0x21, W
0CAE  0425     IORWF 0x25, W
0CAF  00DD     MOVWF y
0CB0  0822     MOVF 0x22, W
0CB1  0426     IORWF 0x26, W
0CB2  00DE     MOVWF data
0CB3  0823     MOVF 0x23, W
0CB4  0427     IORWF 0x27, W
0CB5  00DF     MOVWF handle
348:                   x = m[r(2)] & x;
0CB6  0860     MOVF count, W
0CB7  3C02     SUBLW 0x2
0CB8  26A7     CALL 0x6A7
0CB9  3188     MOVLP 0x8
0CBA  3F40     MOVIW [0]FSR1
0CBB  263D     CALL 0x63D
0CBC  3188     MOVLP 0x8
0CBD  0820     MOVF BDT, W
0CBE  26E2     CALL 0x6E2
0CBF  3188     MOVLP 0x8
349:                   z = m[r(0)] & m[r(1)];
0CC0  0860     MOVF count, W
0CC1  3C01     SUBLW 0x1
0CC2  26A7     CALL 0x6A7
0CC3  3188     MOVLP 0x8
0CC4  3F40     MOVIW [0]FSR1
0CC5  263D     CALL 0x63D
0CC6  3188     MOVLP 0x8
0CC7  2686     CALL 0x686
0CC8  3188     MOVLP 0x8
0CC9  26AD     CALL 0x6AD
0CCA  3188     MOVLP 0x8
0CCB  0820     MOVF BDT, W
0CCC  0524     ANDWF 0x24, W
0CCD  00B4     MOVWF 0x34
0CCE  0821     MOVF 0x21, W
0CCF  0525     ANDWF 0x25, W
0CD0  00B5     MOVWF 0x35
0CD1  0822     MOVF 0x22, W
0CD2  0526     ANDWF 0x26, W
0CD3  00B6     MOVWF 0x36
0CD4  0823     MOVF 0x23, W
0CD5  0527     ANDWF 0x27, W
0CD6  00B7     MOVWF 0x37
350:                   x = x | z;
0CD7  0834     MOVF 0x34, W
0CD8  04DC     IORWF work, F
0CD9  0835     MOVF 0x35, W
0CDA  04DD     IORWF y, F
0CDB  0836     MOVF 0x36, W
0CDC  04DE     IORWF data, F
0CDD  0837     MOVF 0x37, W
0CDE  04DF     IORWF handle, F
351:                   m[7-n] += y + x;
0CDF  0858     MOVF p, W
0CE0  075C     ADDWF work, W
0CE1  00A0     MOVWF BDT
0CE2  0859     MOVF x, W
0CE3  3D5D     ADDWFC y, W
0CE4  00A1     MOVWF 0x21
0CE5  085A     MOVF i_718, W
0CE6  3D5E     ADDWFC data, W
0CE7  00A2     MOVWF 0x22
0CE8  085B     MOVF i, W
0CE9  3D5F     ADDWFC handle, W
0CEA  00A3     MOVWF 0x23
0CEB  2645     CALL 0x645
0CEC  3188     MOVLP 0x8
0CED  2521     CALL 0x521
0CEE  3188     MOVLP 0x8
0CEF  26F7     CALL 0x6F7
0CF0  3188     MOVLP 0x8
0CF1  0021     MOVLB 0x1
0CF2  0820     MOVF BDT, W
0CF3  0781     ADDWF INDF1, F
0CF4  3141     ADDFSR 1, 1
0CF5  0821     MOVF 0x21, W
0CF6  3D81     ADDWFC INDF1, F
0CF7  3141     ADDFSR 1, 1
0CF8  0822     MOVF 0x22, W
0CF9  3D81     ADDWFC INDF1, F
0CFA  3141     ADDFSR 1, 1
0CFB  0823     MOVF 0x23, W
0CFC  3D81     ADDWFC INDF1, F
0CFD  2645     CALL 0x645
0CFE  3188     MOVLP 0x8
352:           
353:                   PrecalcHashes[2-n] = m[7-n];
0CFF  2521     CALL 0x521
0D00  3188     MOVLP 0x8
0D01  3E1C     ADDLW 0x1C
0D02  261E     CALL 0x61E
0D03  3188     MOVLP 0x8
0D04  2521     CALL 0x521
0D05  3188     MOVLP 0x8
0D06  3EC8     ADDLW 0xC8
0D07  0086     MOVWF FSR1L
0D08  3001     MOVLW 0x1
0D09  0087     MOVWF FSR1H
0D0A  2669     CALL 0x669
0D0B  3188     MOVLP 0x8
0D0C  2645     CALL 0x645
0D0D  3188     MOVLP 0x8
354:                   PrecalcHashes[5-n] = m[3-n];
0D0E  2521     CALL 0x521
0D0F  3188     MOVLP 0x8
0D10  3E0C     ADDLW 0xC
0D11  261E     CALL 0x61E
0D12  3188     MOVLP 0x8
0D13  2521     CALL 0x521
0D14  3188     MOVLP 0x8
0D15  3ED4     ADDLW 0xD4
0D16  0086     MOVWF FSR1L
0D17  3001     MOVLW 0x1
0D18  0087     MOVWF FSR1H
0D19  2669     CALL 0x669
0D1A  3188     MOVLP 0x8
355:               }
356:           }
0D21  0020     MOVLB 0x0
357:           
358:           //#define R(a, b, c, d, e, f, g, h, w, k) \
359:           //    h = h + (rotate(e, 26) ^ rotate(e, 21) ^ rotate(e, 7)) + (g ^ (e & (f ^ g))) + k + w; \
360:           //    d = d + h; \
361:           //    h = h + (rotate(a, 30) ^ rotate(a, 19) ^ rotate(a, 10)) + ((a & b) | (c & (a | b)))
362:           
363:           /* this version uses too much stack and causes overflow
364:            * re-written above to be more flat and as first step to
365:            * assembly optimization
366:            *
367:           DWORD rotate(DWORD x, BYTE y)
368:           {
369:               return ((x<<y) | (x>>(32-y)));
370:           }
371:           
372:           void R1(DWORD *m, DWORD w, DWORD k)
373:           {
374:               m[7] = m[7] + (rotate(m[4], 26) ^ rotate(m[4], 21) ^ rotate(m[4], 7)) + (m[6] ^ (m[4] & (m[5] ^ m[6]))) + k + w;
375:               m[3] = m[3] + m[7];
376:               m[7] = m[7] + (rotate(m[0], 30) ^ rotate(m[0], 19) ^ rotate(m[0], 10)) + ((m[0] & m[1]) | (m[2] & (m[0] | m[1])));
377:           }
378:           
379:           void R2(DWORD *m)
380:           {
381:               DWORD hold = m[7];
382:               for(BYTE x=7; x > 0; x--)
383:                   m[x] = m[x-1];
384:               m[0] = hold;
385:           }
386:           
387:           extern BYTE WorkNow;
388:           extern WORKTASK WorkQue[MAX_WORK_COUNT];
389:           
390:           DWORD precalc_hash[6];
391:           
392:           void HasherPreCalc(void)
393:           {
394:               const DWORD K[3] = { 0x428a2f98, 0x71374491, 0xb5c0fbcf };
395:               DWORD m[8];
396:               BYTE n;
397:               for(n = 0; n < 8; n++)
398:                   m[n] = WorkQue[WorkNow].MidState[n];
399:           
400:               R1(m, WorkQue[WorkNow].Merkle[0], K[0]);
401:               precalc_hash[0] = m[7];
402:               precalc_hash[3] = m[3];
403:               R2(m);
404:               R1(m, WorkQue[WorkNow].Merkle[1], K[1]);
405:               precalc_hash[1] = m[7];
406:               precalc_hash[4] = m[3];
407:               R2(m);
408:               R1(m, WorkQue[WorkNow].Merkle[2], K[2]);
409:               precalc_hash[2] = m[7];
410:               precalc_hash[5] = m[3];
411:           }
412:           */
